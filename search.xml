<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>03. 설치 (IntelliJ 사용)</title>
    <url>/2020/08/12/hexo_1_Java_basic_03/</url>
    <content><![CDATA[<h1 id="Java-기초"><a href="#Java-기초" class="headerlink" title="Java 기초"></a>Java 기초</h1><h4 id="03-설치-IntelliJ-사용"><a href="#03-설치-IntelliJ-사용" class="headerlink" title="03. 설치 (IntelliJ 사용)"></a>03. 설치 (IntelliJ 사용)</h4><ul>
<li><p>아래 ORACLE URL을 통해 원하는 버전의 JDK를 설치한다.<br><a href="https://www.oracle.com/java/technologies/javase-downloads.html" target="_blank" rel="noopener">https://www.oracle.com/java/technologies/javase-downloads.html</a></p>
</li>
<li><p>Eclipse 또는 IntelliJ에서 새로운 프로젝트를 생성한다.<br>File &gt; New &gt; Project… &gt; Java 선택 &gt; Project SDK를 설치한 Java로 설정 &gt; Next &gt; Next &gt; Project 이름 및 Location 설정 &gt; Finish</p>
</li>
<li><p>간단한 프로그램 작성</p>
<ul>
<li>src에 ‘hello’ 패키지 생성 (Command+N Mac)</li>
<li>‘hello’ 패키지에 ‘HelloJava’ Class 생성 (Command+N Mac)     </li>
</ul>
</li>
</ul>
<p><em>주의 :</em><br>패키지 이름은 소문자(hello)로 한다.<br>Class 이름은 대문자(HelloJava)로 <em>시작</em>한다.  </p>
<p>main 함수는 class를 시작하는? 함수이다.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package hello;</span><br><span class="line"></span><br><span class="line">public class HelloJava &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;Hello, Java&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>컴파일을 위해서 소스코드를 빌드한다.<br>Build &gt; Build Project (Command+F9 [Mac])    </p>
</li>
<li><p>프로젝트 디렉토리에 있는 class 파일을 확인한다.     </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ls out&#x2F;production&#x2F;First&#x2F;hello&#x2F;</span><br><span class="line">HelloJava.class</span><br></pre></td></tr></table></figure>
</li>
<li><p>Run<br>Run &gt; Run (Control+Option+R [Mac])    </p>
</li>
</ul>
<p>화면 확인<br>Hello, Java     </p>
]]></content>
      <categories>
        <category>Study</category>
        <category>Java Basic</category>
      </categories>
  </entry>
  <entry>
    <title>04. 변수와 자료형</title>
    <url>/2020/08/12/hexo_1_Java_basic_04/</url>
    <content><![CDATA[<h1 id="Java-기초"><a href="#Java-기초" class="headerlink" title="Java 기초"></a>Java 기초</h1><h4 id="04-변수와-자료형"><a href="#04-변수와-자료형" class="headerlink" title="04. 변수와 자료형"></a>04. 변수와 자료형</h4><p>0000 1010 (2진수 8 bit) = 10 (10진수)<br>2진수 4 bit(ex: 0101 = 5)는 최대 15까지 표현 가능하다.</p>
<ul>
<li>컴퓨터에서 음수 표현 (2의 보수)</li>
</ul>
<p>0000 1010에서 맨앞의 0은 부호비트(MSB)이다. (0:양수 1:음수)   </p>
<p>보수 : 더했을 때 MSB가 새로 밀리고 다른 값이 0이되도록 하는 수   </p>
<p>2의 보수 구하는 법 :<br>0000 1010 (10) 의 1의 보수 (모든 bit 바꿈)   </p>
<p>-&gt; 1111 0101 에 0000 0001을 더한다<br>+ 0000 0001<br>= 1111 0110</p>
<p>검증 (2의 보수와 더 했을때 0이되어야 한다.)<br>0000 1010<br>+ 1111 0110<br>= 1 0000 0000 (밀려 MSB를 제외한 모든 비트 = 0)   </p>
]]></content>
      <categories>
        <category>Study</category>
        <category>Java Basic</category>
      </categories>
  </entry>
  <entry>
    <title>05. 변수란 무엇인가</title>
    <url>/2020/08/12/hexo_1_Java_basic_05/</url>
    <content><![CDATA[<h1 id="Java-기초"><a href="#Java-기초" class="headerlink" title="Java 기초"></a>Java 기초</h1><h4 id="05-변수란-무엇인가"><a href="#05-변수란-무엇인가" class="headerlink" title="05. 변수란 무엇인가"></a>05. 변수란 무엇인가</h4><p>변수 : 변하는 수<br>상수 : 변하지 않는 수</p>
<p>변수는 <em>선언</em>이 필요하다.   </p>
<p>선언 방법 :<br>자료형 변수이름;<br>int age; </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package variable;</span><br><span class="line"></span><br><span class="line">public class VariableTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int age, count;</span><br><span class="line">        int age_2 &#x3D; 20;</span><br><span class="line">        age &#x3D; 30;</span><br><span class="line">        System.out.println(age);</span><br><span class="line">        System.out.println(age_2);</span><br><span class="line"></span><br><span class="line">        age &#x3D; 10;</span><br><span class="line">        System.out.println(age);</span><br><span class="line">        count &#x3D; 1;</span><br><span class="line">        System.out.println(count);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>‘=’표시는 같다는 의미가 아니고 대입의 의미이다. (l-value=r-value : r-value를 l-value에 대입)<br>그렇기 때문에 언제든지 변수는 바뀔 수 있다.   </p>
<p>선언은 여러 변수를 한번에 할 수 도 있고 선언과 동시에 초기화(대입)할 수도 있다.  </p>
<p>선언은 해당 변수형의 크기 만큼 메모리를 사용한다.<br>(ex int age; -&gt; 4byte 메모리 점유)   </p>
<p>변수이름은…</p>
<ol>
<li>숫자로 시작할 수 없다.</li>
<li>특수문자는 ‘_’와 ‘$’만 가능하다.</li>
<li>예약어는 쓸 수 없다. (ex : while, for, int, etc…)</li>
<li>쓰임에 맞게 명명해야 가독성이 좋다. (줄여서 약어로 쓰지 말자.)</li>
</ol>
<p>되도록 소문자로 시작하고 단어가 바뀔때 대문자 (camel notation)      </p>
]]></content>
      <categories>
        <category>Study</category>
        <category>Java Basic</category>
      </categories>
  </entry>
  <entry>
    <title>06. 정수 자료형</title>
    <url>/2020/08/12/hexo_1_Java_basic_06/</url>
    <content><![CDATA[<h1 id="Java-기초"><a href="#Java-기초" class="headerlink" title="Java 기초"></a>Java 기초</h1><h4 id="06-정수-자료형"><a href="#06-정수-자료형" class="headerlink" title="06. 정수 자료형"></a>06. 정수 자료형</h4><p>자료형 종류 : </p>
<ol>
<li>기본형 : 자바에서 기본 제공 (정수형, 문자형, 실수형, 논리형)</li>
<li>참조형 : 클래스 형식의 자료형</li>
</ol>
<p>정수형<br>byte &lt; short &lt; int(보통) &lt; long<br>문자형<br>char<br>실수형<br>float &lt; double(보통)<br>논리형<br>boolean     </p>
<ul>
<li>int<br>4byte(32bit)<br>MSB를 제외한 31bit를 사용하여 -2^31 ~ 2^31-1(2147483647)까지 표현 가능     </li>
</ul>
<p>package variable;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class IntegerTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        byte bs1 &#x3D; -128;</span><br><span class="line">        &#x2F;&#x2F;byte bs2 &#x3D; 128;</span><br><span class="line">        System.out.println(bs1);</span><br><span class="line">        &#x2F;&#x2F;System.out.println(bs2);</span><br><span class="line">        &#x2F;&#x2F;int iVal &#x3D; 12345678900;</span><br><span class="line">        &#x2F;&#x2F;long lVal &#x3D; 12345678900;</span><br><span class="line">        long lVal &#x3D; 12345678900L;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>해당 정수형의 한계를 초과하면 error 발생<br>-&gt; 더 큰 정수형 사용   </p>
<p>long type을 사용할 때 4byte 이상의 수를 대입할 경우 숫자를 그냥 쓰면 error 발생<br>-&gt; 리터럴은 기본적으로 4byte이므로 숫자 마지막에 ‘L’을 입력하여(long으로 취급) 8byte로 사용      </p>
]]></content>
      <categories>
        <category>Study</category>
        <category>Java Basic</category>
      </categories>
  </entry>
  <entry>
    <title>07. 문자 자료형</title>
    <url>/2020/08/12/hexo_1_Java_basic_07/</url>
    <content><![CDATA[<h1 id="Java-기초"><a href="#Java-기초" class="headerlink" title="Java 기초"></a>Java 기초</h1><h4 id="07-문자-자료형"><a href="#07-문자-자료형" class="headerlink" title="07. 문자 자료형"></a>07. 문자 자료형</h4><p>인코딩 : 문자 -&gt; 숫자값(코드)<br>‘A’ -&gt; 65<br>디코딩 : 코드 -&gt; 문자<br>65 -&gt; ‘A’   </p>
<p>문자세트 (code-set)</p>
<ol>
<li>아스키(ASCII) : 1byte 영문자, 숫자, 특수문자 표현</li>
<li>유니코드(Unicode) : 한글 등 복잡한 언어 표현<br>‘가’ -&gt; AC00 (2byte)</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package variable;</span><br><span class="line"></span><br><span class="line">public class CharacterTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        char ch &#x3D; &#39;A&#39;;</span><br><span class="line">        System.out.println(ch);</span><br><span class="line">        System.out.println((int)ch);</span><br><span class="line"></span><br><span class="line">        int iCh &#x3D; 66;</span><br><span class="line">        System.out.println((char)iCh);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;char ch2 &#x3D; -66;</span><br><span class="line"></span><br><span class="line">        char hangul &#x3D; &#39;\uAC00&#39;;</span><br><span class="line">        System.out.println(hangul);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;char hangul2 &#x3D; &#39;한글&#39;;</span><br><span class="line">        char hangul2 &#x3D; &#39;한&#39;;</span><br><span class="line">        System.out.println(hangul2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(int)로 코드 확인 가능<br>(char)로 코드를 문자로 확인 가능<br>char type은 음수 불가능<br>문자형 자료에 ‘\u’를 추가하여 Unicode 의 코드 사용<br>char는 2byte인데 ‘한글’은 4byte이므로 불가능</p>
]]></content>
      <categories>
        <category>Study</category>
        <category>Java Basic</category>
      </categories>
  </entry>
  <entry>
    <title>08. 실수와 논리 자료형</title>
    <url>/2020/08/12/hexo_1_Java_basic_08/</url>
    <content><![CDATA[<h1 id="Java-기초"><a href="#Java-기초" class="headerlink" title="Java 기초"></a>Java 기초</h1><h4 id="08-실수와-논리-자료형"><a href="#08-실수와-논리-자료형" class="headerlink" title="08. 실수와 논리 자료형"></a>08. 실수와 논리 자료형</h4><ul>
<li>실수    </li>
</ul>
<p>double이 기본 float 사용시 f,F 식별자 사용<br>정수와 표현 방법이 다르다. (부동 소수점 방식)<br>지수부 + 가수부<br>0을 포현할 수 없으며 약간의 오차가 발생할 수 있다. (부동 소수점 방식의 오류)</p>
<p>1.0 x 10^-1<br>가수   밑수 지수      </p>
<p>float<br>MSB+지수부(8bit)+가수부(23bit)<br>double<br>MSB+지수부(11bit)+가수부(52bit)    </p>
<ul>
<li>논리 자료형    </li>
</ul>
<p>boolean<br>true,false 표현   </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package variable;</span><br><span class="line"></span><br><span class="line">public class DoubleTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        double dNum &#x3D; 3.14;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;float fNum &#x3D; 3.14;</span><br><span class="line">        float fNum &#x3D; 3.14F;</span><br><span class="line"></span><br><span class="line">        System.out.println(dNum);</span><br><span class="line">        System.out.println(fNum);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.14는 8byte (double)이므로 float에 그냥 대입하면 error 발생.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package variable;</span><br><span class="line"></span><br><span class="line">public class DoubleTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        double dNum &#x3D; 1;</span><br><span class="line">        for( int i &#x3D; 0; i &lt; 10000; i++) &#123;</span><br><span class="line">            dNum &#x3D; dNum + 0.1;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(dNum);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>결과는 1001.000000000159으로 약간의 오차가 발생한다.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package variable;</span><br><span class="line"></span><br><span class="line">public class BooleanTest &#123;</span><br><span class="line">    public static void main(String[] args)  &#123;</span><br><span class="line"></span><br><span class="line">        boolean isMarried &#x3D; false;</span><br><span class="line">        System.out.println(isMarried);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>false 또는 true 두가지 값 만 가능.</p>
<ul>
<li>자료형 없이 변수 사용하기 (var)</li>
</ul>
<p>Local variable type inference (java 10 이상)<br>지역변수에 한하여 컴파일러가 대입되는 값을 보고 변수형을 추론.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package variable;</span><br><span class="line"></span><br><span class="line">public class BooleanTest &#123;</span><br><span class="line">    public static void main(String[] args)  &#123;</span><br><span class="line">        var iVar &#x3D; 10;</span><br><span class="line">        var cVar &#x3D; &quot;Char&quot;;</span><br><span class="line"></span><br><span class="line">        System.out.println(iVar);</span><br><span class="line">        System.out.println(cVar);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Study</category>
        <category>Java Basic</category>
      </categories>
  </entry>
  <entry>
    <title>09. 상수와 리터럴, 형변환</title>
    <url>/2020/08/12/hexo_1_Java_basic_09/</url>
    <content><![CDATA[<h1 id="Java-기초"><a href="#Java-기초" class="headerlink" title="Java 기초"></a>Java 기초</h1><h4 id="09-상수와-리터럴-형변환"><a href="#09-상수와-리터럴-형변환" class="headerlink" title="09. 상수와 리터럴, 형변환"></a>09. 상수와 리터럴, 형변환</h4><p>상수 : 변하지 않는 수 (final 키워드)   </p>
<p>리터럴 : 프로그램에서 사용하는 모든 숫자, 값, 논리 값<br>모든 리터럴은 상수 풀(constant pool)에 저장되어 있다.<br>저장될 때 정수는 int, 실수는 double로 저장 된다.   </p>
<p>형 변환    </p>
<ol>
<li><p>묵시적 형 변환<br>작은 수 -&gt; 큰 수,<br>덜 정밀한 수 -&gt; 더 정밀한 수<br>로 대입되는 경우</p>
</li>
<li><p>명시적 형 변환<br>자료 형을 명시하여 변환, 자료 손실 발생 가능.</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package variable;</span><br><span class="line"></span><br><span class="line">public class ImplicitConversion &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        byte bNum &#x3D; 10;</span><br><span class="line">        int iNum &#x3D; bNum; &#x2F;&#x2F;더 큰수로 묵시적 형 변환</span><br><span class="line"></span><br><span class="line">        System.out.println(bNum);</span><br><span class="line">        System.out.println(iNum);</span><br><span class="line"></span><br><span class="line">        int iNum2 &#x3D; 20;</span><br><span class="line">        float fNum &#x3D; iNum2; &#x2F;&#x2F;더 정밀한 수로 형 변환</span><br><span class="line"></span><br><span class="line">        System.out.println(fNum);</span><br><span class="line"></span><br><span class="line">        double dNum;</span><br><span class="line">        dNum &#x3D; fNum + iNum; &#x2F;&#x2F;더 정밀한 수로 형 변환 2회 i-&gt;f-&gt;d</span><br><span class="line">        System.out.println(dNum);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package variable;</span><br><span class="line"></span><br><span class="line">public class ExplicitConversion &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        int i &#x3D; 1000;</span><br><span class="line">        &#x2F;&#x2F;byte bNum &#x3D; i;</span><br><span class="line">        byte bNum &#x3D; (byte)i; &#x2F;&#x2F;명시적 형 변환</span><br><span class="line">        System.out.println(bNum); &#x2F;&#x2F;데이터 유실</span><br><span class="line"></span><br><span class="line">        double dNum &#x3D; 1.2;</span><br><span class="line">        float fNum &#x3D; 0.9F;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;int iNum1 &#x3D; dNum + fNum;</span><br><span class="line">        int iNum1 &#x3D; (int)(dNum + fNum);</span><br><span class="line">        int iNum2 &#x3D; (int)dNum + (int)fNum;</span><br><span class="line">        System.out.println(iNum1); &#x2F;&#x2F;데이터 유실 2.1 -&gt; 2</span><br><span class="line">        System.out.println(iNum2); &#x2F;&#x2F;데이터 유실 1.2+0.9 -&gt; 1+0</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>10진수를 2,8,16진수로 쓰는 법</p>
<ul>
<li>2진수(0B) : 0B1010;</li>
<li>8진수(0) : 012;</li>
<li>16진수(0X) : 0XA;</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package variable;</span><br><span class="line"></span><br><span class="line">public class BinaryTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        int num &#x3D; 10;</span><br><span class="line">        int bNum &#x3D; 0B1010;</span><br><span class="line">        int oNum &#x3D; 012;</span><br><span class="line">        int xNum &#x3D; 0XA;</span><br><span class="line"></span><br><span class="line">        System.out.println(num);</span><br><span class="line">        System.out.println(bNum);</span><br><span class="line">        System.out.println(oNum);</span><br><span class="line">        System.out.println(xNum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Study</category>
        <category>Java Basic</category>
      </categories>
  </entry>
  <entry>
    <title>10. 대입, 부호, 산술, 복합대입, 증감 연산자</title>
    <url>/2020/08/12/hexo_1_Java_basic_10/</url>
    <content><![CDATA[<h1 id="Java-기초"><a href="#Java-기초" class="headerlink" title="Java 기초"></a>Java 기초</h1><h4 id="10-대입-부호-산술-복합대입-증감-연산자"><a href="#10-대입-부호-산술-복합대입-증감-연산자" class="headerlink" title="10. 대입, 부호, 산술, 복합대입, 증감 연산자"></a>10. 대입, 부호, 산술, 복합대입, 증감 연산자</h4><p>항 : 연산에 사용되는 값<br>연산자 : 항을 이용하여 연산하는 기호</p>
<ul>
<li><p>대입 연산자<br>int age = 20;<br>우선순위 가장 낮음.</p>
</li>
<li><p>단항 연산자<br>부호 유지 또는 변경 (+,-)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package operator;</span><br><span class="line"></span><br><span class="line">public class OperatorEx1 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        int num1 &#x3D; -10;</span><br><span class="line">        int num2 &#x3D; 20;</span><br><span class="line"></span><br><span class="line">        System.out.println(+num1);</span><br><span class="line">        System.out.println(+num2);</span><br><span class="line">        System.out.println(-num1);</span><br><span class="line">        System.out.println(-num2);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>+ 부호 유지<br>- 부호 변경<br>실제 변수 값의 부호를 바꾸려면 대입 연산자와 같이 사용.    </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int num1 &#x3D; -10;     </span><br><span class="line">num1 &#x3D; -num1;</span><br></pre></td></tr></table></figure></li>
<li><p>산술 연산자<br>사칙연산, %(나머지)    </p>
</li>
<li><p>복합 대입 연산자<br>대입 연산자 앞의 연산자의 결과를 l-value에 대입</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package operator;</span><br><span class="line"></span><br><span class="line">public class OperatorEx2 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        int num1&#x3D;10,num2&#x3D;10,num3&#x3D;10,num4&#x3D;10,num5 &#x3D; 10;</span><br><span class="line">        num1 +&#x3D; 2; &#x2F;&#x2F;r-value를 더한 뒤 대입</span><br><span class="line">        System.out.println(num1);</span><br><span class="line">        num2 -&#x3D; 2; &#x2F;&#x2F;r-value를 뺀 뒤 대입</span><br><span class="line">        System.out.println(num2);</span><br><span class="line">        num3 *&#x3D; 2; &#x2F;&#x2F;r-value를 곱한 뒤 대입</span><br><span class="line">        System.out.println(num3);</span><br><span class="line">        num4 &#x2F;&#x3D; 2; &#x2F;&#x2F;r-value로 나눈 몫을 대입</span><br><span class="line">        System.out.println(num4);</span><br><span class="line">        num5 %&#x3D; 2; &#x2F;&#x2F;r-value를 나눈 나머지 대입</span><br><span class="line">        System.out.println(num5);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>증가 감소 연산자<br>변수의 값을 1 더하거나 뺄때 사용     </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">val &#x3D; ++num; num 1 증가 후 대입</span><br><span class="line">val &#x3D; num++; 대입 후 num 1 증가</span><br><span class="line">val &#x3D; --num;</span><br><span class="line">val &#x3D; num--;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package operator;</span><br><span class="line"></span><br><span class="line">public class OperatorEx3 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        int score &#x3D; 100;</span><br><span class="line"></span><br><span class="line">        System.out.println(++score); &#x2F;&#x2F;101</span><br><span class="line">        &#x2F;&#x2F;++score 는 score &#x3D; score+1 과 같은 의미이다.</span><br><span class="line">        System.out.println(score++); &#x2F;&#x2F;101</span><br><span class="line">        System.out.println(score); &#x2F;&#x2F;102</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>증감 연산자는 대입을 내포한다.   </p>
]]></content>
      <categories>
        <category>Study</category>
        <category>Java Basic</category>
      </categories>
  </entry>
  <entry>
    <title>11. 관계, 논리, 조건 비트 연산자</title>
    <url>/2020/08/12/hexo_1_Java_basic_11/</url>
    <content><![CDATA[<h1 id="Java-기초"><a href="#Java-기초" class="headerlink" title="Java 기초"></a>Java 기초</h1><h4 id="11-관계-논리-조건-비트-연산자"><a href="#11-관계-논리-조건-비트-연산자" class="headerlink" title="11. 관계, 논리, 조건 비트 연산자"></a>11. 관계, 논리, 조건 비트 연산자</h4><ul>
<li><p>관계자 연산자<br>= 비교연산자<br>결과가 true/false로 반환 됨.<br>‘&gt;’, ‘&lt;’, ‘&gt;=’, ‘&lt;=’, ‘==’, ‘!=’</p>
</li>
<li><p>논리 연산자<br>결과가 true/false로 반환 됨.<br>&amp;&amp; 논리 곱, 두 항 모두 참이어야 true<br>|| 논리 합, 두 항 중 하나만 참이면 true<br>! 부정, 항의 논리 결과 변경 (true -&gt; false, false -&gt; true)    </p>
</li>
</ul>
<p>단락 회로 평가<br>앞 항 결과만으로 논리 연산자 결과가 나온다면 뒷 항은 평가되지 않음.<br>-&gt; 프로그램에서 예상하지 못한 결과가 발생할 수 있으므로 유의</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package operator;</span><br><span class="line"></span><br><span class="line">public class OperatorEx3 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        int num1 &#x3D; 10;</span><br><span class="line">        int i &#x3D; 2;</span><br><span class="line"></span><br><span class="line">        boolean value &#x3D; ((num1+&#x3D;10)&lt;10)&amp;&amp;((i+&#x3D;2)&lt;10);</span><br><span class="line">        System.out.println(value); &#x2F;&#x2F;false</span><br><span class="line">        System.out.println(num1);  &#x2F;&#x2F;20</span><br><span class="line">        System.out.println(i);     &#x2F;&#x2F;2</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>논리 곱에서 왼쪽 항은 연산이 되었으나 오른쪽 항은 연산되지 않았음을 확인할 수 있다.    </p>
<ul>
<li><p>조건 연산자<br>조건식? 결과1: 결과2;  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int num &#x3D; (5&gt;3)&gt; 10: 20;</span><br></pre></td></tr></table></figure>
</li>
<li><p>비트 연산자<br>~ : 비트 반전 (1의 보수)<br>&amp; : 비트 단위 AND, 1&amp;1 만 1<br>| : 비트 단위 OR, 0|0 만 0<br>^ : 비트 단위 XOR   두 비트가 서로 다른 경우 1<br>&lt;&lt; : 왼쪽 shift   a &lt;&lt; 2 a를 2bit 만큼 왼쪽으로 이동, 0으로 채움<br>&gt;&gt; : 오른쪽 shift, 부호비트로 채움<br>&gt;&gt;&gt; : 오른쪽 shift, 0으로 채움<br>왼쪽 : 곱하기, 오른쪽 : 나누기     </p>
</li>
</ul>
<p>어디에 사용하나<br>마스크 : 몇개의 비트 값만 사용할 떄<br>비트켜기 : &amp;00001111 하위 4bit중 1인 비트만 꺼내기<br>비트끄기 : |11110000 하위 4bit중 0인 비트만 0으로 만들기<br>비트토글 : 모든 비트들을 0은 1로, 1은 0으로 바꾸고 싶을 때<br>shift를 통해 곱하기를 빠르게      </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package operator;</span><br><span class="line"></span><br><span class="line">public class OperatorEx4 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        int num1 &#x3D; 0B00001010; &#x2F;&#x2F;10</span><br><span class="line">        int num2 &#x3D; 0B00000101; &#x2F;&#x2F;5</span><br><span class="line"></span><br><span class="line">        System.out.println(num1 &amp; num2); &#x2F;&#x2F;00000000 0</span><br><span class="line">        System.out.println(num1 | num2); &#x2F;&#x2F;00001111 15</span><br><span class="line">        System.out.println(num1 ^ num2); &#x2F;&#x2F;00001111 15</span><br><span class="line">        System.out.println(num2 &lt;&lt; 1); &#x2F;&#x2F;(x2) 00001010 10</span><br><span class="line">        System.out.println(num2 &lt;&lt; 2); &#x2F;&#x2F;(x2^2) 00010100 20</span><br><span class="line">        System.out.println(num2 &lt;&lt; 3); &#x2F;&#x2F;(x2^3) 00010100 40</span><br><span class="line">        System.out.println(num2 &gt;&gt; 2); &#x2F;&#x2F;(&#x2F;2^2) 00000001 1</span><br><span class="line">        System.out.println(num2 &lt;&lt;&#x3D; 3); &#x2F;&#x2F;복합 대입 연산자 40</span><br><span class="line">        System.out.println(num2); &#x2F;&#x2F;40</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Study</category>
        <category>Java Basic</category>
      </categories>
  </entry>
  <entry>
    <title>13. 제어문 if</title>
    <url>/2020/08/12/hexo_1_Java_basic_13/</url>
    <content><![CDATA[<h1 id="Java-기초"><a href="#Java-기초" class="headerlink" title="Java 기초"></a>Java 기초</h1><h4 id="13-제어문-if"><a href="#13-제어문-if" class="headerlink" title="13. 제어문 if"></a>13. 제어문 if</h4><p>if (조건식) {<br>    수행문;<br>}<br>조건식이 참인 경우 수행. 거짓인 경우 조건문 종료.   </p>
<p>if (조건식) {<br>    수행문1;<br>} else {<br>    수행문2;<br>}   </p>
<p>조건식이 참인 경우 수행. 거짓인 경우 else.     </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package ifexample;</span><br><span class="line"></span><br><span class="line">public class IfExample1 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        char gender &#x3D; &#39;M&#39;;</span><br><span class="line"></span><br><span class="line">        if ( gender &#x3D;&#x3D; &#39;F&#39; ) &#123; &#x2F;&#x2F; 블럭의 시작</span><br><span class="line">            System.out.println(&quot;여성입니다.&quot;); &#x2F;&#x2F; 블럭 내부에서는 들여쓰기</span><br><span class="line">        &#125; &#x2F;&#x2F; 블럭 끝</span><br><span class="line">        else &#123;</span><br><span class="line">            System.out.println(&quot;남성입니다.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>조건이 여러개일 때는..   </p>
<p>if (조건식) {<br>    수행문1;<br>} else if (조건식) {<br>    수행문2;<br>} else if (조건식) {<br>    수행문3;<br>} else {<br>    수행문4;<br>}  </p>
<p>나이별 요금 계산</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package ifexample;</span><br><span class="line"></span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class IfExample2 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        Scanner scanner &#x3D; new Scanner(System.in);</span><br><span class="line">        int age &#x3D; scanner.nextInt();</span><br><span class="line">        int charge &#x3D; 0;</span><br><span class="line"></span><br><span class="line">        if ( age &lt; 8 ) &#123;</span><br><span class="line">            charge &#x3D; 1000;</span><br><span class="line">        &#125;</span><br><span class="line">        else if ( age &lt; 14 ) &#123;</span><br><span class="line">            charge &#x3D; 1500;</span><br><span class="line">        &#125;</span><br><span class="line">        else if ( age &lt; 20 ) &#123;</span><br><span class="line">            charge &#x3D; 2000;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            charge &#x3D; 3000;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;나이 : &quot; + age);</span><br><span class="line">        System.out.println(&quot;요금 : &quot; + charge);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>점수별 학점 계산</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package ifexample;</span><br><span class="line"></span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class IfExample3 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        Scanner scanner &#x3D; new Scanner(System.in);</span><br><span class="line">        int score &#x3D; scanner.nextInt();</span><br><span class="line">        char grade;</span><br><span class="line"></span><br><span class="line">        if ( score&gt;&#x3D;90 ) &#123;</span><br><span class="line">            grade &#x3D; &#39;A&#39;;</span><br><span class="line">        &#125;</span><br><span class="line">        else if ( score&gt;&#x3D;80 ) &#123;</span><br><span class="line">            grade &#x3D; &#39;B&#39;;</span><br><span class="line">        &#125;</span><br><span class="line">        else if ( score&gt;&#x3D;70 ) &#123;</span><br><span class="line">            grade &#x3D; &#39;C&#39;;</span><br><span class="line">        &#125;</span><br><span class="line">        else if ( score&gt;&#x3D;60 ) &#123;</span><br><span class="line">            grade &#x3D; &#39;D&#39;;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            grade &#x3D; &#39;F&#39;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;점수 : &quot; + score);</span><br><span class="line">        System.out.println(&quot;학점 : &quot; + grade);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>조건문과 조건 연산자</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package ifexample;</span><br><span class="line"></span><br><span class="line">public class IfExample3 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        int a &#x3D; 10;</span><br><span class="line">        int b &#x3D;20;</span><br><span class="line">        int max;</span><br><span class="line"></span><br><span class="line">        max &#x3D; (a&gt;b)? a:b;</span><br><span class="line"></span><br><span class="line">        System.out.println(max);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 위와 아래는 동일한 결과.</span><br><span class="line"></span><br><span class="line">        if (a&gt;b) &#123;</span><br><span class="line">            max &#x3D; a;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            max &#x3D; b;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(max);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Study</category>
        <category>Java Basic</category>
      </categories>
  </entry>
  <entry>
    <title>15. 제어문 switch ~ case</title>
    <url>/2020/08/12/hexo_1_Java_basic_15/</url>
    <content><![CDATA[<h1 id="Java-기초"><a href="#Java-기초" class="headerlink" title="Java 기초"></a>Java 기초</h1><h4 id="15-제어문-switch-case"><a href="#15-제어문-switch-case" class="headerlink" title="15. 제어문 switch ~ case"></a>15. 제어문 switch ~ case</h4><p>if ~ else if 문의 조건이 정수 또는 문자열일 경우 switch ~ case 로 사용할 수 있다.     </p>
<p>switch(변수){<br>    case 조건1: 수행문1;<br>    case 조건2: 수행문2:<br>    …<br>    default : 수행문n;<br>}       </p>
<p>package ifexample;</p>
<p>import java.util.Scanner;</p>
<p>public class SwitchCaseEx {<br>    public static void main(String[] args) {</p>
<pre><code>    Scanner scanner = new Scanner(System.in);

    int rank = scanner.nextInt();
    char medalColor;

    switch(rank) {
        case 1: medalColor=&apos;G&apos;;
                break; //break가 없으면 다음 case 문이 조건과 상관 없이 수행된다.
        case 2: medalColor=&apos;S&apos;;
                break;
        case 3: medalColor=&apos;B&apos;;
                break;
        default : medalColor=&apos;A&apos;; //default는 break이 필요 없다.
    }
    System.out.println(rank + &quot;등의 메달 색은 &quot; + medalColor + &quot;입니다.&quot;);
}</code></pre><p>}</p>
<p>자바 7부터 조건으로 문자열을 사용할 수 있다.  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package ifexample;</span><br><span class="line"></span><br><span class="line">public class SwitchCaseEx &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        String medalColorT&#x3D;&quot;Gold&quot;;</span><br><span class="line">        int rank;</span><br><span class="line"></span><br><span class="line">        switch(medalColorT) &#123;</span><br><span class="line">            case &quot;Gold&quot;:</span><br><span class="line">                rank &#x3D; 1;</span><br><span class="line">                break; &#x2F;&#x2F;break가 없으면 다음 case 문이 조건과 상관 없이 수행된다.</span><br><span class="line">            case &quot;Silver&quot;:</span><br><span class="line">                rank &#x3D; 2;</span><br><span class="line">                break;</span><br><span class="line">            case &quot;Bronze&quot;:</span><br><span class="line">                rank &#x3D; 3;</span><br><span class="line">                break;</span><br><span class="line">            default :</span><br><span class="line">                rank &#x3D; 0;</span><br><span class="line">                System.out.println(&quot;Error&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(medalColorT + &quot;메달은 &quot; + rank + &quot;등 입니다.&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>서로 다른 조건에 대한 수행문이 같은 경우 case를 병합할 수 있다.     </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package ifexample;</span><br><span class="line"></span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class SwitchCaseEx1 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        Scanner scanner &#x3D; new Scanner(System.in);</span><br><span class="line"></span><br><span class="line">        int month &#x3D; scanner.nextInt();</span><br><span class="line">        int day;</span><br><span class="line"></span><br><span class="line">        switch(month) &#123;</span><br><span class="line">            case 1: case 5: case 7: case 8: case 10: case 12:</span><br><span class="line">                    day&#x3D;31;</span><br><span class="line">                    break;</span><br><span class="line">            case 2: day&#x3D;28;</span><br><span class="line">                    break;</span><br><span class="line">            case 3: case 4: case 6: case 9: case 11:</span><br><span class="line">                    day&#x3D;30;</span><br><span class="line">                    break;</span><br><span class="line">            default :</span><br><span class="line">                    System.out.println(&quot;Error&quot;);</span><br><span class="line">                    day &#x3D; 0;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(month + &quot;월의 날짜 수는 &quot; + day + &quot;일 입니다.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Study</category>
        <category>Java Basic</category>
      </categories>
  </entry>
  <entry>
    <title>16. 제어문 while, do-while</title>
    <url>/2020/08/12/hexo_1_Java_basic_16/</url>
    <content><![CDATA[<h1 id="Java-기초"><a href="#Java-기초" class="headerlink" title="Java 기초"></a>Java 기초</h1><h4 id="16-제어문-while-do-while"><a href="#16-제어문-while-do-while" class="headerlink" title="16. 제어문 while, do-while"></a>16. 제어문 while, do-while</h4><p>동일한 수행문을 조건이 맞는 동안 반복 수행.   </p>
<p>while(조건식) {<br>    수행문1;<br>    …<br>}<br>    수행문2;<br>    …     </p>
<p>while 내 조건문이 참인 경우 수행문1을 반복 수행한다.   </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package loopexample;</span><br><span class="line"></span><br><span class="line">public class WhileExample &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        int num &#x3D; 1;</span><br><span class="line">        int sum &#x3D; 0;</span><br><span class="line"></span><br><span class="line">        while ( num &lt;&#x3D; 10 ) &#123;</span><br><span class="line">            sum +&#x3D; num;</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(sum);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>do {<br>    수행문1;<br>    …<br>} while(조건식);<br>    수행문2;<br>    …</p>
<p>반복문 중 가장 안씀.<br>먼저 수행문1을 수행한 뒤 조건 체크.<br>최소 한번은 수행문이 수행되어야 하는 경우에 사용.    </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package loopexample;</span><br><span class="line"></span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class DoWhileExample1 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        Scanner scanner &#x3D; new Scanner(System.in);</span><br><span class="line"></span><br><span class="line">        int num;</span><br><span class="line">        int sum&#x3D;0;</span><br><span class="line"></span><br><span class="line">        do &#123;</span><br><span class="line">            num &#x3D; scanner.nextInt();</span><br><span class="line">            sum +&#x3D; num;</span><br><span class="line">            System.out.println(sum);</span><br><span class="line">        &#125; while ( num !&#x3D; 0 );</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Study</category>
        <category>Java Basic</category>
      </categories>
  </entry>
  <entry>
    <title>18. 제어문 for문, 중첩반복문</title>
    <url>/2020/08/12/hexo_1_Java_basic_18/</url>
    <content><![CDATA[<h1 id="Java-기초"><a href="#Java-기초" class="headerlink" title="Java 기초"></a>Java 기초</h1><h4 id="18-제어문-for문-중첩반복문"><a href="#18-제어문-for문-중첩반복문" class="headerlink" title="18. 제어문 for문, 중첩반복문"></a>18. 제어문 for문, 중첩반복문</h4><ul>
<li>for문<br>반복문 중 가장 많이 사용됨.<br>일정횟수 반복 구현에 효율적.    </li>
</ul>
<p>for (초기화식; 조건식; 증감식;)<br>{<br>    수행문;<br>    …<br>}   </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package loopexample;</span><br><span class="line"></span><br><span class="line">public class ForExample &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        int num&#x3D;0;</span><br><span class="line">        int total &#x3D; 0;</span><br><span class="line"></span><br><span class="line">        while ( num &lt; 10) &#123;</span><br><span class="line">            total +&#x3D; num;</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(total);</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;위와 아래는 같은 로직이다.        </span><br><span class="line"></span><br><span class="line">        int count;</span><br><span class="line">        int sum&#x3D;0;</span><br><span class="line"></span><br><span class="line">        for(count&#x3D;0; count&lt;10; count++) &#123; &#x2F;&#x2F;횟수의 의미가 있는경우 0부터 시작하는 것에 익숙해지자.</span><br><span class="line">            sum +&#x3D; count;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sum);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>같은 로직이지만 for문이 더 편하고 가독성이 좋다.   </p>
<p>while, do-while은 조건식의 결과 또는 변수가 true,false인 경우 주로 사용.<br>for문은 특정 수의 범위, 횟수와 관련하여 반복되는 경우 사용. 배열과 같이 사용.     </p>
<ul>
<li><p>무한루프<br>while (true) {<br>…<br>}<br>or<br>for(;;) {<br>…<br>}   </p>
</li>
<li><p>중첩 반복문<br>반복문 내부에 또 다른 반복문 사용.<br>외부반복문 / 내부반복문 간의 변 값 변화에 유의.    </p>
</li>
</ul>
<p>중첩반복문을 이용한 구구단</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package loopexample;</span><br><span class="line"></span><br><span class="line">public class ForExample1 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        int num;</span><br><span class="line">        int count;</span><br><span class="line">        int result;</span><br><span class="line"></span><br><span class="line">        for(num&#x3D;2; num&lt;10; num++) &#123;</span><br><span class="line">            for (count &#x3D; 1; count &lt; 10; count++) &#123;</span><br><span class="line">                result &#x3D; num*count;</span><br><span class="line">                System.out.println(num+&quot;x&quot;+count+&quot;&#x3D;&quot;+result);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Study</category>
        <category>Java Basic</category>
      </categories>
  </entry>
  <entry>
    <title>20. break, continue 문</title>
    <url>/2020/08/12/hexo_1_Java_basic_20/</url>
    <content><![CDATA[<h1 id="Java-기초"><a href="#Java-기초" class="headerlink" title="Java 기초"></a>Java 기초</h1><h4 id="20-break-continue-문"><a href="#20-break-continue-문" class="headerlink" title="20. break, continue 문"></a>20. break, continue 문</h4><ul>
<li>break<br>감싸고 있는 블럭을 빠져나오는 기능.<br>주로 반복문, 조건문, switch-case문과 같이 사용됨.<br>반복문에서 특정 조건에서 반복 중지.    </li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package loopexample;</span><br><span class="line"></span><br><span class="line">public class BreakExample &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        int num;</span><br><span class="line">        int sum&#x3D;0;</span><br><span class="line"></span><br><span class="line">        for (num&#x3D;1; ; num++) &#123;</span><br><span class="line">            sum +&#x3D; num;</span><br><span class="line">            if (sum&gt;&#x3D;100) &#123;</span><br><span class="line">                break; &#x2F;&#x2F;sum이 100을 넘어가는 경우 반복 중지</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(sum);</span><br><span class="line">        System.out.println(num);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>continue<br>반복문에서 특정 조건에서 블럭 내부의 다른 수행문을 수행하지 않음.   </li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package loopexample;</span><br><span class="line"></span><br><span class="line">public class ContinueExample &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        int num;</span><br><span class="line"></span><br><span class="line">        for (num&#x3D;1; num&lt;&#x3D;100; num++) &#123;</span><br><span class="line">            if (num%3!&#x3D;0) &#123; &#x2F;&#x2F;3의 배수가 아닌 경우 출력 X</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(num);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>구구단 짝수단만 출력하면서 곱하는수가 단과 같거나 작은 경우만 출력</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package loopexample;</span><br><span class="line"></span><br><span class="line">public class BreakContinueTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        int dan;</span><br><span class="line">        int num;</span><br><span class="line">        int result;</span><br><span class="line"></span><br><span class="line">        for (dan&#x3D;2; dan&lt;10; dan++) &#123;</span><br><span class="line">            if (dan%2&#x3D;&#x3D;1) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            for (num&#x3D;1; num&lt;10; num++) &#123;</span><br><span class="line">                if (num&gt;dan) &#123;</span><br><span class="line">                    break; &#x2F;&#x2F;내부 반복문만 중지된다.</span><br><span class="line">                &#125;</span><br><span class="line">                result&#x3D;dan*num;</span><br><span class="line">                System.out.println(dan+&quot;X&quot;+num+&quot;&#x3D;&quot;+result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Study</category>
        <category>Java Basic</category>
      </categories>
  </entry>
  <entry>
    <title>01. 객체 지향 프로그래밍과 클래스</title>
    <url>/2020/08/12/hexo_OOP_01/</url>
    <content><![CDATA[<h1 id="객체-지향-프로그래밍"><a href="#객체-지향-프로그래밍" class="headerlink" title="객체 지향 프로그래밍"></a>객체 지향 프로그래밍</h1><h4 id="01-객체-지향-프로그래밍과-클래스"><a href="#01-객체-지향-프로그래밍과-클래스" class="headerlink" title="01. 객체 지향 프로그래밍과 클래스"></a>01. 객체 지향 프로그래밍과 클래스</h4><ul>
<li><p>객체 (Object)<br>의사나 행위가 미치는 대상 (사전적)<br>구체적, 추상적 데이터의 단위<br>예) 사람, 자동차, 주문, 생산, 관리…   </p>
</li>
<li><p>객체 지향 프로그래밍<br>객체를 기반으로 하는 프로그래밍<br>객체를 정의하고, 객체의 기능을 구현하며, 객체간의 협력을 구현<br>&lt;&gt; 절차 지향 프로그래밍      </p>
</li>
<li><p>클래스<br>객체를 코드로 구현한 것<br>객체 지향 프로그래밍의 가장 기본적인 요소<br>객체의 청사진     </p>
</li>
<li><p>멤버 변수<br>객체가 가지는 속성을 변수로 표현<br>클래스의 멤버 변수</p>
</li>
<li><p>메서드<br>객체의 기능을 구현  </p>
</li>
</ul>
<p>class 생성하기.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package classpart;</span><br><span class="line"></span><br><span class="line">public class Student &#123;  &#x2F;&#x2F;객체를 코드로 표현 -&gt; class</span><br><span class="line">    &#x2F;&#x2F;public class는 java file내에 하나만 존재하며 java file이름과 동일해야 한다.</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;객체의 속성을 변수로 표현 (멤버 변수, 속성)</span><br><span class="line">    public int studentId; &#x2F;&#x2F;public &#x3D; 접근제어자</span><br><span class="line">    public String studentName; &#x2F;&#x2F;문자열을 사용하기 위해 java에서 제공되는 class (java.lang package)</span><br><span class="line">    public String address;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;기능은 메서드로 구현</span><br><span class="line">    public void showStudentInfo() &#123; &#x2F;&#x2F;void:반환하는 값의 자료형을 나타냄(없음)</span><br><span class="line">                                    &#x2F;&#x2F;메서드 명 다음의 괄호 안에 매개변수가 있을수 도 있다.</span><br><span class="line">        System.out.println(studentName+&quot;,&quot;+address);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>다른 class에서 Student class 사용하기.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package classpart;</span><br><span class="line"></span><br><span class="line">public class StudentTest &#123; &#x2F;&#x2F;객체를 사용하는 건 다른 클래스인 경우가 대부분이다.</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Student studentLee &#x3D; new Student(); &#x2F;&#x2F;인스턴스 생성</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;참조 변수 사용 studentLee</span><br><span class="line">        studentLee.studentName &#x3D; &quot;이순신&quot;;  &#x2F;&#x2F;생성된 인스턴스(객체)의 멤버 변수를 사용할 수 있다.</span><br><span class="line">        studentLee.address &#x3D; &quot;서울&quot;;</span><br><span class="line"></span><br><span class="line">        studentLee.showStudentInfo(); &#x2F;&#x2F;생성된 인스턴스(객체)의 메서드를 사용할 수 있다.</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Study</category>
        <category>JAVA OOP</category>
      </categories>
  </entry>
  <entry>
    <title>03. 함수와 메서드</title>
    <url>/2020/08/12/hexo_OOP_03/</url>
    <content><![CDATA[<h1 id="객체-지향-프로그래밍"><a href="#객체-지향-프로그래밍" class="headerlink" title="객체 지향 프로그래밍"></a>객체 지향 프로그래밍</h1><h4 id="03-함수와-메서드"><a href="#03-함수와-메서드" class="headerlink" title="03. 함수와 메서드"></a>03. 함수와 메서드</h4><ul>
<li>함수(function)<br>하나의 기능을 수행하는 일련의 코드<br>함수는 호출하여 사용하 기능이 수행된 후 값을 반환할 수 있음<br>함수로 구현된 기능은 여러 곳에서 호출되어 사용될 수 있음 (코드의 재사용)<br>가독성, 유지보수에 좋다.</li>
</ul>
<p>함수는 이름, 매개변수, 반환 값, 몸체로 구성된다.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package classpart;</span><br><span class="line"></span><br><span class="line">public class FunctionTest &#123;</span><br><span class="line">    &#x2F;&#x2F;            반환type 이름(매개변수)</span><br><span class="line">    public static int addNum(int num1, int num2) &#123; &#x2F;&#x2F;2개의 매개변수 및 int 반환 값이 필요하다.</span><br><span class="line">        int result;</span><br><span class="line">        result &#x3D; num1+num2;</span><br><span class="line">        return result; &#x2F;&#x2F;반환 값 result</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void sayHello(String greeting) &#123; &#x2F;&#x2F;반환 값이 없는 함수 (void)</span><br><span class="line">        System.out.println(greeting);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static int calcSum() &#123; &#x2F;&#x2F;매개변수가 없고 반환 값만 있는 함수</span><br><span class="line"></span><br><span class="line">        int sum&#x3D;0;</span><br><span class="line">        int i;</span><br><span class="line"></span><br><span class="line">        for (i&#x3D;0;i&lt;&#x3D;100;i++) &#123;</span><br><span class="line">            sum +&#x3D; i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int n1 &#x3D; 10;</span><br><span class="line">        int n2 &#x3D; 20;</span><br><span class="line"></span><br><span class="line">        int total &#x3D; addNum(n1,n2); &#x2F;&#x2F;매개변수를 통해 함수의 반환 값을 int 변수로 받음.</span><br><span class="line">        sayHello(&quot;안녕&quot;); &#x2F;&#x2F;반환 값 없이 매개변수 출력</span><br><span class="line">        int num &#x3D; calcSum(); &#x2F;&#x2F;매개변수 없이 반환 값을 int 변수로 받음.</span><br><span class="line"></span><br><span class="line">        System.out.println(total);</span><br><span class="line">        System.out.println(num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>메서드<br>객체의 기능을 구현하기 위해 클래스 내에서 구현되는 함수<br>메서드를 구현함으로써 객체의 기능이 구현됨<br>메서드 이름은 사용하는 쪽에 맞게 명명<br>ex) getStudentName() (camel notation)<br>지역변수 : 함수 내에서 사용되는 변수   </p>
</li>
<li><p>메모리<br>stack : 함수 호출에 사용되는 memory, 함수의 호출이 끝나면 반환된다.<br>점유된 순서의 반대로 반환된다. (main부터 점유, main을 끝으로 반환.)</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Study</category>
        <category>JAVA OOP</category>
      </categories>
  </entry>
  <entry>
    <title>05. 인스턴스, 힙메모리</title>
    <url>/2020/08/12/hexo_OOP_05/</url>
    <content><![CDATA[<h1 id="객체-지향-프로그래밍"><a href="#객체-지향-프로그래밍" class="headerlink" title="객체 지향 프로그래밍"></a>객체 지향 프로그래밍</h1><h4 id="05-인스턴스-힙메모리"><a href="#05-인스턴스-힙메모리" class="headerlink" title="05. 인스턴스, 힙메모리"></a>05. 인스턴스, 힙메모리</h4><ul>
<li>인스턴스<br>클래스로부터 생성된 객체<br>힙 메모리에 멤버 변수의 크기에 따라 메모리가 생성<br>new 키워드를 이용하여 여러 개의 인스턴스를 생성<br>가비지 콜렉터 스레드에 의해 반환됨(프로그래머가 직접 free하지 않아도 된다.)<br>참조 변수 : 생성된 인스턴스를 가리키는 변수<br>참조 값 : 생성된 인스턴스의 메모리 주소 값</li>
</ul>
<p>멤버변수 사용 : 참조변수.멤버변수<br>메서드 사용 : 참조변수.메서드();    </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package classpart;</span><br><span class="line"></span><br><span class="line">public class StudentTest &#123; &#x2F;&#x2F;객체를 사용하는 건 다른 클래스인 경우가 대부분이다.</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Student studentLee &#x3D; new Student(); &#x2F;&#x2F;인스턴스 생성</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;참조 변수 사용 studentLee</span><br><span class="line">        studentLee.studentName &#x3D; &quot;이순신&quot;;  &#x2F;&#x2F;생성된 인스턴스(객체)의 멤버 변수를 사용할 수 있다.</span><br><span class="line">        studentLee.address &#x3D; &quot;서울&quot;;</span><br><span class="line"></span><br><span class="line">        studentLee.showStudentInfo(); &#x2F;&#x2F;생성된 인스턴스(객체)의 메서드를 사용할 수 있다.</span><br><span class="line"></span><br><span class="line">        Student studentKim &#x3D; new Student(); &#x2F;&#x2F;new 키워드를 통해 인스턴스 생성</span><br><span class="line">                                            &#x2F;&#x2F;생성 될 때 Student class의 멤버 변수 만큼 Heap 메모리 생성</span><br><span class="line">        studentKim.studentName&#x3D;&quot;김유신&quot;;</span><br><span class="line">        studentKim.address&#x3D;&quot;경주&quot;;</span><br><span class="line"></span><br><span class="line">        studentKim.showStudentInfo();</span><br><span class="line"></span><br><span class="line">        System.out.println(studentLee); &#x2F;&#x2F;참조 변수 출력&gt;참조 값 classpart.Student@60f82f98 package.class@heap memory address</span><br><span class="line">        System.out.println(studentKim);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Study</category>
        <category>JAVA OOP</category>
      </categories>
  </entry>
  <entry>
    <title>07. 생성자, 생성자 오버로딩</title>
    <url>/2020/08/12/hexo_OOP_07/</url>
    <content><![CDATA[<h1 id="객체-지향-프로그래밍"><a href="#객체-지향-프로그래밍" class="headerlink" title="객체 지향 프로그래밍"></a>객체 지향 프로그래밍</h1><h4 id="07-생성자-생성자-오버로딩"><a href="#07-생성자-생성자-오버로딩" class="headerlink" title="07. 생성자, 생성자 오버로딩"></a>07. 생성자, 생성자 오버로딩</h4><ul>
<li>생성자<br>객체를 생성할 때 new 키워드와 함께 호출 (객체 생성때만 호출)<br>인스턴스를 초기화 하는 코드가 구현 됨 (주로 멤버 변수 초기화)<br>반환 값이 없음, 상속되지 않음<br>생성자는 클래스 이름과 동일     </li>
</ul>
<p>기본 생성자 (디폴트 생성자)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public Student() &#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>클래스에 생성자를 구현하지 않은 경우 프리 컴파일 단계에서 컴파일러가 넣어줌.<br>매개 변수가 없고 구현부가 없다.<br>만약 클래스에 다른 생성자가 있는 경우 기본 생성자는 제공되지 않는다.     </p>
<p>생성자 구현</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public Student(int id, String name) &#123;</span><br><span class="line">    &#x2F;&#x2F;body &#x3D; 구현부</span><br><span class="line">    studentId &#x3D; id;</span><br><span class="line">    studentName &#x3D; name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>위의 생성자는 인스턴스 생성과 동시에 초기화</p>
<p>사용할 때는 아래와 같이 매개 변수 입력  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package classpart;</span><br><span class="line"></span><br><span class="line">public class StudentTest &#123; &#x2F;&#x2F;객체를 사용하는 건 다른 클래스인 경우가 대부분이다.</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Student studentLee &#x3D; new Student(&quot;이순신&quot;);</span><br><span class="line">        studentLee.address &#x3D; &quot;서울&quot;;</span><br><span class="line"></span><br><span class="line">        studentLee.showStudentInfo(); </span><br><span class="line"></span><br><span class="line">        Student studentKim &#x3D; new Student(101,&quot;김유신&quot;); </span><br><span class="line"></span><br><span class="line">        studentKim.showStudentInfo();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>오버로딩<br>이름이 같지만 다른 매개 변수를 가지는 생성자 또는 메서드를 사용할 수 있다.<br>사용자는 여러 생성자 중 선택하여 사용할 수 있음<br>private 변수도 생성자를 이용하여 초기화 할 수 있음    </li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public Student(String name) &#123;</span><br><span class="line">    studentName &#x3D; name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Student(int id, String name) &#123;</span><br><span class="line">    studentId &#x3D; id;</span><br><span class="line">    studentName &#x3D; name;</span><br><span class="line">    address &#x3D; &quot;주소 없음&quot;;</span><br></pre></td></tr></table></figure>

<ul>
<li>private<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private int name;</span><br></pre></td></tr></table></figure>
위의 멤버 변수는 클래스 외부에서 참조할 수 없다.<br>생성자를 구현하여 초기화 할 수는 있다.  </li>
</ul>
]]></content>
      <categories>
        <category>Study</category>
        <category>JAVA OOP</category>
      </categories>
  </entry>
  <entry>
    <title>08. 참조 자료형</title>
    <url>/2020/08/12/hexo_OOP_08/</url>
    <content><![CDATA[<h1 id="객체-지향-프로그래밍"><a href="#객체-지향-프로그래밍" class="headerlink" title="객체 지향 프로그래밍"></a>객체 지향 프로그래밍</h1><h4 id="08-참조-자료형"><a href="#08-참조-자료형" class="headerlink" title="08. 참조 자료형"></a>08. 참조 자료형</h4><ul>
<li>기본 자료형<br>int, long, float, double, …</li>
<li>참조 자료형<br>String, Date, Student, …  </li>
</ul>
<p>참조 자료형 직접 생성하기</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package reference;</span><br><span class="line"></span><br><span class="line">public class Subject &#123; &#x2F;&#x2F;과목 class 생성</span><br><span class="line"></span><br><span class="line">    String subjectName;</span><br><span class="line">    int score;</span><br><span class="line">    int subjectID;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package reference;</span><br><span class="line"></span><br><span class="line">public class Student &#123;</span><br><span class="line"></span><br><span class="line">    int studentID;</span><br><span class="line">    String studentName;</span><br><span class="line"></span><br><span class="line">    Subject korea; &#x2F;&#x2F;과목 type(참조 자료형)으로 변수 선언</span><br><span class="line">    Subject math;</span><br><span class="line"></span><br><span class="line">    public Student(int id, String name) &#123;</span><br><span class="line">        studentID &#x3D; id;</span><br><span class="line">        studentName &#x3D; name;</span><br><span class="line"></span><br><span class="line">        korea &#x3D; new Subject(); &#x2F;&#x2F;생성 단계가 필요하다</span><br><span class="line">        math &#x3D; new Subject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setKoreaSubject(String name,int score) &#123;</span><br><span class="line">        korea.subjectName &#x3D; name; &#x2F;&#x2F;과목 class의 속성 참조</span><br><span class="line">        korea.score &#x3D; score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setMathSubject(String name,int score) &#123;</span><br><span class="line">        math.subjectName &#x3D; name;</span><br><span class="line">        math.score &#x3D; score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void showStudentScore() &#123;</span><br><span class="line">        int total &#x3D; korea.score + math.score;</span><br><span class="line">        System.out.println(studentName+&quot;의 총점은 &quot;+total+&quot;점 입니다.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>String과는 다르게    </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">korea &#x3D; new Subject();</span><br></pre></td></tr></table></figure>
<p>처럼 생성 단계가 필요한데, 보통 생성자에 넣어둔다.   </p>
<p>실행</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package reference;</span><br><span class="line"></span><br><span class="line">public class StudentTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        Student studentLee &#x3D; new Student(101,&quot;Lee&quot;);</span><br><span class="line"></span><br><span class="line">        studentLee.setKoreaSubject(&quot;국어&quot;,100);</span><br><span class="line">        studentLee.setMathSubject(&quot;수학&quot;,95);</span><br><span class="line"></span><br><span class="line">        Student studentKim &#x3D; new Student(102,&quot;Kim&quot;);</span><br><span class="line"></span><br><span class="line">        studentKim.setKoreaSubject(&quot;국어&quot;,80);</span><br><span class="line">        studentKim.setMathSubject(&quot;수학&quot;,99);</span><br><span class="line"></span><br><span class="line">        studentLee.showStudentScore();</span><br><span class="line">        studentKim.showStudentScore();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Study</category>
        <category>JAVA OOP</category>
      </categories>
  </entry>
  <entry>
    <title>09. 정보 은닉</title>
    <url>/2020/08/12/hexo_OOP_09/</url>
    <content><![CDATA[<h1 id="객체-지향-프로그래밍"><a href="#객체-지향-프로그래밍" class="headerlink" title="객체 지향 프로그래밍"></a>객체 지향 프로그래밍</h1><h4 id="09-정보-은닉"><a href="#09-정보-은닉" class="headerlink" title="09. 정보 은닉"></a>09. 정보 은닉</h4><ul>
<li><p>접근 제어자 : 변수, 메서드, 생성자에 대한 접근 권한 지정<br>public : 완전 공개<br>private : 해당 클래스 내에서만 공개<br>protected : 상위 클래스의 private변수를 하위 클래스에서 public으로 쓰고 싶을 때<br>default : 같은 패키지 내에서만 공개    </p>
<ul>
<li>정보은닉<br>클래스 내부의 정보에 접근하지 못하도록 함<br>(private 접근 제어자를 통한 정보 은닉)<br>private를 외부에서 접근하게 하려면 public 메서드 제공</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package hiding;</span><br><span class="line"></span><br><span class="line">public class MyDate &#123;</span><br><span class="line"></span><br><span class="line">    private int day;</span><br><span class="line">    private int month;</span><br><span class="line">    private int year;</span><br><span class="line"></span><br><span class="line">    private boolean isValid&#x3D;true; &#x2F;&#x2F;멤버 변수 boolean은 선언과 동시에 false로 대입된다.</span><br><span class="line"></span><br><span class="line">    public void setDay(int day) &#123; &#x2F;&#x2F;private 멤버 변수의 외부 입력을 위한 public 메서드 제공</span><br><span class="line">        if (day&lt;0 || day&gt;31) &#123;    &#x2F;&#x2F;잘못된 사용 방지</span><br><span class="line">            isValid &#x3D; false;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            this.day &#x3D; day;       &#x2F;&#x2F;멤버 변수와 매개 변수의 이름이 같은 경우 this.멤버변수</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setMonth(int month) &#123;</span><br><span class="line">        if (month&lt;0 || month&gt;12) &#123;</span><br><span class="line">            isValid &#x3D; false;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            this.month &#x3D; month;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setYear(int year) &#123;</span><br><span class="line">        if (year&lt;0) &#123;</span><br><span class="line">            isValid &#x3D; false;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            this.year &#x3D; year;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getDay() &#123; &#x2F;&#x2F;private 멤버 변수의 외부 참조를 위한 public 메서드 제공</span><br><span class="line">        return day;</span><br><span class="line">    &#125;</span><br><span class="line">    public int getMonth() &#123; </span><br><span class="line">        return month;</span><br><span class="line">    &#125;</span><br><span class="line">    public int getYear() &#123; </span><br><span class="line">        return year;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void showDate() &#123;</span><br><span class="line"></span><br><span class="line">        if (isValid) &#123; &#x2F;&#x2F;잘못된 사용 검</span><br><span class="line">            System.out.println(year+&quot;년 &quot;+month+&quot;월 &quot;+day+&quot;일 &quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;유효하지 않은 날짜 입니다.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>보통 위와 같은 public 메서드의 이름을 set get으로 시작하여 생성하지만,<br>다른 이름으로 생성도 가능하다.</p>
<p>외부 접근</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package hiding;</span><br><span class="line"></span><br><span class="line">public class MyDateTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        MyDate date &#x3D; new MyDate();</span><br><span class="line"></span><br><span class="line">        date.setDay(10);</span><br><span class="line">        date.setMonth(7);</span><br><span class="line">        date.setYear(2019);</span><br><span class="line"></span><br><span class="line">        date.showDate();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Study</category>
        <category>JAVA OOP</category>
      </categories>
  </entry>
  <entry>
    <title>11. this에 대하여</title>
    <url>/2020/08/12/hexo_OOP_11/</url>
    <content><![CDATA[<h1 id="객체-지향-프로그래밍"><a href="#객체-지향-프로그래밍" class="headerlink" title="객체 지향 프로그래밍"></a>객체 지향 프로그래밍</h1><h4 id="11-this에-대하여"><a href="#11-this에-대하여" class="headerlink" title="11. this에 대하여"></a>11. this에 대하여</h4><ul>
<li>this의 역할  </li>
</ul>
<p>자신의 메모리를 가리킴    </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    BirthDay day &#x3D; new BirthDay();</span><br><span class="line">    day.setYear(2000); &#x2F;&#x2F;setYear 메서드에 this가 있을때 생성된 인스턴스(day)의 메모리</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>생성자에서 다른 생성자를 호출 함  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public Person() &#123;</span><br><span class="line">    &#x2F;&#x2F;age &#x3D; 10;     &#x2F;&#x2F;this로 다른 생성자를 호출할때 그위에 다른 statement는 올 수 없다.</span><br><span class="line">    this(&quot;이름 없음&quot;,1);  &#x2F;&#x2F;아래의 생성자 호출하여 변수 초기화</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Person(String name,int age) &#123;</span><br><span class="line">    this.name &#x3D; name;</span><br><span class="line">    this.age &#x3D; age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>인스턴스 자신의 주소를 반환     </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public Person getSelf() &#123; &#x2F;&#x2F;반환 타입은 자기 클래스 자신</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Person personLee &#x3D; new Person(&quot;Lee&quot;,20);</span><br><span class="line">System.out.println(personLee);</span><br><span class="line">&#x2F;&#x2F;위와 아래는 같은 결과 (인스턴스의 메모리 주소)</span><br><span class="line">Person p &#x3D; personLee.getSelf();</span><br><span class="line">System.out.println(p);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Study</category>
        <category>JAVA OOP</category>
      </categories>
  </entry>
  <entry>
    <title>12. 객체 간 협력</title>
    <url>/2020/08/12/hexo_OOP_12/</url>
    <content><![CDATA[<h1 id="객체-지향-프로그래밍"><a href="#객체-지향-프로그래밍" class="headerlink" title="객체 지향 프로그래밍"></a>객체 지향 프로그래밍</h1><h4 id="12-객체-간-협력"><a href="#12-객체-간-협력" class="headerlink" title="12. 객체 간 협력"></a>12. 객체 간 협력</h4><p>객체 지향 프로그램은 객체를 정의 하고 객체 간의 ‘협력’을 구현한 프로그램     </p>
<p>학생, 버스, 지하철 객체 간 협력 프로그램</p>
<ul>
<li><p>학생</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package cooperation;</span><br><span class="line"></span><br><span class="line">public class Student &#123;</span><br><span class="line"></span><br><span class="line">    String studentName;</span><br><span class="line">    int grade;</span><br><span class="line">    int money;</span><br><span class="line"></span><br><span class="line">    public Student(String studentName,int money) &#123;</span><br><span class="line"></span><br><span class="line">        this.studentName &#x3D; studentName;</span><br><span class="line">        this.money &#x3D; money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void takeBus(Bus bus) &#123;  &#x2F;&#x2F;버스 객체와의 협업</span><br><span class="line">        bus.take(1000);</span><br><span class="line">        this.money -&#x3D; 1000;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void takeSubway(Subway subway) &#123;  &#x2F;&#x2F;지하철 객체와의 협업</span><br><span class="line">        subway.take(1200);</span><br><span class="line">        this.money -&#x3D; 1200;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void showInfo() &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(studentName+&quot;님의 남은 돈은 &quot;+money+&quot;원 입니다.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>버스</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package cooperation;</span><br><span class="line"></span><br><span class="line">public class Bus &#123;</span><br><span class="line"></span><br><span class="line">    int busNumber;</span><br><span class="line">    int passengerCount;</span><br><span class="line">    int money;</span><br><span class="line"></span><br><span class="line">    public Bus(int busNumber) &#123;</span><br><span class="line">        this.busNumber &#x3D; busNumber;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void take(int money) &#123; &#x2F;&#x2F;승차 메서드</span><br><span class="line">        this.money +&#x3D; money;</span><br><span class="line">        this.passengerCount++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void showBusInfo() &#123;</span><br><span class="line">        System.out.println(busNumber+&quot;번 버스의 승객은 &quot;+passengerCount+&quot;명 이고, 수입은 &quot;+money+&quot;원 입니다.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>지하철</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package cooperation;</span><br><span class="line"></span><br><span class="line">public class Subway &#123;</span><br><span class="line"></span><br><span class="line">    int lineNumber;</span><br><span class="line">    int passengerCount;</span><br><span class="line">    int money;</span><br><span class="line"></span><br><span class="line">    public Subway(int lineNumber) &#123;</span><br><span class="line">        this.lineNumber &#x3D; lineNumber;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void take(int money) &#123;</span><br><span class="line">        this.money +&#x3D; money;</span><br><span class="line">        this.passengerCount++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void showBusInfo() &#123;</span><br><span class="line">        System.out.println(lineNumber+&quot;번 버스의 승객은 &quot;+passengerCount+&quot;명 이고, 수입은 &quot;+money+&quot;원 입니다.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
]]></content>
      <categories>
        <category>Study</category>
        <category>JAVA OOP</category>
      </categories>
  </entry>
  <entry>
    <title>14. static 변수, 메서드</title>
    <url>/2020/08/12/hexo_OOP_14/</url>
    <content><![CDATA[<h1 id="객체-지향-프로그래밍"><a href="#객체-지향-프로그래밍" class="headerlink" title="객체 지향 프로그래밍"></a>객체 지향 프로그래밍</h1><h4 id="14-static-변수-메서드"><a href="#14-static-변수-메서드" class="headerlink" title="14. static 변수, 메서드"></a>14. static 변수, 메서드</h4><p>여러 인스턴스가 같은 변수 및 메서드를 공유해야할 필요가 있을때   </p>
<ul>
<li><p>static 변수</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private static int serialNum &#x3D; 1000;</span><br></pre></td></tr></table></figure>
<p>처음 프로그램이 로드될 때 데이터 영역에 생성됨<br>클래스 이름으로 참조     </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Student.serialNum &#x3D; 100;</span><br></pre></td></tr></table></figure>
</li>
<li><p>static 메서드<br>static 변수를 위한 기능을 제공하는 메서드<br>인스턴스 변수를 사용할 수 없음   </p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static int getSerialNum() &#123;   &#x2F;&#x2F;static 메서드</span><br><span class="line">    int i &#x3D; 0;   &#x2F;&#x2F; 지역변수 사용가능</span><br><span class="line">    &#x2F;&#x2F;studentName &#x3D; &quot;Lee&quot;; &#x2F;&#x2F;인스턴스 변수 사용할 수 없음</span><br><span class="line">    return serialNum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>클래스 이름으로 참조</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">System.out.println(Student.getSerialNum());</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package staticex;</span><br><span class="line"></span><br><span class="line">public class Student &#123;</span><br><span class="line"></span><br><span class="line">    private static int serialNum &#x3D; 1000; &#x2F;&#x2F;인스턴스 들이 공유함. 그렇기 때문에 외부에서 변경을 피하기 위하여 보통 private로 만</span><br><span class="line">    private int studentId;</span><br><span class="line">    public String studentName;</span><br><span class="line">    public String address;</span><br><span class="line"></span><br><span class="line">    public Student(String name) &#123;</span><br><span class="line">        studentName &#x3D; name;</span><br><span class="line">        serialNum++;   &#x2F;&#x2F;객체 생성시 static 변수 증가하도록</span><br><span class="line">        studentId &#x3D; serialNum;    &#x2F;&#x2F;증가된 serialNum을 학번으로</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getStudentId() &#123;</span><br><span class="line">        return studentId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void showStudentInfo() &#123;</span><br><span class="line">        System.out.println(studentName+&quot;,&quot;+address);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static int getSerialNum() &#123;   &#x2F;&#x2F;static 메서드</span><br><span class="line">        int i &#x3D; 0;   &#x2F;&#x2F; 지역변수 사용가능</span><br><span class="line">        &#x2F;&#x2F;studentName &#x3D; &quot;Lee&quot;; &#x2F;&#x2F;인스턴스 변수 사용할 수 없음</span><br><span class="line">        return serialNum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void setSerialNum(int serialNum) &#123;</span><br><span class="line">        Student.serialNum &#x3D; serialNum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package staticex;</span><br><span class="line"></span><br><span class="line">public class StudentTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        Student studentLee &#x3D; new Student(&quot;Lee&quot;);</span><br><span class="line">        System.out.println(Student.getSerialNum());</span><br><span class="line">        Student studentKim &#x3D; new Student(&quot;Kim&quot;);</span><br><span class="line"></span><br><span class="line">        System.out.println(Student.getSerialNum());</span><br><span class="line"></span><br><span class="line">        System.out.println(studentLee.getStudentId());</span><br><span class="line">        System.out.println(studentKim.getStudentId());</span><br><span class="line"></span><br><span class="line">        System.out.println(Student.getSerialNum());&#x2F;&#x2F;실제 static 변수 또는 메서드 사용은 이것 처럼 참조 변수가 아닌 클래스 이름에서 참조</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Study</category>
        <category>JAVA OOP</category>
      </categories>
  </entry>
  <entry>
    <title>15. static 응용</title>
    <url>/2020/08/12/hexo_OOP_15/</url>
    <content><![CDATA[<h1 id="객체-지향-프로그래밍"><a href="#객체-지향-프로그래밍" class="headerlink" title="객체 지향 프로그래밍"></a>객체 지향 프로그래밍</h1><h4 id="15-static-응용"><a href="#15-static-응용" class="headerlink" title="15. static 응용"></a>15. static 응용</h4><ul>
<li>singleton pattern<br>단 하나만 존재하는 인스턴스 (ex 학교 객체)<br>생성자는 private로 생성<br>클래스 내에서 static으로 유일한 객체 생성<br>외부에서 유일한 객체를 참조할 수 있는 public static get() 메서드 구현    </li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package staticex;</span><br><span class="line"></span><br><span class="line">public class Company &#123;</span><br><span class="line"></span><br><span class="line">    private static Company instance &#x3D; new Company(); &#x2F;&#x2F;내부적으로 인스턴스 생성</span><br><span class="line"></span><br><span class="line">    private Company() &#123; &#x2F;&#x2F;생성자 private로 생성</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Company getInstance() &#123;  &#x2F;&#x2F;외부에서 인스턴스 생성과 무관하게 사용하기 위해 static으로 생성</span><br><span class="line">        if (instance&#x3D;&#x3D;null) &#123;</span><br><span class="line">            instance &#x3D; new Company();</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package staticex;</span><br><span class="line"></span><br><span class="line">import java.util.Calendar;</span><br><span class="line"></span><br><span class="line">public class CompanyTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;Company company &#x3D; new Company(); &#x2F;&#x2F;private 생성자 이므로 인스턴스 생성할 수 없음</span><br><span class="line">        Company company1&#x3D;Company.getInstance();</span><br><span class="line">        Company company2&#x3D;Company.getInstance();</span><br><span class="line"></span><br><span class="line">        System.out.println(company1);</span><br><span class="line">        System.out.println(company2); &#x2F;&#x2F;두 인스턴스의 메모리 주소가 동일하다</span><br><span class="line"></span><br><span class="line">        Calendar calendar &#x3D; Calendar.getInstance(); &#x2F;&#x2F;Calendar 클래스는 싱글톤 패턴으로 구현되어 있다.</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Study</category>
        <category>JAVA OOP</category>
      </categories>
  </entry>
  <entry>
    <title>17. 배열</title>
    <url>/2020/08/12/hexo_OOP_17/</url>
    <content><![CDATA[<h1 id="객체-지향-프로그래밍"><a href="#객체-지향-프로그래밍" class="headerlink" title="객체 지향 프로그래밍"></a>객체 지향 프로그래밍</h1><h4 id="17-배열"><a href="#17-배열" class="headerlink" title="17. 배열"></a>17. 배열</h4><ul>
<li>배열이란<br>동일한 자료형의 순차적 자료 구조<br>ex) 학생 100명에 대한 학번 변수</li>
</ul>
<p>배열 선언</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int[] arr &#x3D; new int[10]; &#x2F;&#x2F;int 10개 &#x3D; 40byte length&#x3D;10, 0~9</span><br><span class="line">int arr[] &#x3D; new int[10];</span><br></pre></td></tr></table></figure>
<p>배열은 fixed length이기 때문에<br>만약 배열의 길이를 늘리고 싶다면,<br>더 긴 배열을 선언한 뒤 값을 복사해야 한다.   </p>
<p>배열은 연속적이어야 한다.  (중간에 비어있으면 안된다.)<br>데이터가 들어가거나 빠질때 추가적인 작업이 필요하다.   </p>
<p>배열을 사용하는 가장 큰 이유 : 인덱스 연산자  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">arr[4] &#x2F;&#x2F;추출이 편하고 속도가 빠름</span><br></pre></td></tr></table></figure>

<p>ArrayList를 쓰면 편하게 배열을 사용할 수 있다.     </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package array;</span><br><span class="line"></span><br><span class="line">public class ArrayTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        int[] arr &#x3D; new int[10]; &#x2F;&#x2F;기본자료형 Array</span><br><span class="line">        &#x2F;&#x2F;int[] arr &#x3D; new int[] &#123;1,2,3&#125;; &#x2F;&#x2F;선언과 동시에 초기화 가능</span><br><span class="line">        &#x2F;&#x2F;int[] arr &#x3D; &#123;1,2,3&#125;; &#x2F;&#x2F;위와 동일</span><br><span class="line">        int total &#x3D; 0;</span><br><span class="line"></span><br><span class="line">        for (int i&#x3D;0;i&lt;arr.length;i++) &#123;</span><br><span class="line">            System.out.println(arr[i]); &#x2F;&#x2F;0으로 10개가 초기화되어 있음</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i&#x3D;0,num&#x3D;1;i&lt;arr.length;i++,num++) &#123; &#x2F;&#x2F;배열 arr의 모든 요소를 1씩 증가하도록 변경</span><br><span class="line">            arr[i]&#x3D;num;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i&#x3D;0;i&lt;arr.length;i++) &#123;</span><br><span class="line">            System.out.println(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i&#x3D;0;i&lt;arr.length;i++) &#123; &#x2F;&#x2F;배열 요소 합 구하기</span><br><span class="line">            total +&#x3D; arr[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(total);</span><br><span class="line"></span><br><span class="line">        double[] dArr &#x3D; new double[5];</span><br><span class="line">        int count &#x3D; 0;</span><br><span class="line">        dArr[0] &#x3D; 1.1; count++;</span><br><span class="line">        dArr[1] &#x3D; 2.1; count++;</span><br><span class="line">        dArr[2] &#x3D; 3.1; count++;</span><br><span class="line"></span><br><span class="line">        double mtotal &#x3D; 1;</span><br><span class="line">        for (int i&#x3D;0;i&lt;count;i++) &#123; &#x2F;&#x2F;count를 통해 직접 초기화 한 값만 곱</span><br><span class="line">            mtotal *&#x3D; dArr[i];</span><br><span class="line">            System.out.println(dArr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(mtotal);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Study</category>
        <category>JAVA OOP</category>
      </categories>
  </entry>
  <entry>
    <title>19. 객체 배열</title>
    <url>/2020/08/12/hexo_OOP_19/</url>
    <content><![CDATA[<h1 id="객체-지향-프로그래밍"><a href="#객체-지향-프로그래밍" class="headerlink" title="객체 지향 프로그래밍"></a>객체 지향 프로그래밍</h1><h4 id="19-객체-배열"><a href="#19-객체-배열" class="headerlink" title="19. 객체 배열"></a>19. 객체 배열</h4><ul>
<li>객체 배열 (참조 자료형 배열)     <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Book[] library &#x3D; new Book[5]; &#x2F;&#x2F;null이 초기화됨</span><br><span class="line">                              &#x2F;&#x2F;실제로는 객체의 주소가 들어가게 된다</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>배열로 만 클래스 생성    </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package array;</span><br><span class="line"></span><br><span class="line">public class Book &#123;</span><br><span class="line"></span><br><span class="line">    private String title;</span><br><span class="line">    private String author;</span><br><span class="line"></span><br><span class="line">    public Book() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Book(String title, String author) &#123;</span><br><span class="line">        this.title &#x3D; title;</span><br><span class="line">        this.author &#x3D; author;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getTitle() &#123;</span><br><span class="line">        return title;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setTitle(String title) &#123;</span><br><span class="line">        this.title &#x3D; title;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getAuthor() &#123;</span><br><span class="line">        return author;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAuthor(String author) &#123;</span><br><span class="line">        this.author &#x3D; author;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void showBookInfo() &#123;</span><br><span class="line">        System.out.println(title+&quot;,&quot;+author);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>객체 배열 생성 및 인스턴스 생성  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package array;</span><br><span class="line"></span><br><span class="line">public class BookArrayTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        Book[] library &#x3D; new Book[5]; &#x2F;&#x2F;객체 배열이 생긴 거지 객체 5개가 생긴건 아님</span><br><span class="line"></span><br><span class="line">        &#x2F;*for (int i&#x3D;0; i&lt;library.length; i++) &#123; &#x2F;&#x2F;인스턴스 생성1</span><br><span class="line">            library[i] &#x3D; new Book();</span><br><span class="line">        &#125;*&#x2F;</span><br><span class="line"></span><br><span class="line">        library[0] &#x3D; new Book(&quot;태백산맥1&quot;,&quot;조정래&quot;); &#x2F;&#x2F;인스턴스 생성2</span><br><span class="line">        library[1] &#x3D; new Book(&quot;태백산맥2&quot;,&quot;조정래&quot;);</span><br><span class="line">        library[2] &#x3D; new Book(&quot;태백산맥3&quot;,&quot;조정래&quot;);</span><br><span class="line">        library[3] &#x3D; new Book(&quot;태백산맥4&quot;,&quot;조정래&quot;);</span><br><span class="line">        library[4] &#x3D; new Book(&quot;태백산맥5&quot;,&quot;조정래&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        for (int i&#x3D;0; i&lt;library.length; i++) &#123;</span><br><span class="line">            System.out.println(library[i]); &#x2F;&#x2F;각 인스턴스의 메모리 주소 출력 32bit x 5</span><br><span class="line">            library[i].showBookInfo();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>기본 자료형 배열 복사</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package array;</span><br><span class="line"></span><br><span class="line">public class ArrayCopy &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        int[] arr1 &#x3D; &#123;10,20,30,40,50&#125;;</span><br><span class="line">        int[] arr2 &#x3D; &#123;1,2,3,4,5&#125;;</span><br><span class="line"></span><br><span class="line">        System.arraycopy(arr1,0,arr2,1,3); &#x2F;&#x2F;배열을 복사할때 사용하는 메서드</span><br><span class="line">                        &#x2F;&#x2F;소스,어디부터,타겟,어디부터,몇개</span><br><span class="line"></span><br><span class="line">        for (int i&#x3D;0; i&lt;arr2.length; i++) &#123;</span><br><span class="line">            System.out.println(arr2[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>객체 배열 복사</p>
</li>
</ul>
<p>얕은 복사   </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package array;</span><br><span class="line"></span><br><span class="line">public class ObjectCopy &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        Book[] library &#x3D; new Book[5];</span><br><span class="line">        Book[] copylibrary &#x3D; new Book[5];</span><br><span class="line"></span><br><span class="line">        library[0] &#x3D; new Book(&quot;태백산맥1&quot;,&quot;조정래&quot;);</span><br><span class="line">        library[1] &#x3D; new Book(&quot;태백산맥2&quot;,&quot;조정래&quot;);</span><br><span class="line">        library[2] &#x3D; new Book(&quot;태백산맥3&quot;,&quot;조정래&quot;);</span><br><span class="line">        library[3] &#x3D; new Book(&quot;태백산맥4&quot;,&quot;조정래&quot;);</span><br><span class="line">        library[4] &#x3D; new Book(&quot;태백산맥5&quot;,&quot;조정래&quot;);</span><br><span class="line"></span><br><span class="line">        System.arraycopy(library,0,copylibrary,0,5); &#x2F;&#x2F;기본자료형과 동일하게 사용하면 얕은 복사 (인스턴스 추가 생성 x)</span><br><span class="line"></span><br><span class="line">        &#x2F;*for (int i&#x3D;0; i&lt;copylibrary.length; i++) &#123;</span><br><span class="line">            copylibrary[i].showBookInfo();</span><br><span class="line">        &#125;*&#x2F;</span><br><span class="line"></span><br><span class="line">        for ( Book book : copylibrary ) &#123; &#x2F;&#x2F;향상된 for문  for ( 변수 선언 : array ) array의 모든 요소를 var에 순차적으로 입력</span><br><span class="line">            book.showBookInfo();</span><br><span class="line">        &#125;</span><br><span class="line">        library[0].setTitle(&quot;나목&quot;);</span><br><span class="line">        library[0].setAuthor(&quot;박완선&quot;);</span><br><span class="line"></span><br><span class="line">        library[0].showBookInfo();</span><br><span class="line">        copylibrary[0].showBookInfo(); &#x2F;&#x2F;동일하게 변경됨 (주소만 복사된 것이므로 동일한 인스턴스이다.) &#x3D;&#x3D; 얕은 복사</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>깊은 복사   </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package array;</span><br><span class="line"></span><br><span class="line">public class ObjectCopy2 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        Book[] library &#x3D; new Book[5];</span><br><span class="line">        Book[] copylibrary &#x3D; new Book[5];</span><br><span class="line"></span><br><span class="line">        library[0] &#x3D; new Book(&quot;태백산맥1&quot;,&quot;조정래&quot;);</span><br><span class="line">        library[1] &#x3D; new Book(&quot;태백산맥2&quot;,&quot;조정래&quot;);</span><br><span class="line">        library[2] &#x3D; new Book(&quot;태백산맥3&quot;,&quot;조정래&quot;);</span><br><span class="line">        library[3] &#x3D; new Book(&quot;태백산맥4&quot;,&quot;조정래&quot;);</span><br><span class="line">        library[4] &#x3D; new Book(&quot;태백산맥5&quot;,&quot;조정래&quot;);</span><br><span class="line"></span><br><span class="line">        copylibrary[0] &#x3D; new Book(); &#x2F;&#x2F;인스턴스 따 생성</span><br><span class="line">        copylibrary[1] &#x3D; new Book();</span><br><span class="line">        copylibrary[2] &#x3D; new Book();</span><br><span class="line">        copylibrary[3] &#x3D; new Book();</span><br><span class="line">        copylibrary[4] &#x3D; new Book();</span><br><span class="line"></span><br><span class="line">        for (int i&#x3D;0; i&lt;library.length; i++) &#123; &#x2F;&#x2F;깊은 복사</span><br><span class="line">            copylibrary[i].setTitle(library[i].getTitle());</span><br><span class="line">            copylibrary[i].setAuthor(library[i].getAuthor());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for ( Book book : copylibrary ) &#123;</span><br><span class="line">            book.showBookInfo();</span><br><span class="line">        &#125;</span><br><span class="line">        library[0].setTitle(&quot;나목&quot;);</span><br><span class="line">        library[0].setAuthor(&quot;박완선&quot;);</span><br><span class="line"></span><br><span class="line">        library[0].showBookInfo();</span><br><span class="line">        copylibrary[0].showBookInfo(); &#x2F;&#x2F;복사본은 변경되지 않음 (서로 다른 인스턴스) &#x3D;&#x3D; 깊은 복사</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Study</category>
        <category>JAVA OOP</category>
      </categories>
  </entry>
  <entry>
    <title>21. 다차원 배열</title>
    <url>/2020/08/12/hexo_OOP_21/</url>
    <content><![CDATA[<h1 id="객체-지향-프로그래밍"><a href="#객체-지향-프로그래밍" class="headerlink" title="객체 지향 프로그래밍"></a>객체 지향 프로그래밍</h1><h4 id="21-다차원-배열"><a href="#21-다차원-배열" class="headerlink" title="21. 다차원 배열"></a>21. 다차원 배열</h4><ul>
<li>다차원 배열<br>2차원 이상의 배열  </li>
</ul>
<p>2차원 배열  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int[][] arr &#x3D; new int [2][3]; &#x2F;&#x2F;6개 요소</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package array;</span><br><span class="line"></span><br><span class="line">public class TwoDimension &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;int[][] arr &#x3D; new int[2][3];</span><br><span class="line">        int[][] arr &#x3D; &#123;&#123;1,2,3&#125;,&#123;4,5,6,7&#125;&#125;;</span><br><span class="line"></span><br><span class="line">        System.out.println(arr.length); &#x2F;&#x2F;2차원 배열에서 length는 행의 개수</span><br><span class="line">        System.out.println(arr[0].length); &#x2F;&#x2F;0번째 행의 길이</span><br><span class="line">        System.out.println(arr[1].length);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;행을 기준으로 열을 돌린다.(2중 for문)</span><br><span class="line"></span><br><span class="line">        for (int i&#x3D;0; i&lt;arr.length; i++) &#123; &#x2F;&#x2F;행 for문</span><br><span class="line">            for (int j&#x3D;0; j&lt;arr[i].length; j++) &#123; &#x2F;&#x2F;열 for문</span><br><span class="line">                System.out.print(arr[i][j]+&quot; &quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Study</category>
        <category>JAVA OOP</category>
      </categories>
  </entry>
  <entry>
    <title>22. ArrayList 사용하기</title>
    <url>/2020/08/12/hexo_OOP_22/</url>
    <content><![CDATA[<h1 id="객체-지향-프로그래밍"><a href="#객체-지향-프로그래밍" class="headerlink" title="객체 지향 프로그래밍"></a>객체 지향 프로그래밍</h1><h4 id="22-ArrayList-사용하기"><a href="#22-ArrayList-사용하기" class="headerlink" title="22. ArrayList 사용하기"></a>22. ArrayList 사용하기</h4><ul>
<li>ArrayList<br>자바에서 제공하는 객체 배열이 구현된 클래스<br>객체 배열을 사용하는데 필요한 여러 메서드들이 구현되어 있음   </li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package array;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line"></span><br><span class="line">public class ArrayListTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;ArrayList list &#x3D; new ArrayList(); &#x2F;&#x2F;요소 자료형 미지정</span><br><span class="line">        ArrayList&lt;String&gt; list &#x3D; new ArrayList&lt;String&gt;(); &#x2F;&#x2F;요소 자료형 지정</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;몇가지 메서드 가능 테스트</span><br><span class="line">        list.add(&quot;aaa&quot;); &#x2F;&#x2F;add 메서드를 통해 요소 추가</span><br><span class="line">        list.add(&quot;bbb&quot;);</span><br><span class="line">        list.add(&quot;ccc&quot;);</span><br><span class="line"></span><br><span class="line">        for (String str : list) &#123; &#x2F;&#x2F;향상된 for문 사용 가능</span><br><span class="line">            System.out.println(str);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i&#x3D;0;i&lt;list.size();i++) &#123; &#x2F;&#x2F;list의 요소 총 개수는 size</span><br><span class="line">            System.out.println(list.get(i)); &#x2F;&#x2F;get 메서드를 통해 요소 참조</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>연습 (학생의 과목 별 점수 확인)     </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package array;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line"></span><br><span class="line">public class Student &#123;</span><br><span class="line"></span><br><span class="line">    int studentID;</span><br><span class="line">    String studentName;</span><br><span class="line">    ArrayList&lt;Subject&gt; subjectlist; &#x2F;&#x2F;ArrayList 변수 선언</span><br><span class="line"></span><br><span class="line">    public Student(int studentID, String studentName) &#123;</span><br><span class="line">        this.studentID &#x3D; studentID;</span><br><span class="line">        this.studentName &#x3D; studentName;</span><br><span class="line"></span><br><span class="line">        subjectlist &#x3D; new ArrayList&lt;Subject&gt;(); &#x2F;&#x2F;참조형 변수이므로 초기화를 생성자에 넣어주자</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void addSubject(String name, int score) &#123;</span><br><span class="line">        Subject subject &#x3D; new Subject(name,score); &#x2F;&#x2F;배열이 비어있으므로 subject 객체 생성</span><br><span class="line">        subjectlist.add(subject);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void showStudentInfo() &#123;</span><br><span class="line"></span><br><span class="line">        int total&#x3D;0;</span><br><span class="line"></span><br><span class="line">        for ( Subject subject : subjectlist ) &#123;</span><br><span class="line">            total +&#x3D; subject.getScore();</span><br><span class="line">            System.out.println(studentName+&quot;의 &quot;+subject.getName()+&quot;과목 성적은 &quot;+subject.getScore()+&quot;점 입니다.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;총점은 &quot;+total+&quot;점 입니다.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package array;</span><br><span class="line"></span><br><span class="line">public class Subject &#123;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line">    private int score;</span><br><span class="line"></span><br><span class="line">    public Subject(String name, int score) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">        this.score &#x3D; score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getScore() &#123;</span><br><span class="line">        return score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setScore(int score) &#123;</span><br><span class="line">        this.score &#x3D; score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package array;</span><br><span class="line"></span><br><span class="line">public class StudentTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        Student Lee &#x3D; new Student(101,&quot;Lee&quot;);</span><br><span class="line">        Student Kim &#x3D; new Student(102,&quot;Kim&quot;);</span><br><span class="line"></span><br><span class="line">        Lee.addSubject(&quot;국어&quot;,100);</span><br><span class="line">        Lee.addSubject(&quot;수학&quot;,90);</span><br><span class="line">        Kim.addSubject(&quot;국어&quot;,100);</span><br><span class="line">        Kim.addSubject(&quot;수학&quot;,90);</span><br><span class="line">        Kim.addSubject(&quot;영어&quot;,80);</span><br><span class="line"></span><br><span class="line">        Lee.showStudentInfo();</span><br><span class="line">        Kim.showStudentInfo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Study</category>
        <category>JAVA OOP</category>
      </categories>
  </entry>
  <entry>
    <title>25. 상속이란</title>
    <url>/2020/08/12/hexo_OOP_25/</url>
    <content><![CDATA[<h1 id="객체-지향-프로그래밍"><a href="#객체-지향-프로그래밍" class="headerlink" title="객체 지향 프로그래밍"></a>객체 지향 프로그래밍</h1><h4 id="25-상속이란"><a href="#25-상속이란" class="headerlink" title="25. 상속이란"></a>25. 상속이란</h4><p>클래스에서 상속의 의미 :<br>새로운 클래스를 정의할 때 이미 구현된 클래스를 상속받아서<br>속성이나 기능이 확장되는 클래스를 구현 함.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class B extends A &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>상속하는 클래스 : 상위 클래스<br>상속받는 클래스 : 하위 클래스   </p>
<p>자바에서는 다중 상속이 불가능하다.     </p>
<p>상속을 사용하는 경우 :<br>상위클래스는 더 일반적인 개념과 기능을 가짐<br>하위클래스는 더 구체적인 개념과 기능을 가짐    </p>
<p>상위 클래스</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package inheritance;</span><br><span class="line"></span><br><span class="line">public class Customer &#123;</span><br><span class="line"></span><br><span class="line">    protected int customerID; &#x2F;&#x2F; 하위 클래스들이 참조할수 있도록 private가 아닌 protected 사용</span><br><span class="line">    protected String customerName;</span><br><span class="line">    protected String customerGrade;</span><br><span class="line">    int bonusPoint;</span><br><span class="line">    double bonusRatio;</span><br><span class="line"></span><br><span class="line">    public Customer() &#123;</span><br><span class="line">        customerGrade&#x3D;&quot;SILVER&quot;;</span><br><span class="line">        bonusRatio&#x3D;0.01;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int calcPrice(int price) &#123;</span><br><span class="line">        bonusPoint +&#x3D; price*bonusRatio;</span><br><span class="line">        return price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String showCustomerInfo() &#123;</span><br><span class="line">        return customerName+&quot;님의 등금은 &quot;+customerGrade+&quot;이며, 적립된 포인트는 &quot;+bonusPoint+&quot;점 입니다.&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getCustomerID() &#123;</span><br><span class="line">        return customerID;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setCustomerID(int customerID) &#123;</span><br><span class="line">        this.customerID &#x3D; customerID;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getCustomerName() &#123;</span><br><span class="line">        return customerName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setCustomerName(String customerName) &#123;</span><br><span class="line">        this.customerName &#x3D; customerName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getCustomerGrade() &#123;</span><br><span class="line">        return customerGrade;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setCustomerGrade(String customerGrade) &#123;</span><br><span class="line">        this.customerGrade &#x3D; customerGrade;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>하위 클래스</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package inheritance;</span><br><span class="line"></span><br><span class="line">public class VIPCustomer extends Customer&#123; &#x2F;&#x2F;상위 클래스(Customer) 지정</span><br><span class="line"></span><br><span class="line">    double salesRatio;</span><br><span class="line">    private int agentID;</span><br><span class="line"></span><br><span class="line">    public VIPCustomer() &#123;</span><br><span class="line">        customerGrade &#x3D; &quot;VIP&quot;; &#x2F;&#x2F;만약 상위 클래스에서 private인 경우 사용할 수 없음</span><br><span class="line">        bonusRatio &#x3D; 0.05;</span><br><span class="line">        salesRatio &#x3D; 0.1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>사용</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package inheritance;</span><br><span class="line"></span><br><span class="line">public class CustomerTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        Customer Lee &#x3D; new Customer();</span><br><span class="line">        Customer Kim &#x3D; new VIPCustomer();</span><br><span class="line"></span><br><span class="line">        Lee.setCustomerID(10010);</span><br><span class="line">        Lee.setCustomerName(&quot;이순신&quot;);</span><br><span class="line">        Lee.bonusPoint &#x3D; 1000;</span><br><span class="line"></span><br><span class="line">        Kim.setCustomerID(10020);    &#x2F;&#x2F;하위 클래스에서 상위 클래스의 기능 사용</span><br><span class="line">        Kim.setCustomerName(&quot;김유신&quot;);</span><br><span class="line">        Kim.bonusPoint &#x3D; 10000;</span><br><span class="line"></span><br><span class="line">        System.out.println(Lee.showCustomerInfo());</span><br><span class="line">        System.out.println(Kim.showCustomerInfo());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Study</category>
        <category>JAVA OOP</category>
      </categories>
  </entry>
  <entry>
    <title>27. 상속에서 클래스 생성 과정과 형변환</title>
    <url>/2020/08/12/hexo_OOP_27/</url>
    <content><![CDATA[<h1 id="객체-지향-프로그래밍"><a href="#객체-지향-프로그래밍" class="headerlink" title="객체 지향 프로그래밍"></a>객체 지향 프로그래밍</h1><h4 id="27-상속에서-클래스-생성-과정과-형변환"><a href="#27-상속에서-클래스-생성-과정과-형변환" class="headerlink" title="27. 상속에서 클래스 생성 과정과 형변환"></a>27. 상속에서 클래스 생성 과정과 형변환</h4><p>하위 클래스 생성시 항상 상위 클래스가 먼저 생성되어야 한다.     </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package inheritance;</span><br><span class="line"></span><br><span class="line">public class VIPCustomer extends Customer&#123; &#x2F;&#x2F;상위 클래스(Customer) 지정</span><br><span class="line"></span><br><span class="line">    double salesRatio;</span><br><span class="line">    private int agentID;</span><br><span class="line"></span><br><span class="line">    public VIPCustomer() &#123;</span><br><span class="line">        &#x2F;&#x2F;super(); &#x2F;&#x2F;아무런 상위 클래스 생성자 호출 명령이 없으면 pre-compile 단계에서 이 함수가 들어감</span><br><span class="line">                   &#x2F;&#x2F;super : 상위 클래스의 메모리 위치 함수, super() : 상위 클래스의 기본 생성자 호출</span><br><span class="line">        &#x2F;&#x2F;super(0, null); &#x2F;&#x2F;만약 상위 클래스의 기본 생성자가 없으면, 명시적으로 상위 클래스의 생성자를 호출해야 한다.</span><br><span class="line">        customerGrade &#x3D; &quot;VIP&quot;; &#x2F;&#x2F;만약 상위 클래스에서 private인 경우 사용할 수 없음</span><br><span class="line">        bonusRatio &#x3D; 0.05;</span><br><span class="line">        salesRatio &#x3D; 0.1;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;VIPCustomer() 생성자 호출&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;*public VIPCustomer(int customerID, String customerName) &#123;</span><br><span class="line">    &#x2F;&#x2F;만약 상위 클래스의 기본 생성자가 없으면, 명시적으로 상위 클래스의 생성자를 호출해야 한다. 방법2</span><br><span class="line">        super(customerID, customerName);</span><br><span class="line">        customerGrade &#x3D; &quot;VIP&quot;;</span><br><span class="line">        bonusRatio &#x3D; 0.05;</span><br><span class="line">        salesRatio &#x3D; 0.1;</span><br><span class="line">    &#125;*&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>상위 클래스로의 묵시적 형변환 (업캐스팅)<br>상속관계에서 모든 하위 클래스는 상위 클래스로 묵시적 형변환이 된다.<br>(하위 클래스는 상위 클래스의 타입을 내포하고 있다.)<br>그 역은 성립하지 않는다.  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Customer Lee &#x3D; new VIPCustomer();</span><br><span class="line">&#x2F;&#x2F;or</span><br><span class="line">VIPCustomer Lee &#x3D; new VIPCustomer();</span><br></pre></td></tr></table></figure>
둘다 VIPCustomer 인스턴스를 생성하는 코드이지만..<br>위의 코드(업캐스팅 사용한)는 type이 Customer이므로,<br>Customer의 변수/메서드만 접근할 수 있다.<br>다만 VIPCustomer관련 멤버변수 메모리는 힙 영역에 생성되긴 한다.    </li>
</ul>
]]></content>
      <categories>
        <category>Study</category>
        <category>JAVA OOP</category>
      </categories>
  </entry>
  <entry>
    <title>28. 메서드 오버라이딩</title>
    <url>/2020/08/12/hexo_OOP_28/</url>
    <content><![CDATA[<h1 id="객체-지향-프로그래밍"><a href="#객체-지향-프로그래밍" class="headerlink" title="객체 지향 프로그래밍"></a>객체 지향 프로그래밍</h1><h4 id="28-메서드-오버라이딩"><a href="#28-메서드-오버라이딩" class="headerlink" title="28. 메서드 오버라이딩"></a>28. 메서드 오버라이딩</h4><ul>
<li>오버라이딩<br>상위 클래스에 정의된 메서드의 구현 내용이 하위 클래스에서 구현할 내용과 맞지 않는 경우 하위 클래스에서 동일한 이름의 메서드를 재정의할 수 있다.  </li>
</ul>
<p>상위 클래스 Customer</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int calcPrice(int price) &#123;</span><br><span class="line">    bonusPoint +&#x3D; price*bonusRatio;</span><br><span class="line">    return price;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>하위 클래스 VIPCustomer (VIP 할인 추가를 위한 메서드 재정의)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override &#x2F;&#x2F;애노테이션.. 컴파일러에게 특정한 정보를 제공해주는 역할     </span><br><span class="line">          &#x2F;&#x2F;@Override는 오버라이딩 정보 제공  </span><br><span class="line">public int calcPrice(int price) &#123; &#x2F;&#x2F;오버라이딩 소스 메서드와 선언부가 동일해야 한다</span><br><span class="line">    bonusPoint +&#x3D; price*bonusRatio;</span><br><span class="line">    return price - (int)(price*salesRatio);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>만약 객체 상속의 묵시적 형변환(업캐스팅)이 있는 경우에는..</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Customer Lee &#x3D; new VIPCustomer();</span><br><span class="line">Lee.calcPrice(1000);</span><br></pre></td></tr></table></figure>
<p>위의 calcPrice 메서드는 인스턴스의 메서드를 사용한다.<br>즉, VIPCustomer 클래스에서 재정의된 calcPrice 메서드를 사용한다.(가상함수)  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package inheritance;</span><br><span class="line"></span><br><span class="line">public class OverridingTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        VIPCustomer Lee &#x3D; new VIPCustomer();</span><br><span class="line">        Lee.setCustomerID(10010);</span><br><span class="line">        Lee.setCustomerName(&quot;이순신&quot;);</span><br><span class="line">        Lee.bonusPoint &#x3D; 20000;</span><br><span class="line"></span><br><span class="line">        Customer Kim &#x3D; new VIPCustomer(); &#x2F;&#x2F;업캐스팅 </span><br><span class="line">        Kim.setCustomerID(10020);</span><br><span class="line">        Kim.setCustomerName(&quot;김유신&quot;);</span><br><span class="line">        Kim.bonusPoint &#x3D; 10000;</span><br><span class="line"></span><br><span class="line">        System.out.println(Lee.showCustomerInfo());</span><br><span class="line">        System.out.println(Kim.showCustomerInfo());</span><br><span class="line">        System.out.println(Lee.calcPrice(1000)); &#x2F;&#x2F;1000-1000*0.1 &#x3D; 900</span><br><span class="line">        System.out.println(Kim.calcPrice(1000)); &#x2F;&#x2F;1000-1000*0.1 &#x3D; 900 가상 메서드 사용</span><br><span class="line">        &#x2F;&#x2F;동일하게 인스턴스의 메서드를 사용한다.</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Study</category>
        <category>JAVA OOP</category>
      </categories>
  </entry>
  <entry>
    <title>28. 다형성</title>
    <url>/2020/08/12/hexo_OOP_29/</url>
    <content><![CDATA[<h1 id="객체-지향-프로그래밍"><a href="#객체-지향-프로그래밍" class="headerlink" title="객체 지향 프로그래밍"></a>객체 지향 프로그래밍</h1><h4 id="28-다형성"><a href="#28-다형성" class="headerlink" title="28. 다형성"></a>28. 다형성</h4><ul>
<li>다형성 이란<br>하나의 코드가 여러 자료형으로 구현되어 실행되는 것<br>같은 코드에서 여러 실행 결과가 나옴    </li>
</ul>
<p>정보은닉, 상속과 더불어 객체지향 프로그래밍의 가장 큰 특징 중 하나이다.<br>OOP의 유연성, 재활용성, 유지보수성에 기본이 되는 특징이다.     </p>
<ul>
<li>다형성의 장점<br>유사한 클래스가 추가되는 경우의 유지보수에 용이하고<br>각 자료형 마다 다른 메서드를 호출하지 않으므로 코드에서 많은 if문이 사라진다.   </li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package polymorphism;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line"></span><br><span class="line">class Animal &#123;</span><br><span class="line"></span><br><span class="line">    public void move() &#123;</span><br><span class="line">        System.out.println(&quot;동물이 움직입니다.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Human extends Animal &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void move() &#123;</span><br><span class="line">        System.out.println(&quot;사람이 두 발로 걷습니다.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Tiger extends Animal &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void move() &#123;</span><br><span class="line">        System.out.println(&quot;호랑이가 네 발로 뜁니다.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Eagle extends Animal &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void move() &#123;</span><br><span class="line">        System.out.println(&quot;독수리가 하늘을 날아갑니다.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class AnimalTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        Animal hAnimal &#x3D; new Human();</span><br><span class="line">        Animal tAnimal &#x3D; new Tiger();</span><br><span class="line">        Animal eAnimal &#x3D; new Eagle();</span><br><span class="line"></span><br><span class="line">        &#x2F;*AnimalTest test &#x3D; new AnimalTest();</span><br><span class="line">        test.moveAnimal(hAnimal);</span><br><span class="line">        test.moveAnimal(tAnimal);</span><br><span class="line">        test.moveAnimal(eAnimal);*&#x2F;</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;Animal&gt; animalList &#x3D; new ArrayList&lt;Animal&gt;();</span><br><span class="line">        animalList.add(hAnimal);</span><br><span class="line">        animalList.add(tAnimal);</span><br><span class="line">        animalList.add(eAnimal);</span><br><span class="line"></span><br><span class="line">        for(Animal animal : animalList) &#123;</span><br><span class="line">            animal.move(); &#x2F;&#x2F;다형성 </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void moveAnimal(Animal animal) &#123;</span><br><span class="line">        animal.move(); &#x2F;&#x2F;하나의 코드에서 여러 자료형을 구현하여 여러 결과가 나옴. (다형성)</span><br><span class="line">                       &#x2F;&#x2F;매개변수는 Animal이지만 실제 호된 move는 Human, Tiger, Eagle의 메서드. (업캐스팅,오버라이딩)</span><br><span class="line">                       &#x2F;&#x2F;여러 클래스가 Animal이라는 타입 하나로 수행될 수 있음.</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Study</category>
        <category>JAVA OOP</category>
      </categories>
  </entry>
  <entry>
    <title>31. 다운캐스팅과 instanceof</title>
    <url>/2020/08/12/hexo_OOP_31/</url>
    <content><![CDATA[<h1 id="객체-지향-프로그래밍"><a href="#객체-지향-프로그래밍" class="headerlink" title="객체 지향 프로그래밍"></a>객체 지향 프로그래밍</h1><h4 id="31-다운캐스팅과-instanceof"><a href="#31-다운캐스팅과-instanceof" class="headerlink" title="31. 다운캐스팅과 instanceof"></a>31. 다운캐스팅과 instanceof</h4><ul>
<li>다운캐스팅<br>묵시적으로 업캐스팅된 인스턴스가 원래의 자료형(하위 클래스)으로 변환되어야 할 때 사용.<br>다운캐스팅은 명시적으로 이루어진다.    </li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Customer vc &#x3D; new VIPCustomer(); &#x2F;&#x2F;업캐스팅 - 묵시적</span><br><span class="line">VIPCustomer vCustomer &#x3D; (VIPCustomer)vc; &#x2F;&#x2F;다운캐스팅 - 명시적</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package polymorphism;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line"></span><br><span class="line">class Animal &#123;</span><br><span class="line"></span><br><span class="line">    public void move() &#123;</span><br><span class="line">        System.out.println(&quot;동물이 움직입니다.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Human extends Animal &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void move() &#123;</span><br><span class="line">        System.out.println(&quot;사람이 두 발로 걷습니다.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void readBooks() &#123;</span><br><span class="line">        System.out.println(&quot;사람이 책을 읽습니다.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Tiger extends Animal &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void move() &#123;</span><br><span class="line">        System.out.println(&quot;호랑이가 네 발로 뜁니다.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void hunting() &#123;</span><br><span class="line">        System.out.println(&quot;호랑이가 사냥을 합니다.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Eagle extends Animal &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void move() &#123;</span><br><span class="line">        System.out.println(&quot;독수리가 하늘을 날아갑니다.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void flying() &#123;</span><br><span class="line">        System.out.println(&quot;독수리가 날개를 쭉 펴고 멀리 날아갑니다.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class AnimalTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        Animal hAnimal &#x3D; new Human();</span><br><span class="line">        Animal tAnimal &#x3D; new Tiger();</span><br><span class="line">        Animal eAnimal &#x3D; new Eagle();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;Eagle eagle &#x3D; (Eagle)hAnimal; &#x2F;&#x2F;Error발생, Human 인스턴스를 Eagle로 형변환하려고함</span><br><span class="line">                                        &#x2F;&#x2F;다운캐스팅은 새로운 선언type과 캐스팅type만 비교하므로 경고가 없기때문에 이런 문제가 발생할 수 있음.</span><br><span class="line">        &#x2F;*if (hAnimal instanceof Eagle) &#123;    &#x2F;&#x2F;inatanceof는 인스턴스의 타입을 확인하여 true,false 반환</span><br><span class="line">            Eagle eagle &#x3D; (Eagle)hAnimal;  &#x2F;&#x2F;실행되지 않기 때문에 Error 없음.</span><br><span class="line">            eagle.flying();</span><br><span class="line">        &#125; else if (hAnimal instanceof Human) &#123;</span><br><span class="line">            Human human1 &#x3D; (Human)hAnimal;</span><br><span class="line">            human1.readBooks();</span><br><span class="line">        &#125;*&#x2F;</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;Animal&gt; animalList &#x3D; new ArrayList&lt;Animal&gt;();</span><br><span class="line">        animalList.add(hAnimal);</span><br><span class="line">        animalList.add(tAnimal);</span><br><span class="line">        animalList.add(eAnimal);</span><br><span class="line"></span><br><span class="line">        AnimalTest test &#x3D; new AnimalTest();</span><br><span class="line">        test.testDownCasting(animalList);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void testDownCasting(ArrayList&lt;Animal&gt; list) &#123;</span><br><span class="line">        for(int i&#x3D;0; i&lt;list.size(); i++) &#123;  &#x2F;&#x2F;Animal 인스턴스들의 type을 확인한 후 다운캐스팅하는 for문 </span><br><span class="line">           Animal animal &#x3D; list.get(i);</span><br><span class="line"></span><br><span class="line">           if (animal instanceof Human) &#123;</span><br><span class="line">               Human human &#x3D; (Human)animal;</span><br><span class="line">               human.readBooks();</span><br><span class="line">           &#125; else if (animal instanceof Tiger) &#123;</span><br><span class="line">               Tiger tiger &#x3D; (Tiger)animal;</span><br><span class="line">               tiger.hunting();</span><br><span class="line">           &#125; else if (animal instanceof Eagle) &#123;</span><br><span class="line">               Eagle eagle &#x3D; (Eagle)animal;</span><br><span class="line">               eagle.flying();</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               System.out.println(&quot;Error&quot;);</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void moveAnimal(Animal animal) &#123;</span><br><span class="line">        animal.move();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>보통 오버라이딩으로는 도저히 구현되지 않는 경우에 다운캐스팅 사용    </p>
]]></content>
      <categories>
        <category>Study</category>
        <category>JAVA OOP</category>
      </categories>
  </entry>
  <entry>
    <title>33. 추상 클래스란?</title>
    <url>/2020/08/12/hexo_OOP_33/</url>
    <content><![CDATA[<h1 id="객체-지향-프로그래밍"><a href="#객체-지향-프로그래밍" class="headerlink" title="객체 지향 프로그래밍"></a>객체 지향 프로그래밍</h1><h4 id="33-추상-클래스란"><a href="#33-추상-클래스란" class="headerlink" title="33. 추상 클래스란?"></a>33. 추상 클래스란?</h4><ul>
<li>추상 클래스<br>추상 메서드를 포함한 클래스<br>추상 메서드 : 구현코드 없이 선언부만 있는 메서드<br>abstract 예약어 사용<br>new(인스턴스화) 할 수 없음   </li>
</ul>
<p>추상 클래스는 상속의 상위 클래스로 사용된다.<br>추상 클래스의 추상 메서드는 하위 클래스가 구현해야 한다. </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package abstractex;</span><br><span class="line"></span><br><span class="line">public abstract class Computer &#123; &#x2F;&#x2F;추상 메서드가 있으면 클래스는 항상 추상 클래스이다.</span><br><span class="line"></span><br><span class="line">    public abstract void display(); &#x2F;&#x2F;이 메서드는 구현하지 않겠다는 의미드 (추상 메서드)</span><br><span class="line">    public abstract void typing();  &#x2F;&#x2F;추상 메서드들은 하위 클래스에서 구현된다.</span><br><span class="line"></span><br><span class="line">    public void turnOn() &#123;</span><br><span class="line">        System.out.println(&quot;전원을 켭니다.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void turnOff() &#123;</span><br><span class="line">        System.out.println(&quot;전원을 끕니다.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package abstractex;</span><br><span class="line"></span><br><span class="line">public class Desktop extends Computer &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void display() &#123; &#x2F;&#x2F;상위 클래스의 모든 추상 메서드들을 구현해주지 않으면 에러가 발생한다.</span><br><span class="line">                            &#x2F;&#x2F;만약 구현하지 않거나 부분만 구현해야 할 경우 abstract 클래스가 되어야 한다.</span><br><span class="line">        System.out.println(&quot;Desktop display&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void typing() &#123;</span><br><span class="line">        System.out.println(&quot;Desktop typing&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package abstractex;</span><br><span class="line"></span><br><span class="line">public abstract class Notebook extends Computer&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void typing() &#123;</span><br><span class="line">        System.out.println(&quot;Notebook typing&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package abstractex;</span><br><span class="line"></span><br><span class="line">public class MyNoteBook extends Notebook &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void display() &#123;</span><br><span class="line">        System.out.println(&quot;MyNoteBook display&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package abstractex;</span><br><span class="line"></span><br><span class="line">public class ComputerTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;Computer computer &#x3D; new Computer(); &#x2F;&#x2F;추상 클래스이기 때문에 인스턴스화 불가능</span><br><span class="line">        Computer desktop &#x3D; new Desktop();</span><br><span class="line">        desktop.display();</span><br><span class="line">        desktop.turnOn();</span><br><span class="line"></span><br><span class="line">        Computer mynotebook &#x3D; new MyNoteBook(); &#x2F;&#x2F;NoteBook type이나 MyNoteBook type도 가능</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Study</category>
        <category>JAVA OOP</category>
      </categories>
  </entry>
  <entry>
    <title>34. 추상 클래스 응용, 템플릿 메서드</title>
    <url>/2020/08/12/hexo_OOP_34/</url>
    <content><![CDATA[<h1 id="객체-지향-프로그래밍"><a href="#객체-지향-프로그래밍" class="headerlink" title="객체 지향 프로그래밍"></a>객체 지향 프로그래밍</h1><h4 id="34-추상-클래스-응용-템플릿-메서드"><a href="#34-추상-클래스-응용-템플릿-메서드" class="headerlink" title="34. 추상 클래스 응용: 템플릿 메서드"></a>34. 추상 클래스 응용: 템플릿 메서드</h4><p>템플릿 : 틀이나 견본<br>템플릿 메서드 : 추상 메서드나 구현된 메서드를 활용하여 전체의 흐름을 정의 해 놓은 메서드<br>            final로 선언하여 재정의할 수 없게함<br>템플릿 메서드 패턴 : 디자인 패턴의 일종<br>프레임 워크에서 많이 사용되는 설계 패턴<br>추상 클래스로 선언된 상의 클래스에서 추상 메서드를 이용하여 전체 구현의 흐름을 정의하고<br>구체적인 각 메서드 구현은 하위 클래스에 위임함<br>하위 클래스가 어떤 구현을 하든 템플릿 메서드에 정의된 시나리오 대로 수행됨   </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package template;</span><br><span class="line"></span><br><span class="line">public abstract class Car &#123;</span><br><span class="line"></span><br><span class="line">    public abstract void drive();</span><br><span class="line">    public abstract void stop();</span><br><span class="line"></span><br><span class="line">    public void startCar() &#123;</span><br><span class="line">        System.out.println(&quot;시동을 켭니다.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void turnOff() &#123;</span><br><span class="line">        System.out.println(&quot;시동을 끕니다.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void washCar() &#123;&#125;; &#x2F;&#x2F;훅메서드, 하위 클래스에서 재정의 용으로 생성</span><br><span class="line"></span><br><span class="line">    final public void run() &#123; &#x2F;&#x2F;템플릿 메서드, 재정의 할 수 없도록 final 키워드 사용</span><br><span class="line">                              &#x2F;&#x2F;시나리오가 정의되어있다.</span><br><span class="line">        startCar();</span><br><span class="line">        drive();</span><br><span class="line">        stop();</span><br><span class="line">        turnOff();</span><br><span class="line">        washCar();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package template;</span><br><span class="line"></span><br><span class="line">public class AICar extends Car &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void drive() &#123;</span><br><span class="line">        System.out.println(&quot;자율 주행합니다.&quot;);</span><br><span class="line">        System.out.println(&quot;자동차가 스스로 방향을 바꿉니다.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void stop() &#123;</span><br><span class="line">        System.out.println(&quot;스스로 멈춥니다.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void washCar() &#123; &#x2F;&#x2F;훅메서드 재정의</span><br><span class="line">        System.out.println(&quot;자동 세차 합니다.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package template;</span><br><span class="line"></span><br><span class="line">public class ManualCar extends Car &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void drive() &#123;</span><br><span class="line">        System.out.println(&quot;사람이 운전합니다.&quot;);</span><br><span class="line">        System.out.println(&quot;사람이 핸들을 조작합니다.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void stop() &#123;</span><br><span class="line">        System.out.println(&quot;브레이크를 밟아서 정지합니다.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package template;</span><br><span class="line"></span><br><span class="line">public class CarTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        Car aicar &#x3D; new AICar();</span><br><span class="line">        aicar.run();</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);</span><br><span class="line"></span><br><span class="line">        Car manualcar &#x3D; new ManualCar();</span><br><span class="line">        manualcar.run();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>final 예약어<br>final 변수 : 변경될 수 없는 상수<br>final 메서드 : 하위 클래스에서 재정의 할 수 없음<br>final 클래스 : 더 이상 상속될 수 없음  </li>
</ul>
]]></content>
      <categories>
        <category>Study</category>
        <category>JAVA OOP</category>
      </categories>
  </entry>
  <entry>
    <title>37. 인터페이스</title>
    <url>/2020/08/12/hexo_OOP_37/</url>
    <content><![CDATA[<h1 id="객체-지향-프로그래밍"><a href="#객체-지향-프로그래밍" class="headerlink" title="객체 지향 프로그래밍"></a>객체 지향 프로그래밍</h1><h4 id="37-인터페이스"><a href="#37-인터페이스" class="headerlink" title="37. 인터페이스"></a>37. 인터페이스</h4><ul>
<li><p>인터페이스의 요소<br>추상 메서드 : 인터페이스는 모두 추상 메서드로만 구현되어 있다.<br>상수 : new가 될 수 없기때문에 모든 변수는 상수이다.<br>디폴트 메서드 : 하위 클래스들의 중복 구현 방지.<br>정적 메서드<br>private 메서드     </p>
</li>
<li><p>인터페이스의 선언과 구현</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface Calc &#123;</span><br><span class="line"></span><br><span class="line">int iNum &#x3D; 3; &#x2F;&#x2F;컴파일 과정에서 상수로 변환 </span><br><span class="line"></span><br><span class="line">int add(int num1,int num2); &#x2F;&#x2F;컴파일 과정에서 추상 메서드로 변환 </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package interfaceex;</span><br><span class="line"></span><br><span class="line">public class CalcTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        Calc calc &#x3D; new CompleteCalc();</span><br><span class="line">        int n1 &#x3D;10;</span><br><span class="line">        int n2 &#x3D; 2;</span><br><span class="line"></span><br><span class="line">        System.out.println(calc.add(n1,n2));</span><br><span class="line">        System.out.println(calc.substract(n1,n2));</span><br><span class="line">        System.out.println(calc.times(n1,n2));</span><br><span class="line">        System.out.println(calc.divide(n1,n2));</span><br><span class="line"></span><br><span class="line">        CompleteCalc ccalc &#x3D; (CompleteCalc)calc;</span><br><span class="line">        ccalc.showInfo();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package interfaceex;</span><br><span class="line"></span><br><span class="line">public abstract class Calculator implements Calc&#123; &#x2F;&#x2F;인터페이스는 implements</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int add(int num1, int num2) &#123;</span><br><span class="line">        return num1+num2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int substract(int num1, int num2) &#123;</span><br><span class="line">        return num1-num2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package interfaceex;</span><br><span class="line"></span><br><span class="line">public class CompleteCalc extends Calculator&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public int times(int num1, int num2) &#123;</span><br><span class="line">        return num1*num2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int divide(int num1, int num2) &#123;</span><br><span class="line">        if (num2&#x3D;&#x3D;0) &#123;</span><br><span class="line">            return Error;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return num1 &#x2F; num2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void showInfo() &#123;</span><br><span class="line">        System.out.println(&quot;모두 구현하였습니다.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Study</category>
        <category>JAVA OOP</category>
      </categories>
  </entry>
  <entry>
    <title>38. 인터페이스를 활용한 다형성 구현</title>
    <url>/2020/08/12/hexo_OOP_38/</url>
    <content><![CDATA[<h1 id="객체-지향-프로그래밍"><a href="#객체-지향-프로그래밍" class="headerlink" title="객체 지향 프로그래밍"></a>객체 지향 프로그래밍</h1><h4 id="38-인터페이스를-활용한-다형성-구현"><a href="#38-인터페이스를-활용한-다형성-구현" class="headerlink" title="38. 인터페이스를 활용한 다형성 구현"></a>38. 인터페이스를 활용한 다형성 구현</h4><p>인터페이스의 역할 :<br>클라이언트에 어떤 메서드를 제공하는지 알려주는 명세<br>한 객체가 어떤 인터페이스 타입이라는 것은 그 인터페이스의 메서드를 구현했다는 의미<br>클라이언트 프로그램은 실제 구현내용을 몰라도 인터페이스의 정의만 알면 그 객체를 사용할 수 있다.  </p>
<p>ex) JDBC Lib의 Connect 인터페이스에 대한 실제 구현은 DB사에서하며 개발자는 구현내용을 몰라도 됨.  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package scheduler;</span><br><span class="line"></span><br><span class="line">public interface Scheduler &#123;</span><br><span class="line">    public void getNextCall();</span><br><span class="line">    public void sendCallToAgent();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package scheduler;</span><br><span class="line"></span><br><span class="line">public class RoundRobin implements Scheduler&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void getNextCall() &#123;</span><br><span class="line">        System.out.println(&quot;상담 전화를 순서대로 대기열에서 가져옵니다.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void sendCallToAgent() &#123;</span><br><span class="line">        System.out.println(&quot;다음 순서의 상담원에게 배분합니다.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package scheduler;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">public class SchedulerTest &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;전화 상담원 할당 방식을 선택하세요&quot;);</span><br><span class="line">        System.out.println(&quot;R : 한명씩 차례대로&quot;);</span><br><span class="line">        System.out.println(&quot;L : 대기가 적은 상담원 우선&quot;);</span><br><span class="line">        System.out.println(&quot;P : 우선순위 높은고객 우선 숙련도 높은 상담원&quot;);</span><br><span class="line"></span><br><span class="line">        int ch &#x3D; System.in.read();</span><br><span class="line">        Scheduler scheduler &#x3D; null;</span><br><span class="line">        if (ch &#x3D;&#x3D; &#39;R&#39; || ch &#x3D;&#x3D; &#39;r&#39;) &#123;</span><br><span class="line">            scheduler &#x3D; new RoundRobin();</span><br><span class="line">        &#125; else if (ch &#x3D;&#x3D; &#39;L&#39; || ch &#x3D;&#x3D; &#39;l&#39;) &#123;</span><br><span class="line">            scheduler &#x3D; new LeastJob();</span><br><span class="line">        &#125; else if (ch &#x3D;&#x3D; &#39;P&#39; || ch &#x3D;&#x3D; &#39;p&#39;) &#123;</span><br><span class="line">            scheduler &#x3D; new PriorityAllocation();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;Error&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        scheduler.getNextCall();</span><br><span class="line">        scheduler.sendCallToAgent();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Strategy Pattern<br>인터페이스를 이용하면 다양한 정책이나 알고리즘을 프로그램의 큰 수정 없이 적용, 확장할 수 있다.  </li>
</ul>
]]></content>
      <categories>
        <category>Study</category>
        <category>JAVA OOP</category>
      </categories>
  </entry>
  <entry>
    <title>40. 인터페이스의 요소들</title>
    <url>/2020/08/12/hexo_OOP_40/</url>
    <content><![CDATA[<h1 id="객체-지향-프로그래밍"><a href="#객체-지향-프로그래밍" class="headerlink" title="객체 지향 프로그래밍"></a>객체 지향 프로그래밍</h1><h4 id="40-인터페이스의-요소들"><a href="#40-인터페이스의-요소들" class="headerlink" title="40. 인터페이스의 요소들"></a>40. 인터페이스의 요소들</h4><p>상수 : 선언된 모든 변수는 상수로 처리 됨<br>메서드 : 모든 메서드는 추상 메서드<br>java8<br>디폴트 메서드 : 기본 구현을 가지는 메서드, 클래스에서 재정의 가능<br>정적 메서드 : 인스턴스 생성과 상관없이 인터페이스 타입으로 호출하는 메서드<br>java9<br>private 메서드 : 인터페이스 내에서 사용하기 위한 메서드, 클래스에서 재정의 불가능  </p>
<p>추상 클래스와 다른점은 하나의 클래스에서 여러 인터페이스를 구현할 수 있다.<br>이떄, 디폴트 메서드의 이름이 중복된다면, 재정의 해야한다.   </p>
<p>인터페이스 간에 상속할 수도 있다.(type inheritance) 이때 implements 대신 extends를 사용한다.     </p>
<p>요소들     </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">default void description() &#123; &#x2F;&#x2F;디폴트 메서드</span><br><span class="line">    System.out.println(&quot;정수 계산기를 구현합니다.&quot;);</span><br><span class="line">    myMethod();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int total(int[] arr) &#123; &#x2F;&#x2F;정적 메서드, 인스턴스를 생성하지 않고도 쓸 수 있다.</span><br><span class="line">    int total&#x3D;0;</span><br><span class="line"></span><br><span class="line">    for(int i:arr) &#123;</span><br><span class="line">        total +&#x3D; i;</span><br><span class="line">    &#125;</span><br><span class="line">    myStaticMethod();</span><br><span class="line">    return total;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void myMethod() &#123; &#x2F;&#x2F;일반 private 메서드</span><br><span class="line">    System.out.println(&quot;private method&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void myStaticMethod() &#123; &#x2F;&#x2F;정적 private 메서드</span><br><span class="line">    System.out.println(&quot;private static method&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>동시에 여러 인터페이스 상속, 인터페이스 간의 상속    </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package interfaceex;</span><br><span class="line"></span><br><span class="line">public interface X &#123;</span><br><span class="line">    void x();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package interfaceex;</span><br><span class="line"></span><br><span class="line">public interface Y &#123;</span><br><span class="line">    void y();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package interfaceex;</span><br><span class="line"></span><br><span class="line">public interface MyInterface extends X,Y&#123;</span><br><span class="line">    void myMythod();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package interfaceex;</span><br><span class="line"></span><br><span class="line">public class MyClass implements MyInterface&#123;</span><br><span class="line">    &#x2F;&#x2F; MyClass는 MyInterface 타입이기도 하지만, X 타입이기도 하고 Y 타입이기도 하다.</span><br><span class="line">    @Override</span><br><span class="line">    public void myMythod() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void x() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void y() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>인터페이스 상속과 동시에 클래스 상속    </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package bookshelf;</span><br><span class="line"></span><br><span class="line">public interface Queue &#123;</span><br><span class="line"></span><br><span class="line">    void enQueue(String title);</span><br><span class="line">    String deQueue();</span><br><span class="line"></span><br><span class="line">    int getSize();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package bookshelf;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line"></span><br><span class="line">public class Shelf &#123;</span><br><span class="line"></span><br><span class="line">    protected ArrayList&lt;String&gt; shelf;</span><br><span class="line"></span><br><span class="line">    public Shelf() &#123;</span><br><span class="line">        shelf &#x3D; new ArrayList&lt;String&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public ArrayList&lt;String&gt; getShelf() &#123;</span><br><span class="line">        return shelf;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getCount() &#123;</span><br><span class="line">        return shelf.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package bookshelf;</span><br><span class="line"></span><br><span class="line">public class BookShelf extends Shelf implements Queue&#123; &#x2F;&#x2F;extends 먼저</span><br><span class="line">    @Override</span><br><span class="line">    public void enQueue(String title) &#123;</span><br><span class="line">        shelf.add(title);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String deQueue() &#123;</span><br><span class="line">        return shelf.remove(0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int getSize() &#123;</span><br><span class="line">        return getCount();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package bookshelf;</span><br><span class="line"></span><br><span class="line">public class BookShelfTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        Queue bookQueue &#x3D; new BookShelf(); &#x2F;&#x2F;기능적인것을 우선한다면 보통 인터페이스 타입으로 선언</span><br><span class="line">        bookQueue.enQueue(&quot;태백산맥1&quot;);</span><br><span class="line">        bookQueue.enQueue(&quot;태백산맥2&quot;);</span><br><span class="line">        bookQueue.enQueue(&quot;태백산맥3&quot;);</span><br><span class="line"></span><br><span class="line">        System.out.println(bookQueue.deQueue());</span><br><span class="line">        System.out.println(bookQueue.deQueue());</span><br><span class="line">        System.out.println(bookQueue.deQueue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Study</category>
        <category>JAVA OOP</category>
      </categories>
  </entry>
  <entry>
    <title>43. Object 클래스</title>
    <url>/2020/08/12/hexo_OOP_43/</url>
    <content><![CDATA[<h1 id="객체-지향-프로그래밍"><a href="#객체-지향-프로그래밍" class="headerlink" title="객체 지향 프로그래밍"></a>객체 지향 프로그래밍</h1><h4 id="43-Object-클래스"><a href="#43-Object-클래스" class="headerlink" title="43. Object 클래스"></a>43. Object 클래스</h4><ul>
<li>Object 클래스<br>모든 클래스의 최상위 클래스 (java.lang.Object)<br>(java.lang 패키지 위치 : /Library/Java/JavaVirtualMachines/jdk-11.0.7.jdk/Contents/Home/lib/src.zip<br>, java.lang 패키지는 컴파일러가 자동으로 import 해준다.)<br>모든 클래스는 Object 클래스에서 상속 받음<br>모든 클래스는 Object 클래스의 메서드를 사용할 수 있음<br>모든 클래스는 Object 클래스의 일부 메서드를 재정의하여 사용할 수 있음<br>(final로 정의된 메서드들은 재정의 할 수 없음)   </li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package object;</span><br><span class="line"></span><br><span class="line">class Book&#123;</span><br><span class="line">    String title;</span><br><span class="line">    String author;</span><br><span class="line"></span><br><span class="line">    public Book(String title,String author) &#123;</span><br><span class="line">        this.title &#x3D; title;</span><br><span class="line">        this.author &#x3D; author;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;title&#x3D;&#39;&quot; + title + &#39;\&#39;&#39; + &quot;, author&#x3D;&#39;&quot; + author + &#39;\&#39;&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ToStringTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Book book &#x3D; new Book(&quot;토지&quot;,&quot;박경리&quot;);</span><br><span class="line"></span><br><span class="line">        System.out.println(book); &#x2F;&#x2F;Object의 toString 메서드는 메모리 주소를 리턴한다</span><br><span class="line"></span><br><span class="line">        String str &#x3D; new String(&quot;토지&quot;); &#x2F;&#x2F;String 클래스는 Object로부터 toString 메서드가 재정의되어 있음</span><br><span class="line">        System.out.println(str); &#x2F;&#x2F;실제로는 str.toString()</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>toString() 메서드<br>원형 : </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">getClass().getName()+&#39;@&#39;+Integer.toHexString(hashCode());</span><br></pre></td></tr></table></figure>
<p>객체의 정보를 String으로 바꾸어 사용할 때 유용함<br>자바 클래스 중에는 이미 정의된 클래스가 많다<br>(String,Integer,Calendar,etc…)<br>그 외에 많은 클래서에서 재정의하여 사용한다    </p>
</li>
<li><p>equals() 메서드<br>두 객체의 동일함을 논리적으로 재정의 할 수 있음<br>물리적 동일함 : 같은 메모리 주소<br>논리적 동일함 : 같은 학번의 학생, 같은 주문 번호의 주문<br>논리적으로 동일함을 구현하기 위해 사용   </p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Student studentLee &#x3D; new Student(100,&quot;이상원&quot;);</span><br><span class="line">Student studentSang &#x3D; new Student(100,&quot;이상원&quot;);</span><br></pre></td></tr></table></figure>

<p>studentLee와 studentSang은 물리적으로 동일한 객체가 아니지만 논리적으로는 동일한 객체라고 할 수 있다.<br>논리적 동일함을 구현하기 위하여…    </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class EqualsTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        String str1 &#x3D; new String(&quot;abc&quot;);</span><br><span class="line">        String str2 &#x3D; new String(&quot;abc&quot;);</span><br><span class="line"></span><br><span class="line">        System.out.println(str1&#x3D;&#x3D;str2); &#x2F;&#x2F;false, 메모리 주소가 같은지 확인</span><br><span class="line">        System.out.println(str1.equals(str2)); &#x2F;&#x2F;String에 재정의된 equals()는 두 문자열이 같은지 확인</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>hashCode() 메서드<br>반환 값 : 인스턴스가 저장된 가상머신의 주소를 10진수로 반환<br>두 개의 서로 다른 메모리에 위치한 인스턴스가 동일하다는 것은?<br>논리적으로 동일 : equals()의 반환값이 true<br>&amp;&amp;<br>동일한 hashCode 값을 가짐 : hashCode()의 반환 값이 동일   </li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package object;</span><br><span class="line"></span><br><span class="line">class Student &#123;</span><br><span class="line">    int studentNum;</span><br><span class="line">    String studentName;</span><br><span class="line"></span><br><span class="line">    public Student(int studentNum, String studentName) &#123;</span><br><span class="line">        this.studentNum &#x3D; studentNum;</span><br><span class="line">        this.studentName &#x3D; studentName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean equals(Object object) &#123;</span><br><span class="line">        if (object instanceof Student) &#123;</span><br><span class="line">            Student student &#x3D; (Student)object;</span><br><span class="line">            if (this.studentNum&#x3D;&#x3D;student.studentNum) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int hashCode() &#123;</span><br><span class="line">        return studentNum; &#x2F;&#x2F;equals()에서 사용한 멤버변수를 활</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class EqualsTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        Student Lee &#x3D; new Student(100,&quot;이순신&quot;);</span><br><span class="line">        Student Lee2 &#x3D; Lee;</span><br><span class="line">        Student Shin &#x3D; new Student(100,&quot;이순신&quot;);</span><br><span class="line"></span><br><span class="line">        System.out.println(Lee&#x3D;&#x3D;Lee2); &#x2F;&#x2F;true</span><br><span class="line">        System.out.println(Lee&#x3D;&#x3D;Shin); &#x2F;&#x2F;false</span><br><span class="line">        System.out.println(Lee.equals(Shin)); &#x2F;&#x2F;true</span><br><span class="line"></span><br><span class="line">        System.out.println(Lee.hashCode());  &#x2F;&#x2F;100</span><br><span class="line">        System.out.println(Shin.hashCode()); &#x2F;&#x2F;100</span><br><span class="line"></span><br><span class="line">        Integer i1 &#x3D; new Integer(100);</span><br><span class="line">        Integer i2 &#x3D; new Integer(100);</span><br><span class="line"></span><br><span class="line">        System.out.println(i1.equals(i2)); &#x2F;&#x2F;true, Integer에서 equals()와 hashCode()가 재정의 되어있음</span><br><span class="line">        System.out.println(i1.hashCode());</span><br><span class="line">        System.out.println(i2.hashCode());</span><br><span class="line"></span><br><span class="line">        System.out.println(System.identityHashCode(i1)); &#x2F;&#x2F;실제 메모리 주소 값을 확인하려면</span><br><span class="line">        System.out.println(System.identityHashCode(i2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>clone() 메서드<br>객체의 복사본을 만듦<br>기본 틀으로 부터 같은 속성 값을 가진 객체의 복사본을 생성할 수 있음     </li>
</ul>
<p>객체지향 프로그래밍의 정보은닉에 위배될 가능성이 있으므로 복제할 객체는 cloneable 인터페이스를 명시해야 함     </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package object;</span><br><span class="line"></span><br><span class="line">class Book implements Cloneable&#123; &#x2F;&#x2F;마크인터페이스 Cloneable : 이 클래스는 복제 가능하다는 것을 명시</span><br><span class="line">    String title;</span><br><span class="line">    String author;</span><br><span class="line"></span><br><span class="line">    public Book(String title,String author) &#123;</span><br><span class="line">        this.title &#x3D; title;</span><br><span class="line">        this.author &#x3D; author;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;title&#x3D;&#39;&quot; + title + &#39;\&#39;&#39; + &quot;, author&#x3D;&#39;&quot; + author + &#39;\&#39;&#39;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected Object clone() throws CloneNotSupportedException &#123;</span><br><span class="line">        return super.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ToStringTest &#123;</span><br><span class="line">    public static void main(String[] args) throws CloneNotSupportedException &#123;</span><br><span class="line">        Book book &#x3D; new Book(&quot;토지&quot;,&quot;박경리&quot;);</span><br><span class="line">        System.out.println(book);</span><br><span class="line">        Book book2 &#x3D; (Book)book.clone(); &#x2F;&#x2F;Object로 반환되기 때문에 다운캐스팅</span><br><span class="line">        System.out.println(book2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>finalize() 메서드<br>직접 호출하는 메서드는 아니다.<br>인스턴스가 힙메모리에서 해제될 때 가비지 콜렉터에서 호출되는 메서드<br>주로 리소스 해제 또는 소켓 닫기 등에 사용    </li>
</ul>
]]></content>
      <categories>
        <category>Study</category>
        <category>JAVA OOP</category>
      </categories>
  </entry>
  <entry>
    <title>46. Class 클래스</title>
    <url>/2020/08/12/hexo_OOP_46/</url>
    <content><![CDATA[<h1 id="객체-지향-프로그래밍"><a href="#객체-지향-프로그래밍" class="headerlink" title="객체 지향 프로그래밍"></a>객체 지향 프로그래밍</h1><h4 id="46-Class-클래스"><a href="#46-Class-클래스" class="headerlink" title="46. Class 클래스"></a>46. Class 클래스</h4><ul>
<li>Class 클래스<br>자바의 모든 클래스와 인터페이스는 컴파일 후 class 파일로 생성됨<br>class 파일에는 객체의 정보(멤버변수, 메서드, 생성자 등)가 포함되어 있음<br>Class 클래스는 컴파일된 class 파일에서 객체의 정보를 가져올 수 있음<br>동적 로딩에 많이 사용    </li>
</ul>
<p>Class 클래스 가져오기  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String s &#x3D; new String();</span><br><span class="line">Class c &#x3D; s.getClass();</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Class c &#x3D; String.Class;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Class c &#x3D; Class.forName(&quot;java.lang.String&quot;); &#x2F;&#x2F;동적 로딩 : 컴파일 타임이 아닌 런타임에서 로딩</span><br></pre></td></tr></table></figure>

<ul>
<li>reflection 프로그래밍<br>Class 클래스로부터 객체의 정보를 가져와 프로그래밍하는 방식<br>로컬에 객체가 없고 자료형을 알 수 없는 경우 유용한 프로그래밍<br>java.lang.reflect 패키지에 있는 클래스 활용    </li>
</ul>
<p>String 클래스 정보 확인</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package classex;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.Constructor;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line">public class StringClassTest &#123;</span><br><span class="line">    public static void main(String[] args) throws ClassNotFoundException &#123;</span><br><span class="line"></span><br><span class="line">        Class c1 &#x3D; String.class;</span><br><span class="line"></span><br><span class="line">        String str &#x3D; new String();</span><br><span class="line">        Class c2 &#x3D; str.getClass();</span><br><span class="line"></span><br><span class="line">        Class c3 &#x3D; Class.forName(&quot;java.lang.String&quot;);</span><br><span class="line"></span><br><span class="line">        Constructor[] cons &#x3D; c3.getConstructors();</span><br><span class="line">        for (Constructor con : cons) &#123; &#x2F;&#x2F;String 클래스의 모든 생성자 출력</span><br><span class="line">            System.out.println(con);</span><br><span class="line">        &#125; &#x2F;&#x2F;보통 로컬에 이 클래스가 없을 때 사용</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        Method[] methods &#x3D; c3.getMethods();</span><br><span class="line">        for (Method method : methods) &#123; &#x2F;&#x2F;String 클래스의 모든 메서드 선언부 출력</span><br><span class="line">            System.out.println(method);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Class 클래스를 이용한 사용자 클래스 인스턴스 생성</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package classex;</span><br><span class="line"></span><br><span class="line">public class Person &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line"></span><br><span class="line">    public Person() &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    public Person(String name) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Person(String name, int age) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">        this.age &#x3D; age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAge(int age) &#123;</span><br><span class="line">        this.age &#x3D; age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package classex;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.Constructor;</span><br><span class="line">import java.lang.reflect.InvocationTargetException;</span><br><span class="line"></span><br><span class="line">public class ClassTest &#123;</span><br><span class="line">    public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException &#123;</span><br><span class="line"></span><br><span class="line">        Person person &#x3D; new Person(&quot;james&quot;);</span><br><span class="line">        System.out.println(person);</span><br><span class="line"></span><br><span class="line">        Class c1 &#x3D; Class.forName(&quot;classex.Person&quot;); &#x2F;&#x2F;동적 로딩</span><br><span class="line">        Person person1 &#x3D; (Person)c1.newInstance(); &#x2F;&#x2F;기본생성자 사용하여 인스턴스 생성, 리턴타입이 Object이므로 다운캐스팅</span><br><span class="line">        System.out.println(person1);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;기본생성자가 아닌 다른 생성자를 사용하여 인스턴스를 생성하려는 경우..</span><br><span class="line">        Class[] parameterTypes &#x3D; &#123;String.class&#125;; &#x2F;&#x2F;String을 사용하는 생성자를 사용할 것</span><br><span class="line">        Constructor cons &#x3D; c1.getConstructor(parameterTypes); &#x2F;&#x2F;생성자 매개변수 타입을 요소로 가지는 Class 타입 배열 필요</span><br><span class="line"></span><br><span class="line">        System.out.println(cons.toString()); &#x2F;&#x2F;선택된 생성자 출력</span><br><span class="line"></span><br><span class="line">        Object[] initargs &#x3D; &#123;&quot;김유신&quot;&#125;; &#x2F;&#x2F;생성자의 매개변수로 사용될 값들을 요소로 가지는 배열(여러개일 수 있으므로 배열 사용)</span><br><span class="line">        Person personKim &#x3D; (Person) cons.newInstance(initargs); &#x2F;&#x2F;매개변수 값을 요소로 가지는 Object 타입 배열 필요</span><br><span class="line">        System.out.println(personKim);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>forName() 메서드와 동적 로딩<br>Class 클래스 static 메서드<br>동적 로딩 : 컴파일시 데이터 타입이 모두 biding되어 자료형이 로딩되는 것이 아닌,<br>실행 중에 데이터 타입을 알고 biding 되는 방식<br>실행 시에 로딩되므로 경우에 따라 다른 클래스가 사용될 수 있어 유용함<br>컴파일 타임에 체크할 수 없으므로 해당 문자열에 대한 클래스가 없는 경우 예외 발생  </li>
</ul>
]]></content>
      <categories>
        <category>Study</category>
        <category>JAVA OOP</category>
      </categories>
  </entry>
  <entry>
    <title>48. String, Wrapper 클래스</title>
    <url>/2020/08/12/hexo_OOP_48/</url>
    <content><![CDATA[<h1 id="객체-지향-프로그래밍"><a href="#객체-지향-프로그래밍" class="headerlink" title="객체 지향 프로그래밍"></a>객체 지향 프로그래밍</h1><h4 id="48-String-Wrapper-클래스"><a href="#48-String-Wrapper-클래스" class="headerlink" title="48. String, Wrapper 클래스"></a>48. String, Wrapper 클래스</h4><ul>
<li>String    </li>
</ul>
<p>String 클래스 선언하기</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String str1 &#x3D; new String(&quot;abc&quot;); &#x2F;&#x2F;인스턴스로 생성</span><br><span class="line">String str2 &#x3D; &quot;abc&quot;              &#x2F;&#x2F;상수풀에 있는 문자</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package string;</span><br><span class="line"></span><br><span class="line">public class StringTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        String str1 &#x3D; new String(&quot;abc&quot;); &#x2F;&#x2F;힙메모리 영역</span><br><span class="line">        String str2 &#x3D; &quot;abc&quot;;                     &#x2F;&#x2F;상수 풀</span><br><span class="line">        String str3 &#x3D; &quot;abc&quot;;</span><br><span class="line"></span><br><span class="line">        System.out.println(str1 &#x3D;&#x3D; str2); &#x2F;&#x2F;false, 메모리 위치가 다르기 때문</span><br><span class="line">        System.out.println(str2 &#x3D;&#x3D; str3); &#x2F;&#x2F;true, 둘다 상수풀이기 때문</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>한번 선언되거나 생성된 문자열은 변경할 수 없다.<br>가변적으로 문자열을 사용하려면 StringBuilder 또는 StringBuffer를 사용한다.<br>StringBuilder는 단일 쓰레드 프로그래밍에서,<br>StringBuffer는 멀티 쓰레드 프로그래밍에서 사용된다.  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package string;</span><br><span class="line"></span><br><span class="line">public class StringTest2 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        String java &#x3D; new String(&quot;java&quot;);</span><br><span class="line">        String android &#x3D; new String(&quot;android&quot;);</span><br><span class="line"></span><br><span class="line">        System.out.println(System.identityHashCode(java));</span><br><span class="line">        java &#x3D; java.concat(android);</span><br><span class="line"></span><br><span class="line">        System.out.println(java);</span><br><span class="line">        System.out.println(System.identityHashCode(java)); &#x2F;&#x2F;메모리 주소가 변경됨,즉 새로운 메모리 영역 사용됨</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package string;</span><br><span class="line"></span><br><span class="line">public class StringBuilderTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        String java &#x3D; new String(&quot;java&quot;);</span><br><span class="line">        String android &#x3D; new String(&quot;android&quot;);</span><br><span class="line"></span><br><span class="line">        StringBuilder buffer &#x3D; new StringBuilder(java);</span><br><span class="line">        System.out.println(System.identityHashCode(buffer));</span><br><span class="line">        buffer.append(&quot;android&quot;);</span><br><span class="line">        System.out.println(System.identityHashCode(buffer)); &#x2F;&#x2F;변경되어도 메모리 주소는 변하지 않음</span><br><span class="line"></span><br><span class="line">        java &#x3D; buffer.toString(); &#x2F;&#x2F;String 타입으로 형변환 </span><br><span class="line">        System.out.println(java);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Wrapper 클래스<br>기본 자료형에 대한 클래스<br>Boolean, Integer, 등등    </li>
</ul>
]]></content>
      <categories>
        <category>Study</category>
        <category>JAVA OOP</category>
      </categories>
  </entry>
  <entry>
    <title>49. 제네릭 프로그래밍</title>
    <url>/2020/08/12/hexo_OOP_49/</url>
    <content><![CDATA[<h1 id="객체-지향-프로그래밍"><a href="#객체-지향-프로그래밍" class="headerlink" title="객체 지향 프로그래밍"></a>객체 지향 프로그래밍</h1><h4 id="49-제네릭-프로그래밍"><a href="#49-제네릭-프로그래밍" class="headerlink" title="49. 제네릭 프로그래밍"></a>49. 제네릭 프로그래밍</h4><ul>
<li>제네릭 프로그래밍이란<br>변수의 선언이나 메서드의 매개변수를 하나의 참조 자료형이 아닌 여러 자료형으로 변환될 수 있도록 프로그래밍 하는 방식<br>실제 사용되는 참조 자료형으로의 변환은 컴파일러가 검증하므로 안정적인 프로그래밍 방식이다.  </li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package generic;</span><br><span class="line"></span><br><span class="line">public class GenericPrinter&lt;T extends Meterial&gt; &#123; &#x2F;&#x2F; T : 자료형 매개변</span><br><span class="line">                                                  &#x2F;&#x2F; 클래스가 생성될때 T에 타입을 대입</span><br><span class="line">                                                  &#x2F;&#x2F;Meterial을 상속받은 타입만 들어갈 수 있게 제한</span><br><span class="line"></span><br><span class="line">    private T meterial; &#x2F;&#x2F;재료는 플라스틱,파우더 등 여러가지일 수 있으므로</span><br><span class="line"></span><br><span class="line">    public T getMeterial() &#123; &#x2F;&#x2F;제네릭 타입을 사용하는 메서드 : 제네릭 메서드</span><br><span class="line">        return meterial;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setMeterial(T meterial) &#123;</span><br><span class="line">        this.meterial &#x3D; meterial;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return meterial.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void printing() &#123;</span><br><span class="line">        meterial.doPrinting(); &#x2F;&#x2F;T가 Meterial 클래스로 제한되면서, Meterial 클래스에 정의된 메서드를 공유할 수 있다.</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package generic;</span><br><span class="line"></span><br><span class="line">public abstract class Meterial &#123;</span><br><span class="line"></span><br><span class="line">    public abstract void doPrinting();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package generic;</span><br><span class="line"></span><br><span class="line">public class Plastic extends Meterial&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;재료는 플라스틱입니다.&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void doPrinting() &#123;</span><br><span class="line">        System.out.println(&quot;플라스틱 프린팅합니다.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package generic;</span><br><span class="line"></span><br><span class="line">public class Powder extends Meterial&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;재료는 파우더입니다&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void doPrinting() &#123;</span><br><span class="line">        System.out.println(&quot;파우더 프린팅합니다.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package generic;</span><br><span class="line"></span><br><span class="line">public class GenericPrinterTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        GenericPrinter&lt;Powder&gt; powderPrinter &#x3D; new GenericPrinter&lt;&gt;();</span><br><span class="line">        Powder powder &#x3D; new Powder();</span><br><span class="line">        powderPrinter.setMeterial(powder);</span><br><span class="line">        System.out.println(powderPrinter.toString());</span><br><span class="line"></span><br><span class="line">        GenericPrinter&lt;Plastic&gt; plasticPrinter &#x3D; new GenericPrinter&lt;&gt;();</span><br><span class="line">        Plastic plastic &#x3D; new Plastic();</span><br><span class="line">        plasticPrinter.setMeterial(plastic);</span><br><span class="line">        System.out.println(plasticPrinter.toString());</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;GenericPrinter&lt;Water&gt; waterPrinter; &#x2F;&#x2F;Water는 Meterial 클래스를 상속받지 않았으므로 에러 발생</span><br><span class="line"></span><br><span class="line">        plasticPrinter.printing();</span><br><span class="line">        powderPrinter.printing();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>일반 클래스에서도 제네릭 메서드를 사용할 수 있다.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public &lt;T,V&gt; double makeRectangle(Point&lt;T,V&gt; p1, Point&lt;T,V&gt; p2) &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>제네릭 메서드의 자료형 매개변수&lt;T,V&gt;는 메서드 내에서만 유효하다.(지역변수와 같은 개념)  </p>
]]></content>
      <categories>
        <category>Study</category>
        <category>JAVA OOP</category>
      </categories>
  </entry>
  <entry>
    <title>50. 컬렉션 프레임워크</title>
    <url>/2020/08/12/hexo_OOP_50/</url>
    <content><![CDATA[<h1 id="객체-지향-프로그래밍"><a href="#객체-지향-프로그래밍" class="headerlink" title="객체 지향 프로그래밍"></a>객체 지향 프로그래밍</h1><h4 id="50-컬렉션-프레임워크"><a href="#50-컬렉션-프레임워크" class="headerlink" title="50. 컬렉션 프레임워크"></a>50. 컬렉션 프레임워크</h4><ul>
<li>컬렉션 프레임워크란?<br>프로그램 구현에 필요한 자료구조와 알고리즘을 구현해 놓은 라이브러리<br>java.util 패키지에 구현되어 있음<br>개발에 소요되는 시간을 절약하고 최적화된 라이브러리를 사용할 수 있음<br>Collection 인터페이스와 Map 인터페이스로 구성됨    </li>
</ul>
<p>Collection : 하나의 객체 관리를 위해 선언된 인터페이스<br>+–List : 순서가 있는 자료관리, 중복 허용<br>+–Set : 순서가 정해져있지 않음, 중복을 허용하지 않음  </p>
<p>Map : 쌍으로 이루어진 객체 관리를 위해 선언된 인터페이스<br>Map을 사용하는 객체는 key-value 쌍으로 되어있으며 이중 Key는 중복될 수 없다. </p>
<ul>
<li>List 인터페이스<br>Collection의 하위 인터페이스<br>객체를 순서에따라 저장하고 관리하는데 필요한 메서드가 선언된 인터페이스<br>배열의 기능을 구현하기 위한 메서드가 선언됨<br>ArrayList, Vector, LinkedList</li>
</ul>
<p>ArrayList와 Vector<br>객체 배열 클래스<br>일반적으로 ArrayList를 더 많이 사용<br>Vector는 멀티 쓰레드 프로그램에서 동기화를 제공<br>capacity와 size는 다른 의미   </p>
<p>ArrayList와 LinkedList<br>둘다 자료의 순차적 구조를 구현한 클래스<br>ArrayList는 물리적 순서와 논리적 순서가 동일하다. (검색용)<br>LinkedList는 물리적으로는 순차적이지 않을 수 있다. (변경용)     </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package collection;</span><br><span class="line"></span><br><span class="line">import java.util.LinkedList;</span><br><span class="line"></span><br><span class="line">public class LinkedListTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        LinkedList&lt;String&gt; myList &#x3D; new LinkedList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        myList.add(&quot;A&quot;);</span><br><span class="line">        myList.add(&quot;B&quot;);</span><br><span class="line">        myList.add(&quot;C&quot;);</span><br><span class="line"></span><br><span class="line">        System.out.println(myList);</span><br><span class="line">        myList.add(1,&quot;D&quot;);</span><br><span class="line"></span><br><span class="line">        System.out.println(myList);</span><br><span class="line"></span><br><span class="line">        for(int i&#x3D;0;i&lt;myList.size();i++) &#123;</span><br><span class="line">            String s &#x3D; myList.get(i);  &#x2F;&#x2F;set 인터페이스에는 get메서드가 없다.</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>Stack<br>LIFO<br>이미 구현된 클래스가 제공되고 있음<br>ArrayList, LinkedList로 구현할 수 있음<br>관련 용어 : pop, push, top    </p>
</li>
<li><p>Queue<br>FIFO<br>ArrayList, LinkedList로 구현할 수 있음<br>관련용어 : front, rear, enqueue, dequeue    </p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package collection;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line"></span><br><span class="line">class MyStack &#123;</span><br><span class="line">    private ArrayList&lt;String&gt; arrayStack &#x3D; new ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">    public void push(String data) &#123;</span><br><span class="line">        arrayStack.add(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String pop() &#123;</span><br><span class="line">        int len &#x3D; arrayStack.size();</span><br><span class="line">        if (len &#x3D;&#x3D; 0 ) &#123;</span><br><span class="line">            System.out.println(&quot;Stack이 비어있습니다.&quot;);</span><br><span class="line">            return null;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return arrayStack.remove(len-1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class StackTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        MyStack myStack &#x3D; new MyStack();</span><br><span class="line">        myStack.push(&quot;A&quot;);</span><br><span class="line">        myStack.push(&quot;B&quot;);</span><br><span class="line">        myStack.push(&quot;C&quot;);</span><br><span class="line"></span><br><span class="line">        System.out.println(myStack.pop());</span><br><span class="line">        System.out.println(myStack.pop());</span><br><span class="line">        System.out.println(myStack.pop());</span><br><span class="line">        System.out.println(myStack.pop());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Set 인터페이스<br>Collection 하위의 인터페이스<br>중복을 허용하지 않는다.<br>순서가 없다.<br>get(i) 메서드를 제공하지 않는다.(대신 Iterator 순회)<br>아이디, 주민번호, 사번 등 유일한 값이나 객체를 관리할 때 사용<br>HashSet, TreeSet</li>
</ul>
<p>Iterator로 순회하기<br>Collection의 개체를 순회하는 인터페이스  </p>
<p>iterator() 메서드 호출</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Iterator ir &#x3D; new memberArrayList.iterator();</span><br></pre></td></tr></table></figure>
<p>Iterator에 선언된 메서드<br>hashNext() : 이후에 요소가 더 있는지 체크<br>next : 다음 요소 반환     </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package collection.set;</span><br><span class="line"></span><br><span class="line">import java.util.HashSet;</span><br><span class="line">import java.util.Iterator;</span><br><span class="line"></span><br><span class="line">public class HashSetTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        HashSet&lt;String&gt; set &#x3D; new HashSet&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        set.add(&quot;이순신&quot;);</span><br><span class="line">        set.add(&quot;김유신&quot;);</span><br><span class="line">        set.add(&quot;강감찬&quot;);</span><br><span class="line">        set.add(&quot;이순신&quot;);</span><br><span class="line"></span><br><span class="line">        System.out.println(set); &#x2F;&#x2F;순서가 없음, 중복도 없음</span><br><span class="line"></span><br><span class="line">        Iterator&lt;String&gt; ir &#x3D; set.iterator(); &#x2F;&#x2F;모든 Collection 객체에서 사용가능</span><br><span class="line"></span><br><span class="line">        while(ir.hasNext()) &#123;</span><br><span class="line">            String str &#x3D; ir.next(); &#x2F;&#x2F;순회 선언시 String으로 선언하였기 때문에 반환값은 String이 된다.</span><br><span class="line">            System.out.println(str);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>HashSet</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package collection.set;</span><br><span class="line"></span><br><span class="line">import java.util.HashSet;</span><br><span class="line">import java.util.Iterator;</span><br><span class="line"></span><br><span class="line">public class MemberHashSet &#123;</span><br><span class="line"></span><br><span class="line">    private HashSet&lt;Member&gt; hashSet;</span><br><span class="line"></span><br><span class="line">    public MemberHashSet() &#123;</span><br><span class="line">        hashSet &#x3D; new HashSet&lt;Member&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void addMember(Member member) &#123;</span><br><span class="line">        hashSet.add(member);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean removeMember(int memberId) &#123;</span><br><span class="line"></span><br><span class="line">        Iterator&lt;Member&gt; ir &#x3D; hashSet.iterator();</span><br><span class="line">        while(ir.hasNext()) &#123;</span><br><span class="line">            Member member &#x3D; ir.next();</span><br><span class="line">            if (member.getMemberId() &#x3D;&#x3D; memberId) &#123;</span><br><span class="line">                hashSet.remove(member);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(memberId+&quot;번호가 존재하지 않습니다.&quot;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void showAllMember() &#123;</span><br><span class="line">        for(Member member : hashSet) &#123;</span><br><span class="line">            System.out.println(member);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package collection.set;</span><br><span class="line"></span><br><span class="line">public class MemberHashSetTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        MemberHashSet manager &#x3D; new MemberHashSet();</span><br><span class="line"></span><br><span class="line">        Member memberLee &#x3D; new Member(100,&quot;Lee&quot;);</span><br><span class="line">        Member memberKim &#x3D; new Member(101,&quot;Kim&quot;);</span><br><span class="line">        Member memberPark &#x3D; new Member(102,&quot;Park&quot;);</span><br><span class="line">        Member memberPark2 &#x3D; new Member(102,&quot;Park&quot;);</span><br><span class="line"></span><br><span class="line">        manager.addMember(memberLee);</span><br><span class="line">        manager.addMember(memberKim);</span><br><span class="line">        manager.addMember(memberPark);</span><br><span class="line">        manager.addMember(memberPark2); &#x2F;&#x2F;중복된 데이터이기 때문에 저장되지 않는데,</span><br><span class="line">                                        &#x2F;&#x2F;이는 Member 클래스에서 equals(), hashCode()를 </span><br><span class="line">                                        &#x2F;&#x2F;ID가 같은경우 논리적으로 동일하도록 재정의했기 때문이다.</span><br><span class="line"></span><br><span class="line">        manager.showAllMember();</span><br><span class="line"></span><br><span class="line">        manager.removeMember(100);</span><br><span class="line">        manager.showAllMember();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Member 클래스 중</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public boolean equals(Object obj) &#123;</span><br><span class="line">    if (obj instanceof Member) &#123;</span><br><span class="line">        Member member &#x3D; (Member)obj;</span><br><span class="line">        if (memberId &#x3D;&#x3D; member.memberId) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125; return false;</span><br><span class="line">    &#125; return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public int hashCode() &#123;</span><br><span class="line">    return memberId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>TreeSet<br>객체의 정렬에 사용되는 클래스    </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package collection.set.treeset;</span><br><span class="line"></span><br><span class="line">import java.util.TreeSet;</span><br><span class="line"></span><br><span class="line">public class TreeSetTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        TreeSet&lt;String&gt; treeSet &#x3D; new TreeSet&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        treeSet.add(&quot;홍길동&quot;);</span><br><span class="line">        treeSet.add(&quot;강감찬&quot;);</span><br><span class="line">        treeSet.add(&quot;이순신&quot;);</span><br><span class="line"></span><br><span class="line">        for (String str : treeSet) &#123;</span><br><span class="line">            System.out.println(str); &#x2F;&#x2F;정렬이 되어있음, String 클래스에 Comparable 인터페이스가 구현되어 있음</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>중복을 허용하지 않으면서 오름차순 또는 내림차순으로 객체를 정렬<br>내부적으로 이진 검색 트리로 구현되어 있음<br>트리에 자료가 저장될 때 자료를 비교하게 되는데<br>이때의 객체비교를 위하여 Comparable이나 Comparator 인터페이스를 구현해야 한다.</p>
<p>Member 클래스 중<br>숫자로 비교하는 경우..</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Member implements Comparable&lt;Member&gt;&#123;</span><br><span class="line">...</span><br><span class="line">    @Override</span><br><span class="line">    public int compareTo(Member member) &#123; &#x2F;&#x2F;this와 매개변수를 비교</span><br><span class="line">        return (this.memberId - member.memberId); &#x2F;&#x2F;양수를 반환하게 되면 오름차순 정렬</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>문자열로 비교하는 경우..</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public int compareTo(Member member) &#123; &#x2F;&#x2F;this와 매개변수를 비교</span><br><span class="line">    return this.memberName.compareTo(member.getMemberName()); &#x2F;&#x2F;String은 compareTo가 이미 구현되어 있음   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Comparator 인터페이스를 사용하는 경우…</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public int compare(Member o1, Member o2) &#123; &#x2F;&#x2F;o1이 this, o2가 매개변</span><br><span class="line">    return (o1.memberId-o2.memberId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;TreeSet 생성자에 Comparator가 구현되어 있는 객체를 매개변수로 전달해야 한다.   </span><br><span class="line">public MemberTreeSet() &#123;</span><br><span class="line">    treeSet &#x3D; new TreeSet&lt;Member&gt;(new Member());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>이미 Comparable이 구현되어있는 경우 Comparator를 통해 다른 정렬방식을 정의할 수 있다.  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package collection.set.treeset;</span><br><span class="line"></span><br><span class="line">import java.util.Comparator;</span><br><span class="line">import java.util.TreeSet;</span><br><span class="line"></span><br><span class="line">class MyCompare implements Comparator&lt;String&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public int compare(String o1, String o2) &#123;</span><br><span class="line">        return o1.compareTo(o2)*(-1); &#x2F;&#x2F;문자열 역순정렬</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class TreeSetTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        TreeSet&lt;String&gt; treeSet &#x3D; new TreeSet&lt;String&gt;(new MyCompare()); &#x2F;&#x2F;String 클래스에서 구현된 정렬 방식을 무시하고</span><br><span class="line">                                                                        &#x2F;&#x2F;내가 구현한 정렬 방식을 사용할 수 있다.</span><br><span class="line"></span><br><span class="line">        treeSet.add(&quot;홍길동&quot;);</span><br><span class="line">        treeSet.add(&quot;강감찬&quot;);</span><br><span class="line">        treeSet.add(&quot;이순신&quot;);</span><br><span class="line"></span><br><span class="line">        for (String str : treeSet) &#123;</span><br><span class="line">            System.out.println(str); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Study</category>
        <category>JAVA OOP</category>
      </categories>
  </entry>
  <entry>
    <title>55. Map 인터페이스</title>
    <url>/2020/08/12/hexo_OOP_55/</url>
    <content><![CDATA[<h1 id="객체-지향-프로그래밍"><a href="#객체-지향-프로그래밍" class="headerlink" title="객체 지향 프로그래밍"></a>객체 지향 프로그래밍</h1><h4 id="55-Map-인터페이스"><a href="#55-Map-인터페이스" class="headerlink" title="55. Map 인터페이스"></a>55. Map 인터페이스</h4><ul>
<li>Map 인터페이스<br>쌍으로 이루어진 객체 관리를 위해 선언된 인터페이스<br>검색을 위한 자료구조<br>Map을 사용하는 객체는 key-value 쌍으로 되어있으며 Key는 중복될 수 없다.<br>Key를 이용하여 값을 저장하거나 검색, 삭제할 때 사용하면 편리하다.<br>내부적으로 hash 방식으로 구현되어 있다.    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">index &#x3D; hash(key) &#x2F;&#x2F;index는 저장 위치</span><br></pre></td></tr></table></figure>
key가 되는 객체는 객체의 유일성 여부를 알기 위해 equals(), hashCode() 메서드를 재정의한다.  </li>
</ul>
<p>HashMap 클래스<br>Map 인터페이스를 구현한 클래스 중에서 가장 일반적으로 쓰인다.<br>pair 자료를 쉽고 빠르게 관리할 수 있다.<br>HashTable 클래스는 Vector 처럼 동기화를 제공한다.     </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package collection.hashmap;</span><br><span class="line"></span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Iterator;</span><br><span class="line"></span><br><span class="line">public class MemberHashMap &#123;</span><br><span class="line"></span><br><span class="line">    private HashMap&lt;Integer,Member&gt; hashMap;</span><br><span class="line"></span><br><span class="line">    public MemberHashMap() &#123;</span><br><span class="line">        hashMap &#x3D; new HashMap&lt;Integer, Member&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void addMember(Member member) &#123;</span><br><span class="line">        hashMap.put(member.getMemberId(),member); &#x2F;&#x2F;add가 아닌 put임에 유의, key-value pair가 들어간다.</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean removeMember(int memberId) &#123; &#x2F;&#x2F;key 값을 통해 제거</span><br><span class="line">        if (hashMap.containsKey(memberId)) &#123; &#x2F;&#x2F;containsKey : 해당 key값의 요소가 있는지 체크</span><br><span class="line">            hashMap.remove(memberId); &#x2F;&#x2F;key값으로 제거</span><br><span class="line">            return true;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;회원 번호가 없습니다.&quot;);</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void showAllMember() &#123;</span><br><span class="line">        &#x2F;&#x2F;hashMap.keySet().iterator(); &#x2F;&#x2F;keySey() : 모든 key 객체를 set으로 반환</span><br><span class="line">        &#x2F;&#x2F;hashMap.values().iterator(); &#x2F;&#x2F;values() : 모든 value 객체를 Collection으로 반환</span><br><span class="line"></span><br><span class="line">        Iterator&lt;Integer&gt; ir &#x3D; hashMap.keySet().iterator();</span><br><span class="line">        while (ir.hasNext()) &#123;</span><br><span class="line">            int key &#x3D; ir.next();</span><br><span class="line">            Member member &#x3D; hashMap.get(key); &#x2F;&#x2F;get(key) 해당 key의 value 반환</span><br><span class="line">            System.out.println(member);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package collection.hashmap;</span><br><span class="line"></span><br><span class="line">public class MemberHashMapTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        MemberHashMap manager &#x3D; new MemberHashMap();</span><br><span class="line"></span><br><span class="line">        Member memberLee &#x3D; new Member(100,&quot;Lee&quot;);</span><br><span class="line">        Member memberKim &#x3D; new Member(101,&quot;Kim&quot;);</span><br><span class="line">        Member memberPark &#x3D; new Member(102,&quot;Park&quot;);</span><br><span class="line">        Member memberPark2 &#x3D; new Member(102,&quot;Park&quot;);</span><br><span class="line"></span><br><span class="line">        manager.addMember(memberLee);</span><br><span class="line">        manager.addMember(memberKim);</span><br><span class="line">        manager.addMember(memberPark);</span><br><span class="line">        manager.addMember(memberPark2); &#x2F;&#x2F;key type인 Integer에 이미 equals()와 hashCode()가 재정의 되어있다.</span><br><span class="line">                                        &#x2F;&#x2F;그렇기 때문에 따로 재정의해주지 않아도 안들어간다.</span><br><span class="line"></span><br><span class="line">        manager.showAllMember();</span><br><span class="line"></span><br><span class="line">        manager.removeMember(101);</span><br><span class="line">        manager.showAllMember();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>TreeMap 클래스<br>key 객체를 정렬하여 key-value를 pair로 관리하는 클래스<br>정렬을 위하여 key에 사용되는 클래스에 Comparable 또는 Comparator 인터페이스를 구현   </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package collection.treemap;</span><br><span class="line"></span><br><span class="line">import java.util.Iterator;</span><br><span class="line">import java.util.TreeMap;</span><br><span class="line"></span><br><span class="line">public class MemberTreeMap &#123;</span><br><span class="line"></span><br><span class="line">    TreeMap&lt;Integer,Member&gt; treeMap;</span><br><span class="line"></span><br><span class="line">    public MemberTreeMap() &#123;</span><br><span class="line">        treeMap &#x3D; new TreeMap&lt;Integer, Member&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void addMember(Member member) &#123;</span><br><span class="line">        treeMap.put(member.getMemberId(),member);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean removeMember(int memberId) &#123;</span><br><span class="line">        if (treeMap.containsKey(memberId)) &#123;</span><br><span class="line">            treeMap.remove(memberId);</span><br><span class="line">            return true;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;회원 번호가 없습니다.&quot;);</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void showAllMember() &#123;</span><br><span class="line">        Iterator&lt;Integer&gt; ir &#x3D; treeMap.keySet().iterator();</span><br><span class="line">        while (ir.hasNext()) &#123;</span><br><span class="line">            int key &#x3D; ir.next();</span><br><span class="line">            Member member &#x3D; treeMap.get(key);</span><br><span class="line">            System.out.println(member);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package collection.treemap;</span><br><span class="line"></span><br><span class="line">public class MemberTreeMapTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        MemberTreeMap manager &#x3D; new MemberTreeMap();</span><br><span class="line"></span><br><span class="line">        Member memberLee &#x3D; new Member(200,&quot;Lee&quot;);</span><br><span class="line">        Member memberKim &#x3D; new Member(400,&quot;Kim&quot;);</span><br><span class="line">        Member memberPark &#x3D; new Member(100,&quot;Park&quot;);</span><br><span class="line"></span><br><span class="line">        manager.addMember(memberLee);</span><br><span class="line">        manager.addMember(memberKim);</span><br><span class="line">        manager.addMember(memberPark);</span><br><span class="line"></span><br><span class="line">        manager.showAllMember(); &#x2F;&#x2F;Integer 클래스에서 Comparable가 구현되어 있으므로</span><br><span class="line">                                 &#x2F;&#x2F;따로 구현하지 않더라도 정렬되어있다.</span><br><span class="line"></span><br><span class="line">        manager.removeMember(200);</span><br><span class="line">        manager.showAllMember();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Study</category>
        <category>JAVA OOP</category>
      </categories>
  </entry>
  <entry>
    <title>56. 내부 클래스</title>
    <url>/2020/08/12/hexo_OOP_56/</url>
    <content><![CDATA[<h1 id="객체-지향-프로그래밍"><a href="#객체-지향-프로그래밍" class="headerlink" title="객체 지향 프로그래밍"></a>객체 지향 프로그래밍</h1><h4 id="56-내부-클래스"><a href="#56-내부-클래스" class="headerlink" title="56. 내부 클래스"></a>56. 내부 클래스</h4><ul>
<li>내부 클래스란<br>클래스 내부에 구현된 클래스 (중첩된 클래스)<br>클래스 내부에서 사용하기 위해 선언하고 구현하는 클래스<br>주로 외부 클래스 생성자에서 내부 클래스를 생성   </li>
</ul>
<p>인스턴스 내부 클래스, 정적 내부 클래스   </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package innerclass;</span><br><span class="line"></span><br><span class="line">class Outer &#123;</span><br><span class="line"></span><br><span class="line">    int outNum &#x3D; 100;</span><br><span class="line">    static int sNum &#x3D;200;</span><br><span class="line"></span><br><span class="line">    Runnable getRunnable(int i) &#123; &#x2F;&#x2F;Runnable 한 type의 객체를 반환하는 메서드</span><br><span class="line"></span><br><span class="line">        int num &#x3D; 100; &#x2F;&#x2F;지역변수 i, num</span><br><span class="line">        class MyRunnable implements Runnable &#123; &#x2F;&#x2F;지역 내부 클래스, 메서드 내에 구현되어 있음</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                &#x2F;&#x2F;num +&#x3D; 10; 메서드의 지역변수 변경할 수 없음.</span><br><span class="line">                &#x2F;&#x2F; i &#x3D; 200;  지역 내부 클래스를 포함하는 메서드의 지역변수는 내부적으로 final이 된다..</span><br><span class="line"></span><br><span class="line">                System.out.println(num);</span><br><span class="line">                System.out.println(i);</span><br><span class="line">                System.out.println(outNum);</span><br><span class="line">                System.out.println(sNum);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return new MyRunnable();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class LocalInnerClassTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Outer outer &#x3D; new Outer();</span><br><span class="line">        Runnable runnable &#x3D; outer.getRunnable(30);</span><br><span class="line"></span><br><span class="line">        runnable.run(); &#x2F;&#x2F;getRunnable 메서드는 이미 종료되어 지역변수는 없어져있다.</span><br><span class="line">                        &#x2F;&#x2F;지역 내부 클래스의 메서드(run)은 언제든지 호출될 수 있다.</span><br><span class="line">                        &#x2F;&#x2F;그렇기 때문에 지역 내부 클래스를 포함하는 메서드의 지역변수는 상수(final)가 된다.</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>지역 내부 클래스   </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package innerclass;</span><br><span class="line"></span><br><span class="line">class Outer &#123;</span><br><span class="line"></span><br><span class="line">    int outNum &#x3D; 100;</span><br><span class="line">    static int sNum &#x3D;200;</span><br><span class="line"></span><br><span class="line">    Runnable getRunnable(int i) &#123; &#x2F;&#x2F;Runnable 한 type의 객체를 반환하는 메서드</span><br><span class="line"></span><br><span class="line">        int num &#x3D; 100; &#x2F;&#x2F;지역변수 i, num</span><br><span class="line">        class MyRunnable implements Runnable &#123; &#x2F;&#x2F;지역 내부 클래스, 메서드 내에 구현되어 있음</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                &#x2F;&#x2F;num +&#x3D; 10; 메서드의 지역변수 변경할 수 없음.</span><br><span class="line">                &#x2F;&#x2F; i &#x3D; 200;  지역 내부 클래스를 포함하는 메서드의 지역변수는 내부적으로 final이 된다..</span><br><span class="line"></span><br><span class="line">                System.out.println(num);</span><br><span class="line">                System.out.println(i);</span><br><span class="line">                System.out.println(outNum);</span><br><span class="line">                System.out.println(sNum);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return new MyRunnable();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class LocalInnerClassTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Outer outer &#x3D; new Outer();</span><br><span class="line">        Runnable runnable &#x3D; outer.getRunnable(30);</span><br><span class="line"></span><br><span class="line">        runnable.run(); &#x2F;&#x2F;getRunnable 메서드는 이미 종료되어 지역변수는 없어져있다.</span><br><span class="line">                        &#x2F;&#x2F;지역 내부 클래스의 메서드(run)은 언제든지 호출될 수 있다.</span><br><span class="line">                        &#x2F;&#x2F;그렇기 때문에 지역 내부 클래스를 포함하는 메서드의 지역변수는 상수(final)가 된다.</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>익명 내부 클래스(가장 많이 사용)   </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package innerclass;</span><br><span class="line"></span><br><span class="line">class Outer2 &#123;</span><br><span class="line"></span><br><span class="line">    int outNum &#x3D; 100;</span><br><span class="line">    static int sNum &#x3D;200;</span><br><span class="line"></span><br><span class="line">    Runnable getRunnable(int i) &#123; &#x2F;&#x2F;Runnable 한 type의 객체를 반환하는 메서드</span><br><span class="line"></span><br><span class="line">        int num &#x3D; 100; &#x2F;&#x2F;지역변수 i, num</span><br><span class="line">        return new Runnable() &#123; &#x2F;&#x2F;익명 내부 클래스, 메서드 내부</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                &#x2F;&#x2F;num +&#x3D; 10; 메서드의 지역변수 변경할 수 없음.</span><br><span class="line">                &#x2F;&#x2F; i &#x3D; 200;  지역 내부 클래스를 포함하는 메서드의 지역변수는 내부적으로 final이 된다..</span><br><span class="line"></span><br><span class="line">                System.out.println(num);</span><br><span class="line">                System.out.println(i);</span><br><span class="line">                System.out.println(outNum);</span><br><span class="line">                System.out.println(sNum);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;; &#x2F;&#x2F;익명 내부 클래스 구현 끝 세미콜론</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Runnable runner &#x3D; new Runnable() &#123;  &#x2F;&#x2F;익명 내부 클래스2, 메서드 외부</span><br><span class="line">                                        &#x2F;&#x2F;하나의 인터페이스나 추상클래스에 대해서 상속 또는 구현하는 별개의 클래스를 생성하지 않아도 </span><br><span class="line">                                        &#x2F;&#x2F;바로 이름 없이 생성할 수 있다.</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            System.out.println(&quot;test&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class AnonymousInnerClassTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Outer2 outer &#x3D; new Outer2();</span><br><span class="line">        Runnable runnable &#x3D; outer.getRunnable(30);</span><br><span class="line"></span><br><span class="line">        runnable.run(); </span><br><span class="line">        outer.runner.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Study</category>
        <category>JAVA OOP</category>
      </categories>
  </entry>
  <entry>
    <title>58. 람다식</title>
    <url>/2020/08/12/hexo_OOP_58/</url>
    <content><![CDATA[<h1 id="객체-지향-프로그래밍"><a href="#객체-지향-프로그래밍" class="headerlink" title="객체 지향 프로그래밍"></a>객체 지향 프로그래밍</h1><h4 id="58-람다식"><a href="#58-람다식" class="headerlink" title="58. 람다식"></a>58. 람다식</h4><ul>
<li><p>람다식이란? (java 8 or newer)<br>자바에서 함수형 프로그래밍을 구현하는 방식<br>클래스를 생성하지 않고 함수의 호출만으로 기능 수행 (내부적으로 익명 객체 사용)<br>함수형 인터페이스 선언    </p>
</li>
<li><p>함수형 프로그래밍이란?<br>순수 함수를 구현하고 호출<br>매개변수만 사용하기 때문에 외부에 사이드 이펙트를 주지 않고 병렬 처리 가능<br>안정적인 확장성있는 프로그래밍 방식    </p>
</li>
</ul>
<p>문법</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">InterFace itfc &#x3D; str -&gt; &#123;System.out.println(str);&#125;;</span><br><span class="line">InterFace2 itfc2 &#x3D; (x,y) -&gt; x+y &#x2F;&#x2F;구현부가 return 문 하나라면 return, 중괄호 생략 가능</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package lambda;</span><br><span class="line"></span><br><span class="line">public class TestStringConcat &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        StringConImpl impl &#x3D; new StringConImpl(); &#x2F;&#x2F;객체지향에서는 인터페이스를 구현한 클래스를 사용</span><br><span class="line">        impl.makeString(&quot;hello&quot;,&quot;world&quot;);</span><br><span class="line"></span><br><span class="line">        StringConcat concat &#x3D; (s,v) -&gt; System.out.println(s+&quot; &quot;+v); &#x2F;&#x2F;함수형 프로그래밍, 람다식 사용</span><br><span class="line">        concat.makeString(&quot;hello&quot;,&quot;world&quot;); &#x2F;&#x2F;클래스 구현이 필요없고, 메서드 구현을 따로 만들 필요도 없음.</span><br><span class="line">                                            &#x2F;&#x2F;실제로는 아래처럼 익명 내부클래스로 동작한다.</span><br><span class="line"></span><br><span class="line">        StringConcat concat2 &#x3D; new StringConcat() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void makeString(String str1, String str2) &#123;</span><br><span class="line">                System.out.println(str1+&quot; &quot;+str2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        concat2.makeString(&quot;hello&quot;,&quot;world&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>람다식은 프로그램내에서 변수처럼 사용할 수 있다.     </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package lambda;</span><br><span class="line"></span><br><span class="line">interface PrintString&#123;</span><br><span class="line">    void showString(String str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class TestLambda &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        PrintString lambdaStr &#x3D; str -&gt; System.out.println(str); &#x2F;&#x2F;함수의 구현부가 변수로 대입</span><br><span class="line">        lambdaStr.showString(&quot;Test1&quot;);</span><br><span class="line"></span><br><span class="line">        showMyString(lambdaStr); &#x2F;&#x2F;매개변수로 활용</span><br><span class="line">        PrintString lambdaStr2 &#x3D; returnString(); &#x2F;&#x2F;반환된 구현부를 변수에 대입</span><br><span class="line">        lambdaStr2.showString(&quot;Test3&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void showMyString(PrintString p) &#123;</span><br><span class="line">        p.showString(&quot;Test2&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static PrintString returnString() &#123;</span><br><span class="line">        return str-&gt;System.out.println(str+&quot;!!!&quot;); &#x2F;&#x2F;함수의 구현부를 반환</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Study</category>
        <category>JAVA OOP</category>
      </categories>
  </entry>
  <entry>
    <title>60. 스트림</title>
    <url>/2020/08/12/hexo_OOP_60/</url>
    <content><![CDATA[<h1 id="객체-지향-프로그래밍"><a href="#객체-지향-프로그래밍" class="headerlink" title="객체 지향 프로그래밍"></a>객체 지향 프로그래밍</h1><h4 id="60-스트림"><a href="#60-스트림" class="headerlink" title="60. 스트림"></a>60. 스트림</h4><p>자료의 대상과 관계없이 동일한 연산을 수행할 수 있는 기능(자료의 추상화)<br>배열, 컬렉션에 동일한 연산이 수행되어 일관성 있는 처리 가능<br>한번 생성하고 사용한 스트림은 재사용할 수 없음<br>스트림 연산은 기존 자료를 변경하지 않음<br>중간 연산과 최종 연산으로 구분 됨<br>최종 연산이 수행되어야 모든 연산이 적용되는 지연 연산  </p>
<ul>
<li><p>중간 연산<br>filter(), map()<br>조건에 맞는 요소를 추출하거나 요소를 변환 함<br>문자열의 길이가 5이상인 요소만 출력하기  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sList.stream().filter(s-&gt;s.length()&gt;&#x3D;5).forEach(s-&gt;System.out.println(s));</span><br></pre></td></tr></table></figure>
<p>고객 클래스에서 고객 이름만 가져오기    </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">customerList.stream().map(c-&gt;c.getName()).forEach(s-&gt;System.out.println(s));</span><br></pre></td></tr></table></figure>
</li>
<li><p>최종 연산<br>스트림의 자료를 소모하면서 연산을 수행<br>최종 연산 후에 스트림은 더이상 다른 연산을 적용할 수 없음<br>forEach() : 요소를 하나씩 꺼내 옴<br>count() : 요소의 개수<br>sum() : 요소의 합<br>등 여러 가지 최종 연산이 있음   </p>
</li>
</ul>
<p>배열 스트림</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package stream;</span><br><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">public class IntArrayTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        int[] arr &#x3D; &#123;1,2,3,4,5&#125;;</span><br><span class="line"></span><br><span class="line">        int sum &#x3D; Arrays.stream(arr).sum();</span><br><span class="line">        int count &#x3D; (int)Arrays.stream(arr).count(); &#x2F;&#x2F;썼으니 재생성, long이므로 형변환</span><br><span class="line"></span><br><span class="line">        System.out.println(sum);</span><br><span class="line">        System.out.println(count);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>콜렉션 스트림</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package stream;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line">public class ArrayListStreamTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; sList &#x3D; new ArrayList&lt;String&gt;();</span><br><span class="line">        sList.add(&quot;Tomas&quot;);</span><br><span class="line">        sList.add(&quot;Edward&quot;);</span><br><span class="line">        sList.add(&quot;Jack&quot;);</span><br><span class="line"></span><br><span class="line">        Stream&lt;String&gt; stream &#x3D; sList.stream(); &#x2F;&#x2F;stream 객체 생성</span><br><span class="line">        stream.forEach(s -&gt; System.out.print(s + &quot; &quot;));</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        sList.stream().sorted().forEach(s -&gt; System.out.print(s + &quot; &quot;)); &#x2F;&#x2F;sorted 중간 연산 추가</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        sList.stream().map(s -&gt; s.length()).forEach(n -&gt; System.out.print(n + &quot; &quot;)); &#x2F;&#x2F;map(변환) 중간 연산 추가</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>reduce() 연산<br>정의된 연산이 아닌 프로그래머가 직접 지정하는 연산을 적용<br>최종 연산으로 스트림의 요소를 소모하며 연산 수행     </li>
</ul>
<p>배열의 모든 요소의 합을 구하는 reduce() 연산   </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Arrays.stream(arr).reduce(0,(a,b)-&gt;a+b));</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package stream;</span><br><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.function.BinaryOperator;</span><br><span class="line"></span><br><span class="line">class CompareString implements BinaryOperator&lt;String&gt; &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String apply(String s1, String s2) &#123;</span><br><span class="line">        if(s1.getBytes().length &gt;&#x3D; s2.getBytes().length) &#123;</span><br><span class="line">            return s1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return s2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class ReduceTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        String[] greetings &#x3D; &#123;&quot;안녕하세요&quot;,&quot;hello&quot;,&quot;Good Morning&quot;,&quot;반갑습니다&quot;&#125;;</span><br><span class="line"></span><br><span class="line">        System.out.println(Arrays.stream(greetings).reduce(&quot;&quot;,(s1,s2) -&gt; &#123;</span><br><span class="line">            if(s1.getBytes().length &gt;&#x3D; s2.getBytes().length) &#123;</span><br><span class="line">                return s1;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return s2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;));</span><br><span class="line">        &#x2F;&#x2F;람다식 대신 BinaryOperator가 구현된 클래스를 사용</span><br><span class="line">        System.out.println(Arrays.stream(greetings).reduce(new CompareString()).get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Study</category>
        <category>JAVA OOP</category>
      </categories>
  </entry>
  <entry>
    <title>63. 예외와 예외 처리</title>
    <url>/2020/08/12/hexo_OOP_63/</url>
    <content><![CDATA[<h1 id="객체-지향-프로그래밍"><a href="#객체-지향-프로그래밍" class="headerlink" title="객체 지향 프로그래밍"></a>객체 지향 프로그래밍</h1><h4 id="63-예외와-예외-처리"><a href="#63-예외와-예외-처리" class="headerlink" title="63. 예외와 예외 처리"></a>63. 예외와 예외 처리</h4><p>컴파일 오류 : 프로그램 코드 작성 중 발생하는 문법적 오류<br>실행 오류 : 실행중인 프로그램이 의도치 않은 동작을 하거나(bug) 프로그램이 중단되는 오류(runtime error)<br>자바는 예외 처리를 통하여 프로그램의 비정상 종료를 막고 log를 남길 수 있음    </p>
<p>시스템 오류(error) : 가상 머신에서 발생, 프로그래머가 처리할 수 없음<br>동적 메모리를 다 사용한 경우, stack over flow 등<br>예외(Exception) : 프로그램에서 제어할 수 있는 오류<br>읽으려는 파일이 없는 경우, 네트웍이나 소켓 연결 오류 등<br>자바 프로그램에서는 예외에 대한 처리를 수행 함</p>
<p>Exception 클레스 : 모든 예외 클래스의 최상위 클래스<br>IOException, RuntimeException 등     </p>
<p>try~catch 문으로 예외처리하기<br>try {<br>예외가 발생할 수 있는 동작<br>} catch(처리할 예외 타입 e) {<br>try블록 안에서 예외가 발생했을 때 수행되는 부분<br>}  </p>
<p>try {<br>예외가 발생할 수 있는 동작<br>} catch(처리할 예외 타입 e) {<br>try블록 안에서 예외가 발생했을 때 수행되는 부분<br>} finally {<br>예외 발생 여부와 상관 없이 항상 수행되는 부분<br>리소스를 정리하는 코드를 주로 쓴다<br>}  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package exception;</span><br><span class="line"></span><br><span class="line">public class ArrayExceptionTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        int[] arr &#x3D; new int[5];</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            for (int i &#x3D; 0; i &lt;&#x3D; 5; i++) &#123;</span><br><span class="line">                System.out.println(arr[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;catch(ArrayIndexOutOfBoundsException e) &#123; &#x2F;&#x2F;IDE가 잡아주지 않으므로 직접 써야함</span><br><span class="line">            System.out.println(e);</span><br><span class="line">            System.out.println(&quot;예외 처리&quot;);</span><br><span class="line">        &#125; &#x2F;&#x2F;예외만 처리되고 프로그램은 계속 수행됨</span><br><span class="line">        System.out.println(&quot;프로그램 종료&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>finally<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package exception;</span><br><span class="line"></span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileNotFoundException;</span><br><span class="line"></span><br><span class="line">public class ExceptionTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        FileInputStream fis &#x3D; null;</span><br><span class="line">        System.out.println(new File(&quot;&quot;).getAbsolutePath()); &#x2F;&#x2F;working directory 확인</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            fis &#x3D; new FileInputStream(&quot;IdeaProjects&#x2F;Chapter13&#x2F;a.txt&quot;);</span><br><span class="line">        &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">            &#x2F;&#x2F;return;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                fis.close(); &#x2F;&#x2F;stream을 close하는 작업을 진행해야되므로</span><br><span class="line">                System.out.println(&quot;finally&quot;);</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                System.out.println(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;end&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>try<del>with</del>resources 문 (java 7)<br>리소스를 자동으로 해제하도록 제공해주는 구문<br>해당 리소스가 AutoCloseable(인터페이스)을 구현한 경우 close()를 명시적으로 호출하지 않아도<br>try{}블록에서 오픈된 리소스는 정상적인 경우나 예외가 발생한 경우 모두 자동으로 close()가 호출 됨    </p>
<p>FileInputStream의 경우 AutoCloseable이 구현되어 있음  </p>
<p>AutoCloseable를 구현한 클래스 생성</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package exception;</span><br><span class="line"></span><br><span class="line">public class AutoCloseObject implements AutoCloseable&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void close() throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;close()가 호출되었습니다.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>해당 클래스 예외 처리</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package exception;</span><br><span class="line"></span><br><span class="line">public class AutoCloseTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        try(AutoCloseObject obj &#x3D; new AutoCloseObject()) &#123;</span><br><span class="line">            throw new Exception(); &#x2F;&#x2F;exception 강제 발생</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125; &#x2F;&#x2F;close() 를 명시적으로 호출하지 않지만 내부적으로는 호출 됨</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>향상된 try-with-resources 문 (java 9)   </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package exception;</span><br><span class="line"></span><br><span class="line">public class AutoCloseTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        AutoCloseObject obj &#x3D; new AutoCloseObject();</span><br><span class="line">        </span><br><span class="line">        try(obj) &#123; &#x2F;&#x2F;선언할 필요 없이 미리 생성된 객체 사용가능 </span><br><span class="line">            throw new Exception();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Study</category>
        <category>JAVA OOP</category>
      </categories>
  </entry>
  <entry>
    <title>65. 다양한 예외 처리</title>
    <url>/2020/08/12/hexo_OOP_65/</url>
    <content><![CDATA[<h1 id="객체-지향-프로그래밍"><a href="#객체-지향-프로그래밍" class="headerlink" title="객체 지향 프로그래밍"></a>객체 지향 프로그래밍</h1><h4 id="65-다양한-예외-처리"><a href="#65-다양한-예외-처리" class="headerlink" title="65. 다양한 예외 처리"></a>65. 다양한 예외 처리</h4><ul>
<li>예외 처리 미루기<br>throws를 이용하여 예외처리 미루기<br>try{} 블록으로 예외처리 하지 않고, 메서드 선언부에 throws를 추가<br>예외가 발생한 메서드에서 예외처리를 하지 않고 메서드를 호출한 곳에서 예외처리함<br>main()에서 throws를 사용하면 가상 머신에서 처리 됨  </li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package exception;</span><br><span class="line"></span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileNotFoundException;</span><br><span class="line"></span><br><span class="line">public class ThrowsException &#123;</span><br><span class="line"></span><br><span class="line">    public Class loadClass(String fileName, String className) throws FileNotFoundException, ClassNotFoundException &#123; &#x2F;&#x2F;throws로 미루기</span><br><span class="line"></span><br><span class="line">        FileInputStream fis &#x3D; new FileInputStream(fileName);</span><br><span class="line">        Class c &#x3D; Class.forName(className);</span><br><span class="line">        return c;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        ThrowsException test &#x3D; new ThrowsException();</span><br><span class="line">        try &#123;</span><br><span class="line">            test.loadClass(&quot;IdeaProjects&#x2F;Chapter13&#x2F;a.txt&quot;,&quot;java.lang.String&quot;); &#x2F;&#x2F;loadClass에 대한 try~catch문 필요</span><br><span class="line">        &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;end&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>다중 예외 처리<br>하나의 try{} 블록에서 여러 예외가 발생하는 경우<br>하나의 catch{} 블록에서 예외 처리 하거나<br>여러 catch{} 블록으로 나누어 처리할 수 있음<br>이때, 최상위 예외 클래스인 Exception 클래스는 가장 마지막 블록에 위치해야 함  </li>
</ul>
<p>하나의 catch{} 블록에서 처리     </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package exception;</span><br><span class="line"></span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileNotFoundException;</span><br><span class="line"></span><br><span class="line">public class ThrowsException &#123;</span><br><span class="line"></span><br><span class="line">    public Class loadClass(String fileName, String className) throws FileNotFoundException, ClassNotFoundException &#123; &#x2F;&#x2F;throws로 미루기</span><br><span class="line"></span><br><span class="line">        FileInputStream fis &#x3D; new FileInputStream(fileName);</span><br><span class="line">        Class c &#x3D; Class.forName(className);</span><br><span class="line">        return c;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        ThrowsException test &#x3D; new ThrowsException();</span><br><span class="line">        try &#123;</span><br><span class="line">            test.loadClass(&quot;IdeaProjects&#x2F;Chapter13&#x2F;a.txt&quot;,&quot;java.lang.string&quot;);</span><br><span class="line">        &#125; catch (FileNotFoundException | ClassNotFoundException e) &#123; &#x2F;&#x2F;두개의 예외를 같이 처리</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;end&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>여러 catch{}블록에서 처리 및 디폴트 Exception   </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package exception;</span><br><span class="line"></span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileNotFoundException;</span><br><span class="line"></span><br><span class="line">public class ThrowsException &#123;</span><br><span class="line"></span><br><span class="line">    public Class loadClass(String fileName, String className) throws FileNotFoundException, ClassNotFoundException &#123; &#x2F;&#x2F;throws로 미루기</span><br><span class="line"></span><br><span class="line">        FileInputStream fis &#x3D; new FileInputStream(fileName);</span><br><span class="line">        Class c &#x3D; Class.forName(className);</span><br><span class="line">        return c;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        ThrowsException test &#x3D; new ThrowsException();</span><br><span class="line">        try &#123;</span><br><span class="line">            test.loadClass(&quot;IdeaProjects&#x2F;Chapter13&#x2F;a.txt&quot;,&quot;java.lang.String&quot;);</span><br><span class="line">        &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125; catch (Exception e) &#123; &#x2F;&#x2F;그 외 다른 예외 처리(디폴트 익셉션), 항상 마지막 catch&#123;&#125; 블록에서..</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;end&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>사용자 정의 예외<br>JDK에서 제공하는 예외 클래스 외에 사용자의 필요에 의해 예외 클래스를 정의하여 사용<br>기존 JDK클래스에서 상속받아 예외 클래스 생성  </li>
</ul>
<p>사용자 정의 예외 연습<br>(id가 null 이거나 8자이하 20자 이상인 경우 예외 처리)    </p>
<p>예외 클래스 생성</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class IDFormatException extends Exception &#123;</span><br><span class="line">    public IDFormatException(String message) &#123; &#x2F;&#x2F;생성자의 매개변수로 예외 상황 메세지 받음    </span><br><span class="line">    super(massage);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>사용자 정의 예외 사용 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package exception;</span><br><span class="line"></span><br><span class="line">public class IDFormatTest &#123;</span><br><span class="line"></span><br><span class="line">    private String userID;</span><br><span class="line"></span><br><span class="line">    public String getUserID() &#123;</span><br><span class="line">        return userID;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setUserID(String userID) throws IDFormatException &#123; &#x2F;&#x2F;예외처리 미루기 </span><br><span class="line">        if (userID &#x3D;&#x3D; null) &#123;</span><br><span class="line">            throw new IDFormatException(&quot;아이디는 null일 수 없습니다.&quot;); &#x2F;&#x2F;throws는 미루기 throw는 발생</span><br><span class="line">        &#125; else if (userID.length() &lt;8 || userID.length() &gt; 20) &#123;</span><br><span class="line">            throw new IDFormatException(&quot;아이디는 8자 이상 20자 이하로 쓰세요.&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            this.userID &#x3D; userID;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        IDFormatTest idTest &#x3D; new IDFormatTest();</span><br><span class="line"></span><br><span class="line">        String myID &#x3D; &quot;tuna&quot;;</span><br><span class="line"></span><br><span class="line">        try &#123; &#x2F;&#x2F;사용하는 곳에서 예외 처리  </span><br><span class="line">            idTest.setUserID(myID);</span><br><span class="line">        &#125; catch (IDFormatException e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        myID &#x3D; null;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            idTest.setUserID(myID);</span><br><span class="line">        &#125; catch (IDFormatException e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Study</category>
        <category>JAVA OOP</category>
      </categories>
  </entry>
  <entry>
    <title>66. 자바 입출력 스트림</title>
    <url>/2020/08/12/hexo_OOP_66/</url>
    <content><![CDATA[<h1 id="객체-지향-프로그래밍"><a href="#객체-지향-프로그래밍" class="headerlink" title="객체 지향 프로그래밍"></a>객체 지향 프로그래밍</h1><h4 id="66-자바-입출력-스트림"><a href="#66-자바-입출력-스트림" class="headerlink" title="66. 자바 입출력 스트림"></a>66. 자바 입출력 스트림</h4><ul>
<li>입출력 스트림 이란<br>네트웍에서 자료의 흐름이 물과 같다는 의미에서 유래<br>다양한 입출력 장치에 독립적으로 일관성 있는 입출력 방식 제공<br>입출력이 구현되는 곳에서는 모두 I/O 스트림을 사용<br>:키보드, 파일, 디스크, 메모리 등  </li>
</ul>
<p>구분<br>I/O 대상 기준 : 입력 스트림, 출력 스트림<br>자료의 종류 : 바이트 스트림, 문자 스트림<br>스트림의 기능 : 기반 스트림, 보조 스트림    </p>
<ul>
<li><p>입력 or 출력 스트림<br>입력 스트림 : 대상으로 부터 자료를 읽어 들이는 스트림<br>ex) FileInputStream(바이트), FileReader(문자), BufferedInputStream(보조), BufferedReader, etc<br>출력 스트림 : 대상으로 자료를 출력하는 스트림<br>ex) FileOutputStream, FileWriter, BufferedOutputStream, BufferedWriter, etc   </p>
</li>
<li><p>바이트 or 문자 단위 스트림<br>바이트 단위 스트림 : 바이트 단위로 자료를 읽고 씀 (동영상, 음악 등)<br>ex) ~Stream<br>문자 단위 스트림 : 문자는 2byte이상씩 처리해야 함<br>ex) ~Reader, ~Writer</p>
</li>
<li><p>기반 or 보조 스트림<br>기반 스트림 : 대상에 직접 자료를 읽고 쓰는 기능의 스트림<br>ex) File~<br>보조 스트림 : 직접 읽고 쓰는 기능은 없고 추가적인 기능을 제공해 주는 스트림<br>기반 스트림이나 또 다른 보조 스트림을 생성자의 매개변수로 포함한다<br>ex) Buffered~, InputStreamReader, OutputStreamWriter</p>
</li>
<li><p>표준 입출력<br>System 클래스의 표준 입출력 멤버</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public Class System &#123;   </span><br><span class="line">    public static PrintStream out; &#x2F;&#x2F;표준 출력 스트림</span><br><span class="line">    public static InputStream in;  &#x2F;&#x2F;표준 입력 스트림</span><br><span class="line">    public static PrintStream err; &#x2F;&#x2F;표준 에러 스트림</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>System.in 사용하여 입력 받기<br>한 바이트 씩 읽어 들임<br>한글과 같은 여러 바이트로 된 문자를 읽기 위해서는<br>InPutStreamReader와 같은 보조 스트림을 사용해야 함    </p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package stream.inputstream;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStreamReader;</span><br><span class="line"></span><br><span class="line">public class SystemInTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;입력&quot;);</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            int i;</span><br><span class="line">            while ((i &#x3D; System.in.read()) !&#x3D; &#39;\n&#39;) &#123;</span><br><span class="line">                System.out.print((char)i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;입력 후 &#39;끝&#39; 이라고 쓰세요.&quot;);</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            int i;</span><br><span class="line">            InputStreamReader isr &#x3D; new InputStreamReader(System.in); &#x2F;&#x2F;byte -&gt; 문자, 다른 스트림을 생성자의 매개변수로 받음</span><br><span class="line">            while ((i &#x3D; isr.read()) !&#x3D; &#39;끝&#39;) &#123; &#x2F;&#x2F;&#39;끝&#39;은 2byte 이기 때문에 보조 스트림 필요</span><br><span class="line">                System.out.print((char)i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Scanner 클래스<br>java.util 패키지에 있는 입력 클래스<br>문자뿐 아니라 정수, 실수 등 다양한 자료형을 읽을 수 있음<br>생성자가 다양하여 여러 소스로부터 자료를 읽을 수 있음  </li>
</ul>
<p>Scanner(File source) : 파일을 매개변수로 받아 Scanner 생성<br>Scanner(InputStream source) : 바이트 스트림을 매개변수로 받아 Scanner 생성<br>Scanner(String source) : String을 매개변수로 받아 Scanner 생성    </p>
<ul>
<li>Console 클래스<br>System.in 을 사용하지 않고 콘솔에서(cmd,terminal) 표준 입출력이 가능<br>readLine() : 문자열을 읽습니다.<br>readPassword() : 사용자에게 문자열을 보여주지 않고 읽습니다<br>reader() : Reader 클래스를 반환<br>writer() : PrintWriter 클래스를 반환  </li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package stream.inputstream;</span><br><span class="line"></span><br><span class="line">import java.io.Console;</span><br><span class="line"></span><br><span class="line">public class ConsoleTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        Console console &#x3D; System.console();</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;이름&quot;);</span><br><span class="line">        String name &#x3D; console.readLine();</span><br><span class="line">        System.out.println(&quot;비밀 번호&quot;);</span><br><span class="line">        char[] password &#x3D; console.readPassword();</span><br><span class="line"></span><br><span class="line">        System.out.println(name);</span><br><span class="line">        System.out.println(password);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Study</category>
        <category>JAVA OOP</category>
      </categories>
  </entry>
  <entry>
    <title>68. 바이트 단위, 문자 단위 입출력 스트림</title>
    <url>/2020/08/12/hexo_OOP_68/</url>
    <content><![CDATA[<h1 id="객체-지향-프로그래밍"><a href="#객체-지향-프로그래밍" class="headerlink" title="객체 지향 프로그래밍"></a>객체 지향 프로그래밍</h1><h4 id="68-바이트-단위-문자-단위-입출력-스트림"><a href="#68-바이트-단위-문자-단위-입출력-스트림" class="headerlink" title="68. 바이트 단위, 문자 단위 입출력 스트림"></a>68. 바이트 단위, 문자 단위 입출력 스트림</h4><ul>
<li>바이트 단위 스트림<br>InputStream : 바이트 단위 입력 스트림 최상위 클래스<br>OutputStrem : 바이트 단위 출력 스트림 최상위 클래스     </li>
</ul>
<p>추상 메서드를 포함한 추상클래스로 하위 클래스가 구현하여 사용<br>주요 하위 클래스<br>FileInputStream, ByteArrayInputStream, FilterInputStream, etc<br>FileOutputStream, ByteArrayOutputStream, FilterOutputStream, etc</p>
<ul>
<li>FileInputStream, FileOutputStream 사용하기<br>파일에 한 바이트 씩 자료를 읽고 쓰는데 사용<br>입력 스트림은 파일이 없을 때 예외 발생<br>출력 스트림은 파일이 없는 경우 새로 파일을 생성하여 출력   </li>
</ul>
<p>FileInputStream</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package stream.inputstream;</span><br><span class="line"></span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">public class FileInputTest1 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        FileInputStream fis &#x3D; null;</span><br><span class="line">        try &#123;</span><br><span class="line">            fis &#x3D; new FileInputStream(&quot;IdeaProjects&#x2F;Chapter14&#x2F;input.txt&quot;);</span><br><span class="line">            int i;</span><br><span class="line">            while ( (i &#x3D; fis.read()) !&#x3D; -1 ) &#123; &#x2F;&#x2F;-1이 return 될 경우 끝이므로</span><br><span class="line">                System.out.print((char)i);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                fis.close();</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;end&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>FileInputStream &amp; try-with-resources</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package stream.inputstream;</span><br><span class="line"></span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">public class FileInputTest2 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        try (FileInputStream fis &#x3D; new FileInputStream(&quot;IdeaProjects&#x2F;Chapter14&#x2F;input.txt&quot;))&#123; &#x2F;&#x2F;AutoCloseable</span><br><span class="line">            int i;</span><br><span class="line">            while ( (i &#x3D; fis.read()) !&#x3D; -1 ) &#123;</span><br><span class="line">                System.out.print((char)i);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;end&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>FileInputStream &amp; byte[]로 읽기</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package stream.inputstream;</span><br><span class="line"></span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">public class FileInputTest3 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        try (FileInputStream fis &#x3D; new FileInputStream(&quot;IdeaProjects&#x2F;Chapter14&#x2F;input2.txt&quot;))&#123; &#x2F;&#x2F;AutoCloseable</span><br><span class="line">            int i;</span><br><span class="line">            byte[] bs &#x3D; new byte[10];</span><br><span class="line">            while ( (i &#x3D; fis.read(bs)) !&#x3D; -1 ) &#123; &#x2F;&#x2F;i:읽은 개수</span><br><span class="line">                for (int k&#x3D;0; k&lt;i; k++) &#123;</span><br><span class="line">                    System.out.print((char)bs[k]);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>FileOutputStream</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package stream.outputstream;</span><br><span class="line"></span><br><span class="line">import java.io.FileOutputStream;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">public class FileOutputTest1 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        try(FileOutputStream fos &#x3D; new FileOutputStream(&quot;output.txt&quot;,true)) &#123; &#x2F;&#x2F;append : 이어쓰기</span><br><span class="line">            fos.write(65); &#x2F;&#x2F;ABC 숫자를 넣었지만 문자로 출력</span><br><span class="line">            fos.write(66);</span><br><span class="line">            fos.write(67);</span><br><span class="line"></span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>FileOutputStream &amp; FileInputStream </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package stream.outputstream;</span><br><span class="line"></span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileOutputStream;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">public class FileOutputTest2 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        byte[] bs &#x3D; new byte[26];</span><br><span class="line">        byte data &#x3D; 65;</span><br><span class="line">        for (int i &#x3D; 0; i&lt;bs.length; i++) &#123;</span><br><span class="line">            bs[i] &#x3D; data;</span><br><span class="line">            data++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        try(FileOutputStream fos &#x3D; new FileOutputStream(&quot;alpha.txt&quot;,true);</span><br><span class="line">            FileInputStream fis &#x3D; new FileInputStream(&quot;alpha.txt&quot;)) &#123;</span><br><span class="line"></span><br><span class="line">            fos.write(bs);</span><br><span class="line">            int ch;</span><br><span class="line">            while ((ch &#x3D; fis.read()) !&#x3D; -1) &#123;</span><br><span class="line">                System.out.print((char)ch);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>문자 단위 스트림<br>Reader : 문자 단위로 읽는 최상위 스트림<br>Writer : 문자 단위로 쓰는 최상위 스트림<br>추상 메서드를 포함한 추상클래스로 하위 클래스가 구현하여 사용<br>주요 하위 클래스<br>FileReader, InputStreamReader, BufferedReader, etc<br>FileWriter, OutputStreamWriter, BufferedWriter, etc     </p>
</li>
<li><p>FileReader와 FileWriter<br>파일에 문자를 읽고 쓸때 가장 많이 사용하는 클래스<br>문자의 인코딩 방식을 지정할 수 있음    </p>
</li>
</ul>
<p>바이트 단위 스트림과의 비교</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package stream.reader;</span><br><span class="line"></span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileReader;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStreamReader;</span><br><span class="line"></span><br><span class="line">public class FileReaderTest &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line"></span><br><span class="line">        FileInputStream fis &#x3D; new FileInputStream(&quot;IdeaProjects&#x2F;Chapter14&#x2F;reader.txt&quot;); &#x2F;&#x2F;byte단위 스트림</span><br><span class="line">        int i;</span><br><span class="line">        while ((i &#x3D; fis.read()) !&#x3D; -1) &#123;</span><br><span class="line">            System.out.print((char)i); &#x2F;&#x2F;byte단위이기 때문에 한글 깨짐</span><br><span class="line">        &#125;</span><br><span class="line">        fis.close();</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line">        fis &#x3D; new FileInputStream(&quot;IdeaProjects&#x2F;Chapter14&#x2F;reader.txt&quot;);</span><br><span class="line">        InputStreamReader isr &#x3D; new InputStreamReader(fis); &#x2F;&#x2F;보조 스트림 사용 (byte -&gt; 문자)</span><br><span class="line">        int k;</span><br><span class="line">        while ((k &#x3D; isr.read()) !&#x3D; -1) &#123;</span><br><span class="line">            System.out.print((char)k);</span><br><span class="line">        &#125;</span><br><span class="line">        isr.close();</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        FileReader fr &#x3D; new FileReader(&quot;IdeaProjects&#x2F;Chapter14&#x2F;reader.txt&quot;); &#x2F;&#x2F;문자 단위 스트림</span><br><span class="line">        int j;</span><br><span class="line">        while ((j &#x3D; fr.read()) !&#x3D; -1) &#123;</span><br><span class="line">            System.out.print((char)j);</span><br><span class="line">        &#125;</span><br><span class="line">        fr.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>FileWriter &amp; FileReader</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package stream.writer;</span><br><span class="line"></span><br><span class="line">import java.io.FileReader;</span><br><span class="line">import java.io.FileWriter;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">public class FileWriterTest &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line"></span><br><span class="line">        FileWriter fw &#x3D; new FileWriter(&quot;IdeaProjects&#x2F;Chapter14&#x2F;writer.txt&quot;);</span><br><span class="line"></span><br><span class="line">        fw.write(&#39;A&#39;);</span><br><span class="line"></span><br><span class="line">        char[] cArr &#x3D; &#123;&#39;B&#39;,&#39;C&#39;,&#39;D&#39;,&#39;E&#39;,&#39;F&#39;&#125;;</span><br><span class="line">        fw.write(cArr);</span><br><span class="line">        fw.write(cArr,2,2); &#x2F;&#x2F;DE</span><br><span class="line"></span><br><span class="line">        String str &#x3D; &quot;안녕하세요.&quot;;</span><br><span class="line">        fw.write(str);</span><br><span class="line">        fw.close();</span><br><span class="line"></span><br><span class="line">        FileReader fr &#x3D; new FileReader(&quot;IdeaProjects&#x2F;Chapter14&#x2F;writer.txt&quot;);</span><br><span class="line">        int i;</span><br><span class="line">        while ((i&#x3D;fr.read()) !&#x3D; -1) &#123;</span><br><span class="line">            System.out.print((char)i);</span><br><span class="line">        &#125;</span><br><span class="line">        fr.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Study</category>
        <category>JAVA OOP</category>
      </categories>
  </entry>
  <entry>
    <title>70. 보조 스트림</title>
    <url>/2020/08/12/hexo_OOP_70/</url>
    <content><![CDATA[<h1 id="객체-지향-프로그래밍"><a href="#객체-지향-프로그래밍" class="headerlink" title="객체 지향 프로그래밍"></a>객체 지향 프로그래밍</h1><h4 id="70-보조-스트림"><a href="#70-보조-스트림" class="headerlink" title="70. 보조 스트림"></a>70. 보조 스트림</h4><p>실제 읽고 쓰는 스트림이 아닌 보조적인 기능을 추가하는 스트림<br>데코레이터라고도 불린다<br>상위 클래스 FilterInputStream, FilterOutputStream<br>생성자의 매개변수로 다른 스트림을 가진다</p>
<p>데코레이터 패턴(Decorator Pattern)<br>기반 스트림 &gt; 보조 스트림1 &gt; 보조 스트림2  </p>
<p>Buffered 스트림 : 내부에 8192바이트 배열을 가지고 있음, 읽거나 쓸때 속도가 빠름    </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private static int DEFAULT_BUFFER_SIZE &#x3D; 8192;</span><br></pre></td></tr></table></figure>

<p>Buffered 스트림을 이용하여 파일 복사</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package stream.decorator;</span><br><span class="line"></span><br><span class="line">import java.io.*;</span><br><span class="line">&#x2F;&#x2F;import java.net.Socket;</span><br><span class="line">&#x2F;&#x2F;import java.nio.Buffer;</span><br><span class="line"></span><br><span class="line">public class FileCopy &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line"></span><br><span class="line">        long milliseconds &#x3D; 0;</span><br><span class="line"></span><br><span class="line">        try(FileInputStream fis &#x3D; new FileInputStream(&quot;IdeaProjects&#x2F;Chapter14&#x2F;alpha.txt&quot;);</span><br><span class="line">            FileOutputStream fos &#x3D; new FileOutputStream(&quot;IdeaProjects&#x2F;Chapter14&#x2F;copy.txt&quot;);</span><br><span class="line">            BufferedInputStream bis &#x3D; new BufferedInputStream(fis); &#x2F;&#x2F;더 빠르게 처리하기 위해 데코레이터 사용</span><br><span class="line">            BufferedOutputStream bos &#x3D; new BufferedOutputStream(fos)) &#123;</span><br><span class="line"></span><br><span class="line">            milliseconds &#x3D; System.currentTimeMillis(); &#x2F;&#x2F;현재시간</span><br><span class="line"></span><br><span class="line">            int i;</span><br><span class="line">            while ((i&#x3D;bis.read()) !&#x3D; -1) &#123;</span><br><span class="line">                bos.write(i); &#x2F;&#x2F;while 동안 한 바이트씩 읽어서 바로 쓰기</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            milliseconds &#x3D; System.currentTimeMillis() - milliseconds; &#x2F;&#x2F;시간차 계산</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(milliseconds);</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;Socket socket &#x3D; new Socket();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;BufferedReader isr &#x3D; new BufferedReader(new InputStreamReader(socket.getInputStream())); &#x2F;&#x2F;byte-&gt;문자 보조에 추가로 버퍼기능까지</span><br><span class="line">        &#x2F;&#x2F;isr.readLine();&#x2F;&#x2F;BufferedReader에만 있는 메서드, 한줄만 읽는 기능(&#x2F;n 까지)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DataInputStream/DataOutputStream : 자료가 저장된 상태 그대로 자료형을 유지하며 읽거나 쓰는 기능을 제공하는 스트림    </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package stream.decorator;</span><br><span class="line"></span><br><span class="line">import java.io.*;</span><br><span class="line"></span><br><span class="line">public class DataStreamTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        try(FileOutputStream fos &#x3D; new FileOutputStream(&quot;IdeaProjects&#x2F;Chapter14&#x2F;data.txt&quot;);</span><br><span class="line">            DataOutputStream dos &#x3D; new DataOutputStream(fos);</span><br><span class="line">            FileInputStream fis &#x3D; new FileInputStream(&quot;IdeaProjects&#x2F;Chapter14&#x2F;data.txt&quot;);</span><br><span class="line">            DataInputStream dis &#x3D; new DataInputStream(fis)) &#123;</span><br><span class="line"></span><br><span class="line">            dos.writeByte(100); &#x2F;&#x2F;한 바이트로 씀</span><br><span class="line">            dos.write(100); &#x2F;&#x2F;4 바이트로 씀</span><br><span class="line">            dos.writeChar(&#39;A&#39;);</span><br><span class="line">            dos.writeUTF(&quot;안녕하세요&quot;);</span><br><span class="line"></span><br><span class="line">            System.out.println(dis.readByte()); &#x2F;&#x2F;쓴 방식대로 읽어야 한다 </span><br><span class="line">            System.out.println(dis.read());</span><br><span class="line">            System.out.println(dis.readChar());</span><br><span class="line">            System.out.println(dis.readUTF());</span><br><span class="line"></span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Study</category>
        <category>JAVA OOP</category>
      </categories>
  </entry>
  <entry>
    <title>71. 직렬화</title>
    <url>/2020/08/12/hexo_OOP_71/</url>
    <content><![CDATA[<h1 id="객체-지향-프로그래밍"><a href="#객체-지향-프로그래밍" class="headerlink" title="객체 지향 프로그래밍"></a>객체 지향 프로그래밍</h1><h4 id="71-직렬화"><a href="#71-직렬화" class="headerlink" title="71. 직렬화"></a>71. 직렬화</h4><p>인스턴스의 상태를 그대로 저장하거나 네트웍으로 전송하고 이를 다시 복원하는 방식<br>ObjectInputStream, ObjectOutputStream 보조스트림 사용  </p>
<p>Serializable 인터페이스<br>직렬화는 인스턴스의 내용이 외부로 유출되는 것이므로 프로그래머가 객체의 직렬화 가능 여부를 명시함<br>구현 코드가 없는 마크 인터페이스  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package stream.serialization;</span><br><span class="line"></span><br><span class="line">import java.io.*;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; class Person implements Externalizable &#123; &#x2F;&#x2F;직렬화가능하며 구현해야할 기능이 있음  </span><br><span class="line">class Person implements Serializable &#123; &#x2F;&#x2F;직렬화가능하다는 마크 인터페이스 </span><br><span class="line">    String name;</span><br><span class="line">    transient String job; &#x2F;&#x2F;직렬화 제외 키워드</span><br><span class="line"></span><br><span class="line">    public Person(String name, String job) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">        this.job &#x3D; job;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return name + &quot;,&quot; + job;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class SerializationTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        Person personLee &#x3D; new Person(&quot;이순신&quot;,&quot;엔지니어&quot;);</span><br><span class="line">        Person personKim &#x3D; new Person(&quot;김유신&quot;,&quot;선생님&quot;);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;객체 파일 생성</span><br><span class="line">        try (FileOutputStream fos &#x3D; new FileOutputStream(&quot;IdeaProjects&#x2F;Chapter14&#x2F;serial.dat&quot;);</span><br><span class="line">             ObjectOutputStream oos &#x3D; new ObjectOutputStream(fos)) &#123;</span><br><span class="line">            oos.writeObject(personLee);</span><br><span class="line">            oos.writeObject(personKim);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;객체 파일 읽기</span><br><span class="line">        try (FileInputStream fis &#x3D; new FileInputStream(&quot;IdeaProjects&#x2F;Chapter14&#x2F;serial.dat&quot;);</span><br><span class="line">        ObjectInputStream ois &#x3D; new ObjectInputStream(fis)) &#123;</span><br><span class="line">            Person p1 &#x3D; (Person) ois.readObject();</span><br><span class="line">            Person p2 &#x3D; (Person) ois.readObject();</span><br><span class="line"></span><br><span class="line">            System.out.println(p1);</span><br><span class="line">            System.out.println(p2);</span><br><span class="line"></span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Study</category>
        <category>JAVA OOP</category>
      </categories>
  </entry>
  <entry>
    <title>72. 그 외 입출력 클래스와 데코레이터 패턴</title>
    <url>/2020/08/12/hexo_OOP_72/</url>
    <content><![CDATA[<h1 id="객체-지향-프로그래밍"><a href="#객체-지향-프로그래밍" class="headerlink" title="객체 지향 프로그래밍"></a>객체 지향 프로그래밍</h1><h4 id="72-그-외-입출력-클래스와-데코레이터-패턴"><a href="#72-그-외-입출력-클래스와-데코레이터-패턴" class="headerlink" title="72. 그 외 입출력 클래스와 데코레이터 패턴"></a>72. 그 외 입출력 클래스와 데코레이터 패턴</h4><ul>
<li><p>File 클래스<br>파일 개념을 추상화한 클래스<br>입출력 기능은 없고 파일의 속성, 경로, 이름 등을 알 수 있음     </p>
</li>
<li><p>RandomAccessFile 클래스<br>입출력 클래스 중 유일하게 파일 입출력을 동시에 할 수 있는 클래스<br>파일 포인터가 있어서 읽고 쓰는 위치의 이동이 가능함<br>다양한 자료형에 대한 메서드가 제공됨    </p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package stream.others;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.RandomAccessFile;</span><br><span class="line"></span><br><span class="line">public class RandomAccessFileTest &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line"></span><br><span class="line">        RandomAccessFile rf &#x3D; new RandomAccessFile(&quot;IdeaProjects&#x2F;Chapter14&#x2F;random.txt&quot;,&quot;rw&quot;);</span><br><span class="line"></span><br><span class="line">        rf.writeInt(100);</span><br><span class="line">        System.out.println(rf.getFilePointer()); &#x2F;&#x2F;현재 포인터 위치</span><br><span class="line">        rf.writeDouble(3.14);</span><br><span class="line">        rf.writeUTF(&quot;안녕하세요&quot;);</span><br><span class="line"></span><br><span class="line">        rf.seek(0); &#x2F;&#x2F;포인터 위치 변경</span><br><span class="line">        int i &#x3D; rf.readInt();</span><br><span class="line">        double d &#x3D; rf.readDouble();</span><br><span class="line">        String str &#x3D; rf.readUTF();</span><br><span class="line"></span><br><span class="line">        System.out.println(i);</span><br><span class="line">        System.out.println(d);</span><br><span class="line">        System.out.println(str);</span><br><span class="line"></span><br><span class="line">        rf.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>데코레이터 패턴<br>자바의 입출력 스트림은 데코레이터 패턴을 사용<br>실제 입출력 기능을 가진 객체(컴포넌트)와 그 외 다양한 기능을 제공하는 데코레이터(보조스트림)을 사용하여 다양한 입출력 기능을 구현<br>상속보다 유연한 확장성을 가짐<br>지속적인 서비스의 증가와 제거가 용이함   </li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package stream.coffee;</span><br><span class="line"></span><br><span class="line">public class CoffeeTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        Coffee americano &#x3D; new KenyaAmericano();</span><br><span class="line">        americano.brewing();</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        Coffee kenyaLatte &#x3D; new Latte(new KenyaAmericano());</span><br><span class="line">        kenyaLatte.brewing();</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        Coffee mocha &#x3D; new Mocha(new Latte(new KenyaAmericano()));</span><br><span class="line">        mocha.brewing();</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        Coffee etiopiaLatte &#x3D; new Latte(new EtiopiaAmericano());</span><br><span class="line">        etiopiaLatte.brewing();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Study</category>
        <category>JAVA OOP</category>
      </categories>
  </entry>
  <entry>
    <title>74. Thread 구현하기</title>
    <url>/2020/08/12/hexo_OOP_74/</url>
    <content><![CDATA[<h1 id="객체-지향-프로그래밍"><a href="#객체-지향-프로그래밍" class="headerlink" title="객체 지향 프로그래밍"></a>객체 지향 프로그래밍</h1><h4 id="74-Thread-구현하기"><a href="#74-Thread-구현하기" class="headerlink" title="74. Thread 구현하기"></a>74. Thread 구현하기</h4><p>쓰레드를 구현할 일이 많지는 않지만 안드로이드 개발에서 쓰임<br>쓰레드 프로그래밍에서는 공유 자원이 중요  </p>
<ul>
<li><p>Process<br>실행중인 프로그램, OS로부터 메모리를 할당 받음     </p>
</li>
<li><p>Thread<br>실제 프로그램이 수행되는 작업의 최소 단위<br>하나의 프로세스는 하나 이상의 Thread를 가지게 됨  </p>
</li>
<li><p>Thread 구현하기   </p>
</li>
</ul>
<ol>
<li>자바 Thread 클래스로부터 상속받아 구현    </li>
<li>Runnable 인터페이스 구현   </li>
</ol>
<p>상속 방식</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package thread;</span><br><span class="line"></span><br><span class="line">class MyThread extends Thread &#123; </span><br><span class="line">    public void run() &#123;</span><br><span class="line">        int i;</span><br><span class="line">        for (i&#x3D;0;i&lt;200;i++) &#123;</span><br><span class="line">            System.out.print(i + &quot;\t&quot;);</span><br><span class="line">            try &#123;</span><br><span class="line">                sleep(100); &#x2F;&#x2F;Thread 클래스의 메서드</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                System.out.println(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ThreadTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;start&quot;);</span><br><span class="line">        MyThread th1 &#x3D; new MyThread(); &#x2F;&#x2F;main이랑 별개로 수행됨</span><br><span class="line">        MyThread th2 &#x3D; new MyThread();</span><br><span class="line"></span><br><span class="line">        th1.start(); &#x2F;&#x2F;클래스의 run() 수행</span><br><span class="line">        th2.start();</span><br><span class="line">        System.out.println(&quot;end&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>구현 방식   </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package thread;</span><br><span class="line"></span><br><span class="line">class MyThread implements Runnable &#123;</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        int i;</span><br><span class="line">        for (i&#x3D;0;i&lt;100;i++) &#123;</span><br><span class="line">            System.out.print(i + &quot;\t&quot;);</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(100); &#x2F;&#x2F;Thread 클래스의 메서드</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                System.out.println(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ThreadTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;start&quot;);</span><br><span class="line">        MyThread runner1 &#x3D; new MyThread();</span><br><span class="line">        MyThread runner2 &#x3D; new MyThread();</span><br><span class="line">        Thread th1 &#x3D; new Thread(runner1); &#x2F;&#x2F;Runnable을 구현한 객체를 매개변수로 가능</span><br><span class="line">        Thread th2 &#x3D; new Thread(runner2);</span><br><span class="line"></span><br><span class="line">        th1.start();</span><br><span class="line">        th2.start();</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;end&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>Multi-thread 프로그래밍<br>동시에 여러 개의 Thread가 수행되는 프로그래밍<br>Thread는 각각의 작업공간(context)를 가짐<br>공유 자원이 있는 경우 race condition이 발생<br>critical section은 한번에 하나의 thread만 접근할 수 있으며<br>critical section에 대한 동기화(synchronization)의 구현이 필요   </p>
</li>
<li><p>Thread의 여러가지 메서드 활용   </p>
</li>
</ul>
<p>Thread 우선 순위<br>Thread.MIN_PRIORITY(=1) ~ Thread.MAX_PRIORITY(=10)<br>디폴트 우선 순위 : Thread.NORM_PRIORITY(=5)    </p>
<p>setPriority(int newPriority)<br>int getPriority()</p>
<p>우선 순위가 높은 thread는 CPU를 배분 받을 확률이 높다     </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ThreadTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;start&quot;);</span><br><span class="line"></span><br><span class="line">        Thread t &#x3D; Thread.currentThread(); &#x2F;&#x2F;현재 수행중인 thread(main)</span><br><span class="line">        System.out.println(t); &#x2F;&#x2F;이름, priority, 그룹</span><br><span class="line">        </span><br><span class="line">        System.out.println(&quot;end&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>join() 메서드  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package thread;</span><br><span class="line"></span><br><span class="line">public class JoinTest extends Thread&#123;</span><br><span class="line"></span><br><span class="line">    int start;</span><br><span class="line">    int end;</span><br><span class="line">    int total;</span><br><span class="line"></span><br><span class="line">    public JoinTest(int start,int end) &#123;</span><br><span class="line">        this.start &#x3D; start;</span><br><span class="line">        this.end &#x3D; end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void run() &#123;</span><br><span class="line">        int i;</span><br><span class="line">        for(i&#x3D;start; i&lt;&#x3D;end; i++) &#123;</span><br><span class="line">            total +&#x3D; i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        JoinTest jt1 &#x3D; new JoinTest(1,50);</span><br><span class="line">        JoinTest jt2 &#x3D; new JoinTest(51,100);</span><br><span class="line"></span><br><span class="line">        jt1.start();</span><br><span class="line">        jt2.start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            jt1.join(); &#x2F;&#x2F;main thread가 jt1, jt2 thread를 대기(not runnable)</span><br><span class="line">            jt2.join();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int total &#x3D; jt1.total+jt2.total;</span><br><span class="line">        System.out.println(jt1.total);</span><br><span class="line">        System.out.println(jt2.total);</span><br><span class="line">        System.out.println(total);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>interrupt() 메서드<br>다른 thread에 예외를 발생시키는 interrupt를 보냄<br>thread가 join(),sleep(),wait() 메서드에 의해 블럭킹 되었다면 interrupt에 의해 다시 runnable 상태가 될 수 있음     </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package thread;</span><br><span class="line"></span><br><span class="line">public class InterruptTest extends Thread&#123;</span><br><span class="line"></span><br><span class="line">    public void run() &#123;</span><br><span class="line">        int i;</span><br><span class="line">        for (i&#x3D;0;i&lt;100;i++) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            sleep(5000); &#x2F;&#x2F;5초 not runnable</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">            System.out.println(&quot;Wake!!!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        InterruptTest test &#x3D; new InterruptTest();</span><br><span class="line">        test.start();</span><br><span class="line">        test.interrupt(); &#x2F;&#x2F;Interrupt 예외 발생</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;end&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Thread 종료하기<br>데몬등 무한 반복하는 thread가 종료될 수 있도록 run() 메서드 내의 while문을 활용<br>Thread.stop()은 사용하지 않는다     </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package thread;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">public class TerminateThread extends Thread&#123;</span><br><span class="line"></span><br><span class="line">    private boolean flag &#x3D; false;</span><br><span class="line">    int i;</span><br><span class="line"></span><br><span class="line">    public TerminateThread(String name) &#123; &#x2F;&#x2F;thread 이름 주기</span><br><span class="line">        super(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while( !flag ) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                sleep(100);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(getName()+&quot; end&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setFlag(boolean flag) &#123;</span><br><span class="line">        this.flag &#x3D; flag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line"></span><br><span class="line">        TerminateThread threadA &#x3D; new TerminateThread(&quot;A&quot;);</span><br><span class="line">        TerminateThread threadB &#x3D; new TerminateThread(&quot;B&quot;);</span><br><span class="line"></span><br><span class="line">        threadA.start();</span><br><span class="line">        threadB.start();</span><br><span class="line"></span><br><span class="line">        int in;</span><br><span class="line">        while(true) &#123;</span><br><span class="line">            in &#x3D; System.in.read();</span><br><span class="line">            if (in &#x3D;&#x3D; &#39;A&#39;) &#123;</span><br><span class="line">                threadA.setFlag(true);</span><br><span class="line">            &#125; else if (in &#x3D;&#x3D; &#39;B&#39;) &#123;</span><br><span class="line">                threadB.setFlag(true);</span><br><span class="line">            &#125; else if (in &#x3D;&#x3D; &#39;M&#39;) &#123;</span><br><span class="line">                threadA.setFlag(true);</span><br><span class="line">                threadB.setFlag(true);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;main end&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Study</category>
        <category>JAVA OOP</category>
      </categories>
  </entry>
  <entry>
    <title>77. Multi-thread 프로그래밍</title>
    <url>/2020/08/12/hexo_OOP_77/</url>
    <content><![CDATA[<h1 id="객체-지향-프로그래밍"><a href="#객체-지향-프로그래밍" class="headerlink" title="객체 지향 프로그래밍"></a>객체 지향 프로그래밍</h1><h4 id="77-Multi-thread-프로그래밍"><a href="#77-Multi-thread-프로그래밍" class="headerlink" title="77. Multi-thread 프로그래밍"></a>77. Multi-thread 프로그래밍</h4><ul>
<li><p>임계 영역(critical section)<br>두 개 이상의 thread가 동시에 접근하게 되는 리소스<br>critical section에 동시에 thread가 접근하게 되면 실행 결과를 보장할 수 없음<br>thread간의 순서를 맞추는 동기화(synchronization)가 필요   </p>
</li>
<li><p>동기화<br>임계 영역에 여러 thread가 접근하는 경우, 한 thread가 수행하는 동안 공유 자원을 lock하여 다른 thread의 접근을 막음<br>동기화를 잘못 구현하면 deadlock에 빠질 수 있음      </p>
</li>
<li><p>자바에서 동기화 구현<br>synchronized 수행문과 synchronized 메서드를 이용  </p>
</li>
</ul>
<p>synchronized 수행문</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">synchronized(참조형 수식) &#123;</span><br><span class="line">&#125; &#x2F;&#x2F;참조형 수식에 해당되는 객체에 lock을 건다</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package thread;</span><br><span class="line"></span><br><span class="line">class Bank &#123; &#x2F;&#x2F;critical section</span><br><span class="line">    private int money &#x3D; 10000;</span><br><span class="line"></span><br><span class="line">    public int getMoney() &#123;</span><br><span class="line">        return money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setMoney(int money) &#123;</span><br><span class="line">        this.money &#x3D; money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void saveMoney(int save) &#123;</span><br><span class="line">        synchronized (this) &#123; &#x2F;&#x2F;Bank가 shared resource 이므로</span><br><span class="line">            int m &#x3D; this.getMoney();</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(3000);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            setMoney(m+save);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void minusMoney(int minus) &#123;</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            int m &#x3D; this.getMoney();</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(200);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            setMoney(m - minus);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Park extends Thread &#123;</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(&quot;start save&quot;);</span><br><span class="line">        SyncTest.myBank.saveMoney(3000);</span><br><span class="line">        System.out.println(&quot;save money:&quot; + SyncTest.myBank.getMoney());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ParkWife extends Thread &#123;</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(&quot;start minus&quot;);</span><br><span class="line">        SyncTest.myBank.minusMoney(1000);</span><br><span class="line">        System.out.println(&quot;minus money:&quot; + SyncTest.myBank.getMoney());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class SyncTest &#123;</span><br><span class="line">    public static Bank myBank &#x3D; new Bank();</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        Park park &#x3D; new Park();</span><br><span class="line">        ParkWife parkwife &#x3D; new ParkWife();</span><br><span class="line"></span><br><span class="line">        park.start();</span><br><span class="line">        Thread.sleep(200);</span><br><span class="line">        parkwife.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>synchronized 메서드<br>현재 이 메서드가 속한 객체에 lock을 건다<br>deadlock 방지를 위해 synchronized 메서드 내에서 다른 synchronized 메서드를 호출하지 않는다  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package thread;</span><br><span class="line"></span><br><span class="line">class Bank &#123; &#x2F;&#x2F;critical section</span><br><span class="line">    private int money &#x3D; 10000;</span><br><span class="line"></span><br><span class="line">    public int getMoney() &#123;</span><br><span class="line">        return money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setMoney(int money) &#123;</span><br><span class="line">        this.money &#x3D; money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized void saveMoney(int save) &#123; &#x2F;&#x2F;synchronized 키워드로 lock</span><br><span class="line">        int m &#x3D; this.getMoney();</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(3000);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        setMoney(m+save);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized void minusMoney(int minus) &#123;</span><br><span class="line">        int m &#x3D; this.getMoney();</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(200);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        setMoney(m-minus);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Park extends Thread &#123;</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(&quot;start save&quot;);</span><br><span class="line">        SyncTest.myBank.saveMoney(3000);</span><br><span class="line">        System.out.println(&quot;save money:&quot; + SyncTest.myBank.getMoney());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ParkWife extends Thread &#123;</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(&quot;start minus&quot;);</span><br><span class="line">        SyncTest.myBank.minusMoney(1000);</span><br><span class="line">        System.out.println(&quot;minus money:&quot; + SyncTest.myBank.getMoney());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class SyncTest &#123;</span><br><span class="line">    public static Bank myBank &#x3D; new Bank();</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        Park park &#x3D; new Park();</span><br><span class="line">        ParkWife parkwife &#x3D; new ParkWife();</span><br><span class="line"></span><br><span class="line">        park.start();</span><br><span class="line">        Thread.sleep(200);</span><br><span class="line">        parkwife.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>wait(),notify() 메소드   </li>
</ul>
<p>wait() : 리소스가 더 이상 유효하지 않은 경우 리소스가 사용 가능할 때 까지 기다리기 위해 thread를 non-runnable 상태로 전환<br>wait() 상태가 된 thread는 notify()가 호출 될 때까지 기다린다    </p>
<p>notify() : wait()하고 있는 thread중 한 thread를 runnable한 상태로 깨움   </p>
<p>nofifyAll() : wait()하고 있는 모든 thread가 runnable한 상태가 되도록 함<br>notify()보다 notifyAll()을 사용하길 권장됨<br>특정 thread가 통지를 받도록 제어할 수 없으므로 모두 깨운 후 scheduler에 CPU를 점유하는 것이 좀더 공평     </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package thread;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line"></span><br><span class="line">class FastLibrary&#123;</span><br><span class="line"></span><br><span class="line">    public ArrayList&lt;String&gt; books &#x3D; new ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">    public FastLibrary() &#123;</span><br><span class="line">        books.add(&quot;태백산맥1&quot;);</span><br><span class="line">        books.add(&quot;태백산맥2&quot;);</span><br><span class="line">        books.add(&quot;태백산맥3&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized String lendBook() throws InterruptedException &#123;</span><br><span class="line">        Thread t &#x3D; Thread.currentThread();</span><br><span class="line">        while (books.size() &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            System.out.println(t.getName() + &quot; waiting start&quot;);</span><br><span class="line">            wait();</span><br><span class="line">            System.out.println(t.getName() + &quot; waiting end&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        String title &#x3D; books.remove(0);</span><br><span class="line">        System.out.println(t.getName() +&quot;:&quot;+ title + &quot; lend&quot;);</span><br><span class="line">        return title;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized void returnBook(String title) &#123;</span><br><span class="line">        Thread t &#x3D; Thread.currentThread();</span><br><span class="line">        books.add(title);</span><br><span class="line">        notifyAll(); &#x2F;&#x2F;모든 wait 스레드를 깨운다     </span><br><span class="line">        System.out.println(t.getName() +&quot;:&quot;+ title + &quot; return&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Student extends Thread&#123;</span><br><span class="line"></span><br><span class="line">    public void run() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            String title &#x3D; LibraryMain.library.lendBook();</span><br><span class="line">            if (title &#x3D;&#x3D; null) return;</span><br><span class="line">            sleep(5000);</span><br><span class="line">            LibraryMain.library.returnBook(title);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class LibraryMain &#123;</span><br><span class="line"></span><br><span class="line">    public static FastLibrary library &#x3D; new FastLibrary();</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        Student std1 &#x3D; new Student();</span><br><span class="line">        Student std2 &#x3D; new Student();</span><br><span class="line">        Student std3 &#x3D; new Student();</span><br><span class="line">        Student std4 &#x3D; new Student();</span><br><span class="line">        Student std5 &#x3D; new Student();</span><br><span class="line">        Student std6 &#x3D; new Student();</span><br><span class="line"></span><br><span class="line">        std1.start();</span><br><span class="line">        std2.start();</span><br><span class="line">        std3.start();</span><br><span class="line">        std4.start();</span><br><span class="line">        std5.start();</span><br><span class="line">        std6.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Study</category>
        <category>JAVA OOP</category>
      </categories>
  </entry>
  <entry>
    <title>maven / logback</title>
    <url>/2020/08/15/hexo_spring_project_1/</url>
    <content><![CDATA[<h2 id="maven-logback"><a href="#maven-logback" class="headerlink" title="maven / logback"></a>maven / logback</h2><ul>
<li>maven  </li>
</ul>
<p>build를 담당하는 maven &amp; gradle<br>mvc compile을 통해 필요한 library들을 검토하고 자동으로 다운로드 해준다.<br>다운받은 jar파일들은 User Home 디렉토리의 .m2/repository에 보관된다.<br>설정 파일<br>maven : pom.xml<br>gradle : build.gradle<br>컴파일하면 target으로 실행가능하도록 생성됨  </p>
<ul>
<li>logback (slf4j) </li>
</ul>
<p>level이 내려갈수록 log 범위가 작아짐<br>logging을 담당하는 logback<br>.trace<br>.debug<br>.info<br>.warn<br>.error  </p>
<p>logback에 대한 설정은 src/main/resources에 logback.xml(spring-boot에서는 logback-spring.xml)을 생성하여 할 수 있다.<br>ex) logback.xml</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;appender name&#x3D;&quot;STDOUT&quot; class&#x3D;&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;</span><br><span class="line">        &lt;encoder&gt;</span><br><span class="line">            &lt;pattern&gt;%-5level %logger&#123;36&#125; - %msg%n&lt;&#x2F;pattern&gt;</span><br><span class="line">        &lt;&#x2F;encoder&gt;</span><br><span class="line">    &lt;&#x2F;appender&gt;</span><br><span class="line"></span><br><span class="line">    &lt;root level&#x3D;&quot;trace&quot;&gt;</span><br><span class="line">        &lt;appender-ref ref&#x3D;&quot;STDOUT&quot; &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;root&gt;</span><br><span class="line">&lt;&#x2F;configuration&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>DB(h2)  </li>
</ul>
<p>설치</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew install h2</span><br></pre></td></tr></table></figure>
<p>실행 (브라우저에서 h2-console로 연결된다)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">h2</span><br></pre></td></tr></table></figure>

<p>JDBC API는 java.sql과 javax.sql이 있는데 각각 JAVA SE와 EE에 호환된다.  </p>
<p>연결, 테이블생성, 조회</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    private static Logger logger &#x3D; LoggerFactory.getLogger(Main.class);</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        logger.info(&quot;Hello World&quot;);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;Connection, Statement, ResultSet은 java.sql에 있는 구현체이다.</span><br><span class="line">        Connection connection &#x3D; null;</span><br><span class="line">        Statement statement &#x3D; null;</span><br><span class="line">        try &#123;</span><br><span class="line">            Class.forName(&quot;org.h2.Driver&quot;);</span><br><span class="line">            String url &#x3D; &quot;jdbc:h2:mem:test;MODE&#x3D;MySQL;&quot;;</span><br><span class="line">            connection &#x3D; DriverManager.getConnection(url, &quot;sa&quot;, &quot;&quot;);</span><br><span class="line">            statement &#x3D; connection.createStatement();</span><br><span class="line"></span><br><span class="line">            connection.setAutoCommit(false);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;테이블 생성</span><br><span class="line">            statement.execute(&quot;create table member(&quot; +</span><br><span class="line">                    &quot;id int auto_increment, &quot; +</span><br><span class="line">                    &quot;username varchar(255) not null, &quot; +</span><br><span class="line">                    &quot;password varchar(255) not null, &quot; +</span><br><span class="line">                    &quot;primary key(id))&quot;);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;데이터 insert</span><br><span class="line">            statement.executeUpdate(&quot;insert into member(username, password)&quot; +</span><br><span class="line">                    &quot;values(&#39;jilee&#39;,&#39;1234&#39;)&quot;);</span><br><span class="line"></span><br><span class="line">            ResultSet resultSet &#x3D; statement.executeQuery(&quot;select * from member&quot;);</span><br><span class="line">            </span><br><span class="line">            &#x2F;&#x2F;select 결과는 ResultSet에 저장되며</span><br><span class="line">            &#x2F;&#x2F;ResultSet.next()는 커서를 레코드 단위로 리턴한 뒤 마지막에는 false를 리턴한다. </span><br><span class="line">            while (resultSet.next()) &#123;</span><br><span class="line">                int id &#x3D; resultSet.getInt(&quot;id&quot;);</span><br><span class="line">                String username &#x3D; resultSet.getString(&quot;username&quot;);</span><br><span class="line">                String password &#x3D; resultSet.getString(&quot;password&quot;);</span><br><span class="line"></span><br><span class="line">                logger.info(id + username + password);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            connection.commit();</span><br><span class="line"></span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (SQLException throwables) &#123;</span><br><span class="line">            throwables.printStackTrace();</span><br><span class="line">            try &#123;</span><br><span class="line">                connection.rollback();</span><br><span class="line">            &#125; catch (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;사용한 자원 정리 단계</span><br><span class="line">        &#125; finally &#123; </span><br><span class="line">            try &#123;</span><br><span class="line">                statement.close();</span><br><span class="line">            &#125; catch (SQLException throwables) &#123;</span><br><span class="line">                throwables.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            try &#123;</span><br><span class="line">                connection.close();</span><br><span class="line">            &#125; catch (SQLException throwables) &#123;</span><br><span class="line">                    throwables.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>리팩토링 후<br>var 사용 / try with resource 사용 / Member 모델 사용</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    private static Logger logger &#x3D; LoggerFactory.getLogger(Main.class);</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws ClassNotFoundException &#123;</span><br><span class="line">        logger.info(&quot;Hello World&quot;);</span><br><span class="line"></span><br><span class="line">        Class.forName(&quot;org.h2.Driver&quot;);</span><br><span class="line">        var url &#x3D; &quot;jdbc:h2:mem:test;MODE&#x3D;MySQL;&quot;;</span><br><span class="line"></span><br><span class="line">        try(var connection &#x3D; DriverManager.getConnection(url, &quot;sa&quot;, &quot;&quot;);</span><br><span class="line">            var statement &#x3D; connection.createStatement();)</span><br><span class="line">        &#123;</span><br><span class="line">            connection.setAutoCommit(false);</span><br><span class="line">            statement.execute(&quot;create table member(&quot; +</span><br><span class="line">                    &quot;id int auto_increment, &quot; +</span><br><span class="line">                    &quot;username varchar(255) not null, &quot; +</span><br><span class="line">                    &quot;password varchar(255) not null, &quot; +</span><br><span class="line">                    &quot;primary key(id))&quot;);</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                statement.executeUpdate(&quot;insert into member(username, password)&quot; +</span><br><span class="line">                        &quot;values(&#39;jilee&#39;,&#39;1234&#39;)&quot;);</span><br><span class="line">                connection.commit();</span><br><span class="line">            &#125; catch (SQLException e) &#123;</span><br><span class="line">                connection.rollback();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            var resultSet &#x3D; statement.executeQuery(&quot;select * from member&quot;);</span><br><span class="line">            while (resultSet.next()) &#123;</span><br><span class="line">                var member &#x3D; new Member(resultSet);</span><br><span class="line">                logger.info(member.toString());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; catch (SQLException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Lombok  </li>
</ul>
<p>코드의 가독성을 위하여 사용한다.  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Getter</span><br><span class="line">@Setter</span><br><span class="line">@ToString</span><br><span class="line">@NoArgsConstructor</span><br><span class="line">@RequiredArgsConstructor</span><br><span class="line">public class Member &#123;</span><br><span class="line"></span><br><span class="line">    private int id;</span><br><span class="line">    @NonNull private String userName;</span><br><span class="line">    @NonNull private String password;</span><br><span class="line"></span><br><span class="line">    public Member(ResultSet resultSet) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            this.id &#x3D; resultSet.getInt(&quot;id&quot;);</span><br><span class="line">            this.userName &#x3D; resultSet.getString(&quot;username&quot;);</span><br><span class="line">            this.password &#x3D; resultSet.getString(&quot;password&quot;);</span><br><span class="line">        &#125; catch (SQLException throwables) &#123;</span><br><span class="line">            throwables.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>servlet  </li>
</ul>
<p>EE 버전의 스팩을 구현한 servlet 서버로는 tomcat / jeus / oracle weblogic 등이 있다.  </p>
<p>EE 사용을 위한 의존성 추가</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;javax.servlet&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;javax.servlet-api&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;4.0.1&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;scope&gt;provided&lt;&#x2F;scope&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<p>WAR 설정 추가</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;groupId&gt;com.mycompany.app&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;my-app&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt;</span><br><span class="line">&lt;packaging&gt;war&lt;&#x2F;packaging&gt;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Study</category>
        <category>Spring Framework</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>IoC (Inversion of Control)</title>
    <url>/2020/08/15/hexo_spring_project_2/</url>
    <content><![CDATA[<h2 id="IoC-Inversion-of-Control"><a href="#IoC-Inversion-of-Control" class="headerlink" title="IoC (Inversion of Control)"></a>IoC (Inversion of Control)</h2><p>Spring의 대표적인 특징 중 하나.</p>
<p>어떤 객체가 사용하는 의존 객체를 직접 만들어서 사용하는게 아니라, 주입(DI)받아서 사용하는 것.  </p>
<p>Spring IoC Container<br> : 애플리케이션 컴포넌트의 중앙 저장소.</p>
<p>ApplicationContext<br> : IoC 컨테이너의 핵심적인 인터페이스.<br> IoC 컨테이너의 최상위 인터페이스인 BeanFactory를 상속받아 여러 기능이 추가됨.</p>
<ul>
<li><p>메시지 소스 처리 (i18n)  </p>
</li>
<li><p>이벤트 발행</p>
</li>
<li><p>리소스 로딩  </p>
<p>IoC 컨테이너에 객체를 생성하고 생성된 객체들(Bean)의 의존성을 관리해준다.<br>이해만 해둘뿐, 딱히 이 인터페이스에 대해 직접 보거나 사용할 일은 없는 듯.<br>ClassPathXmlApplicationContext : XML 설정 파일 사용<br>AnnotationConfigApplicationContext : 자바 설정 파일 사용 (@Configuration)</p>
</li>
</ul>
<p>Bean<br> : Spring IoC 컨테이너가 관리하는 객체.<br>Class를 Bean으로 등록하려면 Component Scan을 사용하거나<br>또는 직접 XML이나 자바 설정 파일(@Configuration)에 등록해야 한다.  </p>
<p>IoC 컨테이너에 등록되는 Bean들의 특징</p>
<ul>
<li>의존성 관리, 특히 테스트에서 가짜 객체(@Mock)를 활용한 단위테스트에 용이하다.</li>
<li>스코프 : 기본적으로 싱글톤 스코프로 등록이된다. (or 프로토타입)<br>싱글톤 스코프로 등록되는 클래스는 애플리케이션이 구동되는 초기에 Bean으로 생성된다.  </li>
<li>라이프사이클 인터페이스</li>
</ul>
<p>Component Scanning<br> : Annotation 처리 프로세서 역할을 하는 @ComponentScan에 의하여<br> 모든 @Component Annotation이 붙은 Class들을 Bean으로 등록한다.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">    @Repository</span><br><span class="line">    @Service</span><br><span class="line">    @Controller</span><br></pre></td></tr></table></figure>

<p>참고로 @ComponentScan은 기본적으로 이 어노테이션이 붙은 클래스가 위치한 곳 부터 Component Scanning을 실시한다.<br>또는 특정 위치에서 부터 Scanning을 하도록 설정할수도 있고 Filter 옵션을 통해 어떤 클래스를 스캔할 지 또는 하지 않을 지 정할 수도 있다.   </p>
<p>직접 등록하기</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class Config() &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public String test() &#123;</span><br><span class="line">        return &quot;test&quot;;</span><br><span class="line">    &#125;   </span><br><span class="line">    </span><br><span class="line">    @Bean</span><br><span class="line">    public BookRepository bookRepository() &#123;</span><br><span class="line">        return new BookRepository();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public BookService bookService &#123;</span><br><span class="line">        return new BookService(bookRespsitory());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>function을 이용한 직접 등록</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    new SpringApplicationBuilder()</span><br><span class="line">        .sources(Demospring51Application.class)</span><br><span class="line">        .initializers((ApplicationContextInitializer&lt;GenericApplicationContext&gt;)</span><br><span class="line">            applicationContext -&gt; &#123;</span><br><span class="line">                applicationContext.registerBean(MyBean.class);</span><br><span class="line">            &#125;)</span><br><span class="line">        .run(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>이 방법은 리플랙션이나 프록시를 사용하지 않기 때문에 애플리케이션 구동 시 성능상의 이점이 있다지만..<br>ComponentScan을 대체하기에는 쓰기 불편해서 좋은 방법은 아닌 것 같다. </p>
<p>Bean을 꺼내어 쓰는 방법<br> : @Autowired 또는 @Inject 또는 ApplicationContext.getBean()으로 직접 꺼내기<br>Bean으로 등록된 Class만 Bean을 꺼내어 쓸 수 있다.</p>
<p>의존성 주입(Dependency Injection)<br> : @Autowired 또는 @Inject를 사용하는데,<br> 예외로 생성자가 오직 하나이면서 Bean을 파라미터로 받는다면 @Autowired를 생략하고도 DI를 자동으로 해준다.<br> @Autowired/@Inject를 붙인다면 생성자/필드/Setter에 붙이게 된다.</p>
<h4 id="Autowired에-대하여…"><a href="#Autowired에-대하여…" class="headerlink" title="@Autowired에 대하여…"></a>@Autowired에 대하여…</h4><p>어노테이션을 setter에 달려있고 의존성의 Bean이 없을 때,<br>setter임에도 불구하고 생각과 달리 다른 경우와 마찬가지로 객체생성이 불가능할 수 있는데<br>Spring이 해당 의존성을 위해 Bean을 찾기 때문이다.<br>이를 피하기 위해서는 @Autowired(required = false)로 설정하여 의존성 주입이 안된 상태로 생성할 수 있다.<br>필드에 어노테이션을 다는 경우도 비슷함.  </p>
<p>그리고 의존성 타입의 Bean이 여러가지 일 경우에 객체생성이 안될 수 있는데,<br>이때는 주입받으려는 Bean을 @Primary로 마킹하거나,</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Repository @Primary</span><br><span class="line">public class PrimaryBookRepository implements BookRepository &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>해당 타입의 모든 Bean을 주입 받거나</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">List&lt;BookRepository&gt; bookrepositories;</span><br></pre></td></tr></table></figure>
<p>@Qualifier(“beanName”)으로 특정 Bean을 주입받는다.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Autowired @Qualifier(&quot;sampleBookRepository&quot;)</span><br><span class="line">BookRepository bookrepository;</span><br></pre></td></tr></table></figure>

<p>BeanPostProcessor<br> : 빈 라이프 사이클 인터페이스이다.<br> 빈 인스턴스의 생성 전후에 부가적인 작업을 할 수 있다.<br> 특히, AutowiredAnnotationBeanPostProcessor의 postProcessorBeforeInitialization 메서드로 인해<br> 빈 인스턴스 생성 전에 @Autowired 어노테이션을 처리한다.</p>
<p>BeanFactoryPostProcessor<br> : 다른 모든 Bean들을 만들기 이전에 수행된다.<br> 특히, BeanFactoryPostProcessor를 구현한 ConfigurationClassPostProcessor는 @ComponentScan 어노테이션을 처리한다.  </p>
<h4 id="빈의-스코프에-대하여…"><a href="#빈의-스코프에-대하여…" class="headerlink" title="빈의 스코프에 대하여…"></a>빈의 스코프에 대하여…</h4><p>빈의 스코프는 기본적으로 싱글톤이고, 그 외에 프로토타입이 있다.<br>프로토타입</p>
<ul>
<li>Request</li>
<li>Session</li>
<li>WebSocket</li>
<li>…  </li>
</ul>
<p>@Component @Scope(“prototype”)<br>위의 어노테이션처리된 Bean은 받아 올 때마다 새로운 인스턴스가 생성된다.  </p>
<p>참고로 프로토타입 빈이 싱글톤 빈을 의존하는 것은 문제없지만,<br>싱글톤 빈이 의존하는 프로토타입 빈은 의도한 것처럼 새로운 인스턴스가 생성되지 않는다는 문제가 있다.<br>이 문제를 해결하는 방법으로</p>
<ul>
<li>Proxy mode<br>프로토타입 빈을 Proxy 빈으로 감싸서 다른 빈이 이 프로토타입 빈을 참조할 때 Proxy를 거쳐서 참조하도록<br>이때, Proxy 빈은 해당 프로토타입 빈을 상속하며, 참조하는 빈은 Proxy 빈을 참조한다. <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">##for class</span><br><span class="line">@Component @Scope(value &#x3D; &quot;prototype&quot;, proxyMode &#x3D; ScopedProxyMode.TARGET_CLASS)</span><br><span class="line">##for interface</span><br><span class="line">@Component @Scope(value &#x3D; &quot;prototype&quot;, proxyMode &#x3D; ScopedProxyMode.INTERFACES)</span><br></pre></td></tr></table></figure></li>
<li>Object-Provider<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">ObjectProvider&lt;Proto&gt; proto;</span><br></pre></td></tr></table></figure></li>
<li>Provider</li>
</ul>
<h4 id="ApplicationContext의-기능-Environment…"><a href="#ApplicationContext의-기능-Environment…" class="headerlink" title="ApplicationContext의 기능 Environment…"></a>ApplicationContext의 기능 Environment…</h4><p>EnvironmentCapable<br> : 프로파일과 프로퍼티를 다루는 인터페이스이다.  </p>
<p>프로파일<br> : 빈들의 그룹, Environment가 활성화할 프로파일을 확인하고 설정한다.<br> 환경에따라 사용할 빈을 구분할 때 사용된다. (ex 프로덕션에서는 A 빈, 테스트환경에서는 B 빈을 사용)</p>
<p>프로파일 정의하기</p>
<ul>
<li>클래스에 정의<br>test 프로파일로 애플리케이션을 실행할 때 사용될 Java Configuration<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Configuration @Profile(&quot;test&quot;)</span><br></pre></td></tr></table></figure>
proc 프로파일이 아닌 애플리케이션을 실행할 때 사용될 Component <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Component @Profile(&quot;!proc&quot;)</span><br></pre></td></tr></table></figure></li>
<li>Bean 생성 메서드에 정의<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Bean @Profile(&quot;test&quot;)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>@Profile에는 표현식으로 !(not), &amp;(and), |(or) 가능.</p>
<p>프로파일 지정하기</p>
<ul>
<li><p>JVM 시스템 프로퍼티 [-Dspring.profiles.avtive=”test,A,B,…”]<br>== intelliJ의 Run/Debug Configuration의 Active profiles </p>
</li>
<li><p>@ActiveProfiles (테스트용)</p>
</li>
</ul>
<p>프로퍼티<br> : 다양한 방법으로 정의할 수 있는 설정 값, Environment가 프로퍼티 소스를 설정하고 프로퍼티 값을 가져온다.<br> 프로퍼티는 우선순위가 있다.(계층형이다.)<br> 1.ServletConfig<br> 1.ServletContext<br> 1.JNDI (java:comp/env/)<br> 1.JVM 시스템 프로퍼티 (-Dkey=”value”)<br> 1.JVM 시스템 환경 변수 (OS 환경 변수)</p>
<p>Environment를 통해 프로퍼티 추가하기</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@PropertySource(&quot;classpath:&#x2F;app.properties&quot;)</span><br></pre></td></tr></table></figure>
<p>app.properties 파일을 참조한다.<br>참고로 스프링부트에서는 application.properties라는 기본 프로퍼티 소스를 지원한다.  </p>
<h4 id="ApplicationContext의-기능-MessageSource…"><a href="#ApplicationContext의-기능-MessageSource…" class="headerlink" title="ApplicationContext의 기능 MessageSource…"></a>ApplicationContext의 기능 MessageSource…</h4><p>MessageSource<br> : i18n(국제화) 기능을 제공하는 인터페이스이다.  </p>
<p>MessageSource의 getMessage로 참조할 수 있다.<br>Locale에 따라서 다른 메세지를 보여준다.  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">MessageSource messageSource;</span><br><span class="line"></span><br><span class="line">public void run() &#123;</span><br><span class="line">    System.out.println(messageSource.getMessage(&quot;code1&quot;), Locale.KOREA);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>스프링부트에서는 messages로 시작하는 소스들을 자동으로 참조한다.<br>messages.properties<br>messages_ko_KR.properties</p>
<p>리로딩 기능이 있는 메시지 소스를 @Bean으로 직접 만들어서 참조</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public MessageSource messageSource() &#123;</span><br><span class="line">    var messageSource &#x3D; new ReloadableResourceBundleMessageSource();</span><br><span class="line">    messageSource.setBasename(&quot;classpath:&#x2F;messages&quot;);</span><br><span class="line">    messageSource.setDefaultEncoding(&quot;UTF-8&quot;);</span><br><span class="line">    return messageSource;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ApplicationContext의-기능-ApplicationEventPublisher…"><a href="#ApplicationContext의-기능-ApplicationEventPublisher…" class="headerlink" title="ApplicationContext의 기능 ApplicationEventPublisher…"></a>ApplicationContext의 기능 ApplicationEventPublisher…</h4><p>ApplicationEventPublisher<br> : 이벤트 프로그래밍에 필요한 인터페이스. 옵저버 패턴의 구현체이다.  </p>
<p>spring 4.2 전에는<br>이벤트 만들기<br>ApplicationEvent Class를 상속받아야 한다.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MyEvent extends ApplicationEvent &#123;</span><br><span class="line">    public MyEvent(Object source) &#123;</span><br><span class="line">        super(source);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>이벤트 핸들러 만들기<br>ApplicationListener&lt;이벤트&gt; 인터페이스를 구현하고 빈으로 등록되어야 한다.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class MyEventHandler implements ApplicationListener&lt;MyEvent&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onApplicationEvent(MyEvent event) &#123;</span><br><span class="line">        System.out.println(&quot;이벤트 확인&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>spring 4.2 부터는 이벤트나 이벤트 핸들러 생성에서 상속/구현이 빠지고 어노테이션으로 처리한다.<br>이벤트 만들기</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MyEvent &#123;</span><br><span class="line">    private Object source;</span><br><span class="line"></span><br><span class="line">    public MyEvent(Object source) &#123;</span><br><span class="line">        this.source &#x3D; source;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public Object getSource() &#123;</span><br><span class="line">        return source;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>이벤트 핸들러 만들기</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class MyEventHandler &#123;</span><br><span class="line">    </span><br><span class="line">    @EventListener</span><br><span class="line">    public void handle(MyEvent event) &#123;</span><br><span class="line">        System.out.println(&quot;이벤트 확인&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>이벤트 발생시키기</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ApplicationEventPublisher.publishEvent(new MyEvent(this));</span><br></pre></td></tr></table></figure>

<p>만약 이벤트 핸들러가 여러개라면, Spring은 기본적으로 이벤트를 여러 핸들러로 순차적으로 처리하게 된다.<br>이때, 순서를 정하고 싶다면 핸들러에 @Order 어노테이션을 사용한다.<br>또는 비동기적(여러 쓰레드)으로 처리하고 싶다면 @Async 사용한다. (Java Configuration File에서는 @EnableAsync 필요)  </p>
<p>Spring에서 제공하는 기본 이벤트</p>
<ul>
<li>ContextRefreshedEvent</li>
<li>ContextStartedEvent</li>
<li>ContextStoppedEvent</li>
<li>ContextClosedEvent</li>
<li>RequestHandledEvent</li>
</ul>
<h4 id="ResouceLoader"><a href="#ResouceLoader" class="headerlink" title="ResouceLoader"></a>ResouceLoader</h4><p> : 리소스를 읽어오는 기능을 제공하는 인터페이스  </p>
<p> Resource getResource(String location);</p>
<p> 파일시스템에서 읽어오기<br> 클래스패스에서 읽어오기(target/classes) getResource(“classpath:test.txt”);<br>    resources에 있는 파일들이 빌드될 때 클래스패스에 들어가게 된다.<br> URL로 읽어오기<br> 상대/절대 경로로 읽어오기</p>
]]></content>
      <categories>
        <category>Study</category>
        <category>Spring Framework</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>AOP (Aspect Oriented Programming)</title>
    <url>/2020/08/15/hexo_spring_project_3/</url>
    <content><![CDATA[<h2 id="AOP-Aspect-Oriented-Programming"><a href="#AOP-Aspect-Oriented-Programming" class="headerlink" title="AOP (Aspect Oriented Programming)"></a>AOP (Aspect Oriented Programming)</h2><p>흩어진 Concern을 Aspect로 모듈화 할 수 있는 프로그래밍 기법이다.<br>AOP의 핵심은 흩어진 코드(여러 곳에서 반복되는 코드)를 한 곳으로 모으는 것.<br>AOP의 구현체로 AspectJ와 스프링 AOP가 있다.  </p>
<p>Concern(여러 경로에 흩어져 있는 비슷한 코드)의 변경이 있을때<br>Concern들을 Aspect로 모아서 Aspect만 변경함으로서<br>모든 경로에서 각각 따로 변경해줘야 하는 번거로움을 방지해준다.  </p>
<h4 id="AOP-주요-개념"><a href="#AOP-주요-개념" class="headerlink" title="AOP 주요 개념"></a>AOP 주요 개념</h4><p>Aspect : 모아진 코드와 정보 집합 모듈<br>Advice : 구현될 기능<br>PointCut : 어디에 적용되는지의 정보<br>Target : 적용이 되는 대상<br>Join Point : 생성자 호출 직전/직후, 메서드 호출시 등등 적용 가능한 시점</p>
<h4 id="AOP-적용-방법"><a href="#AOP-적용-방법" class="headerlink" title="AOP 적용 방법"></a>AOP 적용 방법</h4><p>AspectJ<br>컴파일 타임 : 자바파일을 class 파일로 만들 때, 추가 컴파일링 필요<br>로딩 타임 : class 로딩 시점, java agent 로드타임위버 설정 필요<br>Spring AOP (쉽고 현실적임)<br>런 타임 : A 빈이 만들어질때 A 타입의 proxy 빈을 만들어서 proxy 빈이 Advice를 먼저 호출  </p>
<p>대표적으로 @Transactional 어노테이션이 있는데,<br>트랜잭션 처리(트랜잭션 시작, 커밋/롤백)에 대한 동일한 부분을 어노테이션 하나로 처리한다.<br>참고로 JPA Repository의 모든 메서드에는 @Transactional이 생략되어 적용되어있다.  </p>
<h4 id="스프링-AOP"><a href="#스프링-AOP" class="headerlink" title="스프링 AOP"></a>스프링 AOP</h4><p>프록시 기반의 AOP 구현체이며 스프링 빈에만 적용할 수 있다.  </p>
<p>프록시 패턴은 주로 접근 제어 또는 부가기능을 추가하기 위해 사용한다.  </p>
<ol>
<li>프록시는 Real Subject와 같은 인터페이스를 구현하고(같은 타입) Real Subject를 의존한다.    </li>
<li>프록시에만 부가기능을 추가하고 Real Subject는 변경하지 않는다.  </li>
<li>사용자는 부가기능이 구현된 프록시를 사용한다.</li>
</ol>
<p>이때, 프록시를 작성하는 어려움이나 반복적인 코드, 그리고 객체들 사이의 복잡한 관계 등 문제가 발생하는데  </p>
<p>스프링 AOP는 스프링 IoC 컨테이너가 제공하는 기반시설과<br>런 타임 시점에 동적으로 프록시를 만들어 주는 기능(Dynamic Proxy)을 사용하여 이런 문제를 해결한다.  </p>
<p>스프링 IoC 컨테이너의 AbstractAutoProxyCreator(implements BeanPostProcessor)에 의하여<br>기존 빈을 대체하는 프록시를 동적으로 생성하고 프록시를 기존 빈 대신에 컨테이너에 등록한다.  </p>
<p>Aspect 정의<br>Pointcut과 Advice의 정보가 필요하다.  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Component &#x2F;&#x2F;Aspect Bean 이어야 한다.</span><br><span class="line">@Aspect</span><br><span class="line">public class PerfAspect &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;Advice 생성</span><br><span class="line">    @Around(&quot;execution(* kr.co.testproject..*.EventService.*(..))&quot;) </span><br><span class="line">    &#x2F;&#x2F;Advice는 @Around 어노테이션이 붙어야 하고 값으로 pointcut을 이름으로 적용하거나 또는 직접 정의할 수 있다.</span><br><span class="line">    &#x2F;&#x2F;표현식을 사용할 수 있다. </span><br><span class="line">    public Object logPerf(ProceedingJoinPoint pjp) throws Throwable &#123; </span><br><span class="line">    &#x2F;&#x2F;ProceedingJoinPoint는 적용될 메소드라고 보면 된다.</span><br><span class="line">        long begin &#x3D; System.currentTimeMillis();</span><br><span class="line">        Object retVal &#x3D; pjp.proceed(); &#x2F;&#x2F;메소드 호출</span><br><span class="line">        System.out.println(System.currentTimeMillis() - begin);</span><br><span class="line">        return retVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>또는 어노테이션으로 pointcut을 정의할 수 있는데<br>먼저 어노테이션을 생성하고</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Target(ElementType.METHOD) &#x2F;&#x2F; 이 어노테이션은 메서드에 붙일것이다라고 명시.  </span><br><span class="line">@Retention(RetentionPolicy.CLASS) &#x2F;&#x2F; 어노테이션 정보를 유지할 기간, AOP는 CLASS 이상으로 사용해야 한다.  </span><br><span class="line">public @interface PerfLogging &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Aspect의 @Around에서 execution 대신 어노테이션 표현식을 사용한다.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Around(&quot;@annotation(PerfLogging)&quot;) </span><br><span class="line">&#x2F;&#x2F;@PerfLogging 어노테이션이 붙은 메서드가 pointcut이 된다.</span><br></pre></td></tr></table></figure>

<p>또는 특정 Bean에 적용</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Around(&quot;bean(simpleEventService)&quot;) </span><br><span class="line">&#x2F;&#x2F;@PerfLogging 어노테이션이 붙은 메서드가 pointcut이 된다.</span><br></pre></td></tr></table></figure>

<p>단순히 메서드 실행 기준 특정 시점에만 부가기능이 있는 경우에는<br>@Around 대신 @Before, @AfterReturning, @AfterThrowing를 사용해도 된다.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Before(&quot;bean(simpleEventService)&quot;)</span><br></pre></td></tr></table></figure>


<h4 id="스프링-AOP-활용하기-예시"><a href="#스프링-AOP-활용하기-예시" class="headerlink" title="스프링 AOP 활용하기 예시"></a>스프링 AOP 활용하기 예시</h4><p>Annotation 생성</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Target(ElementType.METHOD)  </span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)  </span><br><span class="line">public @interface LogExecutionTime &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>실제 Aspect 생성</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">@Aspect</span><br><span class="line">public class LogAspect &#123;</span><br><span class="line">	Logger logger &#x3D; LoggerFactory.getLogger(LogAspect.class);</span><br><span class="line"></span><br><span class="line">	@Around(&quot;@annotation(LogExecutionTime)&quot;)</span><br><span class="line">	public Object logExecutionTime(ProceedingJoinPoint joinPoint) throws Throwable &#123;</span><br><span class="line">		StopWatch stopWatch &#x3D; new StopWatch();</span><br><span class="line">		stopWatch.start();</span><br><span class="line"></span><br><span class="line">		Object proceed &#x3D; joinPoint.proceed();</span><br><span class="line"></span><br><span class="line">		stopWatch.stop();</span><br><span class="line">		logger.info(stopWatch.prettyPrint());</span><br><span class="line"></span><br><span class="line">		return proceed;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Annotation 달기</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@LogExecutionTime</span><br><span class="line">@GetMapping(&quot;&#x2F;owners&#x2F;find&quot;)</span><br><span class="line">public String initFindForm(Map&lt;String, Object&gt; model) &#123;</span><br><span class="line">	model.put(&quot;owner&quot;, new Owner());</span><br><span class="line">	return &quot;owners&#x2F;findOwners&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>결과적으로, AOP를 통하여 하나의 클래스(Aspect)로<br>Annotation이 달려있는 모든 메서드는 수행 시간이 계산된다.  </p>
]]></content>
      <categories>
        <category>Study</category>
        <category>Spring Framework</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>PSA (Portable Service Abstraction)</title>
    <url>/2020/08/15/hexo_spring_project_4/</url>
    <content><![CDATA[<h2 id="PSA-Portable-Service-Abstraction"><a href="#PSA-Portable-Service-Abstraction" class="headerlink" title="PSA (Portable Service Abstraction)"></a>PSA (Portable Service Abstraction)</h2><p>이미 잘 만들어진 인터페이스를 사용하는 것.<br>확장성이 좋지 못한 코드 또는 기술에 특화되어 있는 코드에 사용하면 좋다.</p>
<p>Spring Framework이 제공하는 API는 대부분이 추상화되어있다.  </p>
<hr>
<h4 id="추상화-예제"><a href="#추상화-예제" class="headerlink" title="추상화 예제"></a>추상화 예제</h4><ul>
<li><p>스프링 트랜잭션<br>@Transactional 어노테이션의 Aspect는 PlatformTransactionManager 인터페이스를 사용하여 코딩되어 있는데,<br>그렇기 때문에 PlatformTransactionManager에 대한 구현체<br>(JpaTransactionManager, DatasourceTransactionManager, HibernateTransactionManager 등)가 바뀌더라도<br>@Transactional Aspect의 코드가 변경될 필요가 없다.  </p>
</li>
<li><p>스프링 캐시<br>@Cacheable / @CacheEvict 등 스프링 캐시 관련 어노테이션의 Aspect는<br>CacheManager 인터페이스를 사용하여 코딩되어있으며,<br>위와 동일하게 구현체가 바뀌더라도 Aspect 코드는 변경될 필요가 없다.</p>
</li>
<li><p>스프링 웹 MVC<br>@Controller / @RequestMapping 등 스프링 웹 MVC 관련 어노테이션은<br>의존성에 따라 Servlet을 사용할 수도 있고 Reactive를 사용할 수도 있다.<br>고로, 해당 어노테이션을 사용한 나의 코드는 변경하기 쉽거나 변경되지 않아도 된다.  </p>
</li>
</ul>
]]></content>
      <categories>
        <category>Study</category>
        <category>Spring Framework</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>01. What, How, Hello world</title>
    <url>/2020/08/12/hexo_springboot_1_01/</url>
    <content><![CDATA[<h1 id="스프링-부트-프로젝트"><a href="#스프링-부트-프로젝트" class="headerlink" title="스프링 부트 프로젝트"></a>스프링 부트 프로젝트</h1><h3 id="레스토랑-예약-사이트-만들기"><a href="#레스토랑-예약-사이트-만들기" class="headerlink" title="레스토랑 예약 사이트 만들기"></a>레스토랑 예약 사이트 만들기</h3><h4 id="01-What-How-Hello-world"><a href="#01-What-How-Hello-world" class="headerlink" title="01. What, How, Hello world"></a>01. What, How, Hello world</h4><ul>
<li><p>무엇을 만들 것인가<br>프로그래밍은 프로그램을 만드는 것이며, 이는 문제를 해결하는 것이다.<br>무엇을 만들 것인가의 시작은 무엇이 문제인가로부터 시작된다.   </p>
</li>
<li><p>사용자 스토리<br>사용자 입장에서 프로그램의 기능을 서술한 것<br>(사용자)는 (가치)를 위해 (기능)을 할 수 있다.<br>ex) &lt;고객&gt;은 &lt;뭘 먹고 싶은지 발견&gt;할 수 있도록 &lt;가게 목록을 볼&gt; 수 있다.</p>
</li>
<li><p>계획을 세워야 한다<br>사용자 스토리 기반에서 어떤 순서로 개발할 것인지 세운다.<br>계획을 세워두면 변경이 있을 떄 얼마나 기간이 늘어날 지, 또는 어떤 것을 포기할지 선택하는 기준이 된다.      </p>
</li>
<li><p>어떻게 만들 것인가<br>도메인 모델링 : 해결하려는 문제에서 쓰이는 개념들을 정의하고 필요한 것을 알아보는것<br>모델 : 가게, 메뉴 정보, 사용자, 즐겨찾기 정보, 리뷰 정보, 예약 정보<br>시스템 아키텍쳐 : 시스템의 구성, 제약 조건을 알아야 한다.<br>제약 조건 : 홈페이지를 통해 서비스(Web), 모바일(Mobile App)<br>3-tier Architecture : 가장 흔하게 쓰이는 시스템 아키텍쳐<br>Presentation : 사용자와 소통하는 부분 (Front-end|HTML,CSS,JS)<br>Business : 소통의 결과, 사용자 요청 처리 등 (Back-end|Rest API)<br>Data source : 처리된 데이터가 저장되는 곳 (Database|DBMS)    </p>
</li>
<li><p>Back-end를 어떻게 만들 것인가<br>Layered Architecture (4개의 층으로 구성됨)  </p>
<blockquote>
<p>UI Layer    </p>
<blockquote>
<p>Application Layer   </p>
<blockquote>
<p>Domain Layer    </p>
<blockquote>
<p>Infrastructure Layer</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>  각 레이어는 아래의 레이어에 의존하고 위의 레이어를 사용하지 않는다.    </p>
</li>
<li><p>기술 선택<br>JAVA, Spring Boot, Rest API     </p>
</li>
<li><p>프로젝트 생성<br>스프링 부트 프로젝트 생성 (Spring Initailizer 이용)<br><a href="https://spring.io/" target="_blank" rel="noopener">Spring Home page</a> &gt; Projects &gt; Spring Boot &gt; Quickstart &gt; 여러 선택 후 GENERATE &gt; IDEA에서 open</p>
</li>
</ul>
<p>UI 레이어를 위한 interfaces 패키지 추가 및 Welcome 컨트롤러 생성    </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package kr.co.fastcampus.eatgo.interfaces;</span><br><span class="line"></span><br><span class="line">import org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line">@RestController &#x2F;&#x2F;웹에서 접속 가능한 컨트롤러 어노테이션</span><br><span class="line">public class WelcomController &#123;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;&#x2F;&quot;) &#x2F;&#x2F;Get: http에서 접속하는데 쓰는 기본적인 4가지 메소드중 하나</span><br><span class="line">    public String hello() &#123;</span><br><span class="line">        return &quot;Hello, world!!!&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Study</category>
        <category>Spring Boot Project</category>
      </categories>
      <tags>
        <tag>spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title>05. Test Driven Development(TDD)</title>
    <url>/2020/08/12/hexo_springboot_1_05/</url>
    <content><![CDATA[<h1 id="스프링-부트-프로젝트"><a href="#스프링-부트-프로젝트" class="headerlink" title="스프링 부트 프로젝트"></a>스프링 부트 프로젝트</h1><h3 id="레스토랑-예약-사이트-만들기"><a href="#레스토랑-예약-사이트-만들기" class="headerlink" title="레스토랑 예약 사이트 만들기"></a>레스토랑 예약 사이트 만들기</h3><h4 id="05-Test-Driven-Development-TDD"><a href="#05-Test-Driven-Development-TDD" class="headerlink" title="05. Test Driven Development(TDD)"></a>05. Test Driven Development(TDD)</h4><p>테스트 주도 개발<br>목표 주도 개발<br>사용자 중심 개발<br>인터페이스 중심 개발     </p>
<p>TDD를 하는 이유는 올바르게 작동하는 깔끔한 코드 작성을 위함<br>Refactoring : 작동은 그대로 둔 상태로 코드만 바꾸는 것<br>Refactoring을 위해서는 올바르게 작동한다는 것을 보장해 줄 Test 코드가 필요하다.<br>TDD의 핵심은 Test 코드를 먼저 작성하는 것이다.  </p>
<p>TDD 사이클<br>Red : 실패하는 테스트<br>Green : 성공하는 테스트<br>Refactoring : 테스트는 그대로인 상태에서 내부 구현을 변경  </p>
<p>Demo<br>레스토랑 모델 생성</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package kr.co.fastcampus.eatgo.domain;</span><br><span class="line"></span><br><span class="line">public class Restourant &#123;</span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return &quot;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>레스토랑 테스트 생성</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package kr.co.fastcampus.eatgo.domain;</span><br><span class="line"></span><br><span class="line">import org.junit.Test;</span><br><span class="line"></span><br><span class="line">import static org.hamcrest.CoreMatchers.is;</span><br><span class="line">import static org.junit.Assert.*;</span><br><span class="line"></span><br><span class="line">public class RestaurantTests &#123;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void creation() &#123;</span><br><span class="line">        Restourant restaurant &#x3D; new Restaurant();</span><br><span class="line">        assertThat(restaurant.getName(), is(&quot;Bob zip&quot;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>테스트 실패 내역이 출력된다.(Red)<br>(“Bob zip”을 기대했지만 값은 “”이다.)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Expected: is &quot;Bob zip&quot;</span><br><span class="line">     but: was &quot;&quot;</span><br><span class="line">Expected :Bob zip</span><br><span class="line">Actual   :</span><br><span class="line">&lt;Click to see difference&gt;</span><br></pre></td></tr></table></figure>

<p>=&gt; 성공 하도록 코딩 (Green)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package kr.co.fastcampus.eatgo.domain;</span><br><span class="line"></span><br><span class="line">public class Restourant &#123;</span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return &quot;Bob zip&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Red,Green에서 이 모델을 어떻게 사용할 것인지 먼저 정의<br>실제 구현은 그 다음 Refactoring</p>
<p>=&gt; 실제 구현 (Refactoring)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package kr.co.fastcampus.eatgo.domain;</span><br><span class="line"></span><br><span class="line">public class Restourant &#123;</span><br><span class="line">    private final String name;</span><br><span class="line">    private final String address;</span><br><span class="line"></span><br><span class="line">    public Restourant(String name, String address) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">        this.address &#x3D; address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getAddress() &#123;</span><br><span class="line">        return address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getInformation() &#123;</span><br><span class="line">        return name+&quot; in &quot;+address;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Study</category>
        <category>Spring Boot Project</category>
      </categories>
      <tags>
        <tag>spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title>06. REST API</title>
    <url>/2020/08/12/hexo_springboot_1_06/</url>
    <content><![CDATA[<h1 id="스프링-부트-프로젝트"><a href="#스프링-부트-프로젝트" class="headerlink" title="스프링 부트 프로젝트"></a>스프링 부트 프로젝트</h1><h3 id="레스토랑-예약-사이트-만들기"><a href="#레스토랑-예약-사이트-만들기" class="headerlink" title="레스토랑 예약 사이트 만들기"></a>레스토랑 예약 사이트 만들기</h3><h4 id="06-REST-API"><a href="#06-REST-API" class="headerlink" title="06. REST API"></a>06. REST API</h4><p>다양한 환경(Web, Mobile)을 지원하려면,<br>서로 다른 Front-end로 구성되어야 한다.<br>대신 공통으로 사용하는 기능들은 하나의 Back-end를 통해 제공한다.    </p>
<p>이때 Back-end를 만드는 기술이 Rest API.  </p>
<p>REST(REpresentational State Transfer)<br>표현 상태 전달, 곧 Resource를 처리하는 방식을 의미한다.</p>
<p>Resource의 처리 방식은 4가지(CRUD)<br>CRUD와 http의 표준 4가지 메서드와 연결<br>Create &gt; POST<br>Read &gt; GET<br>Update &gt; PUT/PATCH<br>Delete &gt; DELETE     </p>
<p>URI(Uniform Resource Identifier)<br>리소스를 지정할 때 사용하는 식별자(resource 식별)<br>URL(Uniform Resource Locator)<br>리소스를 지정할 때 사용하는 지시자(resource 위치)   </p>
<p>리소스의 분류<br>1.Collection<br>2.Member    </p>
<ul>
<li><p>Collection : 여러 리소스 목록<br>Read(List), Create</p>
</li>
<li><p>Member : 개별 리소스<br>Read(Detail), Update, Delete</p>
</li>
</ul>
<p>Collection 표현 : <a href="http://hostname/restorants" target="_blank" rel="noopener">http://hostname/restorants</a><br>Member표현 : <a href="http://hostname/restorants/{id}" target="_blank" rel="noopener">http://hostname/restorants/{id}</a>, {id} : 개별 리소스의 id   </p>
<p>JSON(JavaScript Object Notation)<br>결과를 받거나 넘길때 사용되는 포맷<br>자바 스크립트에서 오브젝를 표현할때 쓰는 방식을 여러 언어 또는 환경에서 표준으로 사용할 수 있음  </p>
<p>JSON 에서 Member 표현</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;id&quot;:2019,</span><br><span class="line">&quot;name&quot;:&quot;식당&quot;,</span><br><span class="line">&quot;address&quot;:&quot;골목&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JSON 에서 Collection 표현</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">&#123;</span><br><span class="line">&quot;id&quot;:2001,</span><br><span class="line">&quot;name&quot;:&quot;오디세이&quot;,</span><br><span class="line">&quot;address&quot;:&quot;우주&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">&quot;id&quot;:2019,</span><br><span class="line">&quot;name&quot;:&quot;식당&quot;,</span><br><span class="line">&quot;address&quot;:&quot;골목&quot;</span><br><span class="line">&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>APIs를 Rest API에 맞춰 정의하기<br>가게 목록 얻기(read Collection)<br>GET /restaurants<br>개별 가게 정보 얻기(read Member)<br>GET /restaurants/{id}<br>가게 추가(create Collection)<br>POST /restaurants<br>가게 수정(update Member)<br>PATCH /restaurants/{id}<br>가게 삭제(delete Member)<br>DELETE /restaurants/{id}    </p>
]]></content>
      <categories>
        <category>Study</category>
        <category>Spring Boot Project</category>
      </categories>
      <tags>
        <tag>spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title>10. 의존성 주입 (DI)</title>
    <url>/2020/08/12/hexo_springboot_1_10/</url>
    <content><![CDATA[<h1 id="스프링-부트-프로젝트"><a href="#스프링-부트-프로젝트" class="headerlink" title="스프링 부트 프로젝트"></a>스프링 부트 프로젝트</h1><h3 id="레스토랑-예약-사이트-만들기"><a href="#레스토랑-예약-사이트-만들기" class="headerlink" title="레스토랑 예약 사이트 만들기"></a>레스토랑 예약 사이트 만들기</h3><h4 id="10-의존성-주입-DI"><a href="#10-의존성-주입-DI" class="headerlink" title="10. 의존성 주입 (DI)"></a>10. 의존성 주입 (DI)</h4><p>의존성 주입 (Dependency injection)   </p>
<p>의존성 : 의존 관계, 둘 이상의 객체가 서로 협력하는 방법에 대한 것<br>ex1) A는 B에 의존 =&gt; A가 B를 사용한다 =&gt; B의 변화가 A에 영향을 끼친다 =&gt; 효과적인 관리가 필요하다<br>ex2) RestaurantController는 RestaurantRepository에 의존한다.  </p>
<p>레스토랑 컨트롤러에서 저장소 객체를 생성하고 멤버변수로 사용했었는데,<br>이런 작업을 다른 곳에서 할수 있다.<br>=&gt; Spring IOC Container</p>
<p>DI는 이런 객체간의 의존 관계를 Spring이 직접 관리해주도록 하는 것<br>DI를 위해 두가지 어노테이션을 지원한다.<br>@Component<br>@Autowired  </p>
<p>Demo<br>Repository  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Component &#x2F;&#x2F;Spring이 직접 관리하도록</span><br><span class="line">public class RestaurantRepository &#123;</span><br><span class="line">~</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Controller  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RestController </span><br><span class="line">public class RestaurantController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired &#x2F;&#x2F;Spring이 알아서 객체를 생성해서 멤버변수에 넣어준다.</span><br><span class="line">    private RestaurantRepository repository;</span><br><span class="line"></span><br><span class="line">~</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>주의해야 할 것은 WebMvcTest에서 제대로 사용되지 못하기 때문에<br>직접 의존성 주입을 해야할 필요가 있다   </p>
<p>Controller Test     </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RunWith(SpringRunner.class) </span><br><span class="line">@WebMvcTest(RestaurantController.class)</span><br><span class="line">public class RestaurantControllerTest &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private MockMvc mvc;</span><br><span class="line"></span><br><span class="line">    @SpyBean &#x2F;&#x2F;WebMvcTest에서는 제대로된 저장소를 사용할수 없기때문에 직접 의존성 주입</span><br><span class="line">    private RestaurantRepository restaurantRepository;</span><br><span class="line"></span><br><span class="line">~</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>의존성 주입을 통해 얻을 수 있는 이점은<br>객체 간의 의존성을 좀더 유연하게 해준다.<br>예를 들어 저장소를 interface로 만들어 의존성 주입을 하면<br>여러 구현체를 만들수 있고 얼마든지 다른 형태로 변경할 수 있다.<br>(Controller가 직접적으로 저장소에 의존하고 있던 것을 분리할 수 있다.)     </p>
<p>저장소  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package kr.co.fastcampus.eatgo.domain;</span><br><span class="line"></span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public interface RestaurantRepository &#123;</span><br><span class="line">    List&lt;Restaurant&gt; findAll();</span><br><span class="line"></span><br><span class="line">    Restaurant findById(Long id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>구현체</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package kr.co.fastcampus.eatgo.domain;</span><br><span class="line"></span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">@Component &#x2F;&#x2F;Spring이 직접 관리하도록</span><br><span class="line">public class RestaurantRepositoryImpl implements RestaurantRepository &#123;</span><br><span class="line"></span><br><span class="line">~</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Controller</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class RestaurantController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired </span><br><span class="line">    private RestaurantRepository repository; &#x2F;&#x2F;구현체가 아닌 인터페이스를 사용할 수 있다  </span><br><span class="line"></span><br><span class="line">~</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>주의해야 할 것은 SpyBean에서 실질적인 구현이 없는것은 사용할 수 없으므로<br>어떤 구현을 사용할 것인지 입력해주어야 한다.   </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RunWith(SpringRunner.class) </span><br><span class="line">@WebMvcTest(RestaurantController.class) </span><br><span class="line">public class RestaurantControllerTest &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private MockMvc mvc;</span><br><span class="line"></span><br><span class="line">    @SpyBean(RestaurantRepositoryImpl.class) &#x2F;&#x2F;어떤 구현체를 사용할 것인지 입력해줘야 한다     </span><br><span class="line">    private RestaurantRepository restaurantRepository;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Study</category>
        <category>Spring Boot Project</category>
      </categories>
      <tags>
        <tag>spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title>07. 가게 목록, 가게 상세</title>
    <url>/2020/08/12/hexo_springboot_1_07/</url>
    <content><![CDATA[<h1 id="스프링-부트-프로젝트"><a href="#스프링-부트-프로젝트" class="headerlink" title="스프링 부트 프로젝트"></a>스프링 부트 프로젝트</h1><h3 id="레스토랑-예약-사이트-만들기"><a href="#레스토랑-예약-사이트-만들기" class="headerlink" title="레스토랑 예약 사이트 만들기"></a>레스토랑 예약 사이트 만들기</h3><h4 id="07-가게-목록-가게-상세"><a href="#07-가게-목록-가게-상세" class="headerlink" title="07. 가게 목록, 가게 상세"></a>07. 가게 목록, 가게 상세</h4><p>가게 목록 Demo<br>Controller  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package kr.co.fastcampus.eatgo.interfaces;</span><br><span class="line"></span><br><span class="line">import kr.co.fastcampus.eatgo.domain.Restaurant;</span><br><span class="line">import org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">@RestController &#x2F;&#x2F;Rest API 를 사용하는 컨트롤러 임을 명시</span><br><span class="line">public class RestaurantController &#123;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;&#x2F;restaurants&quot;)</span><br><span class="line">    public List&lt;Restaurant&gt; list() &#123;</span><br><span class="line">        List&lt;Restaurant&gt; restaurants &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        Restaurant restaurant &#x3D; new Restaurant(1004l, &quot;Bob zip&quot;,&quot;Seoul&quot;);</span><br><span class="line">        restaurants.add(restaurant);</span><br><span class="line">        &#x2F;&#x2F;웹에서 출력은 아래와 같다    </span><br><span class="line">        &#x2F;&#x2F;[&#123;&quot;name&quot;:&quot;Bob zip&quot;,&quot;address&quot;:&quot;Seoul&quot;,&quot;id&quot;:1004,&quot;information&quot;:&quot;Bob zip in Seoul&quot;&#125;]</span><br><span class="line">        return restaurants;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Controller TEST</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package kr.co.fastcampus.eatgo.interfaces;</span><br><span class="line"></span><br><span class="line">import org.junit.Test;</span><br><span class="line">import org.junit.runner.RunWith;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;</span><br><span class="line">import org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line">import org.springframework.test.web.servlet.MockMvc;</span><br><span class="line">import org.springframework.test.web.servlet.request.MockMvcRequestBuilders;</span><br><span class="line"></span><br><span class="line">import static org.hamcrest.core.StringContains.containsString;</span><br><span class="line">import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;</span><br><span class="line">import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;</span><br><span class="line"></span><br><span class="line">@RunWith(SpringRunner.class) &#x2F;&#x2F;spring을 이용하여 테스트 실행</span><br><span class="line">@WebMvcTest(RestaurantController.class) &#x2F;&#x2F;특정 컨트롤러를 테스트한다고 명시</span><br><span class="line">public class RestaurantControllerTest &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired &#x2F;&#x2F;spring에서 알아서 넣어줄 수 있도록</span><br><span class="line">    private MockMvc mvc; &#x2F;&#x2F;spring mvc 테스트를 위한 객체    </span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void list() throws Exception &#123;</span><br><span class="line">        mvc.perform(MockMvcRequestBuilders.get(&quot;&#x2F;restaurants&quot;))</span><br><span class="line">                .andExpect(status().isOk())</span><br><span class="line">                .andExpect(content().string(</span><br><span class="line">                        containsString(&quot;\&quot;id\&quot;:1004&quot;)</span><br><span class="line">                ))</span><br><span class="line">                .andExpect(content().string(</span><br><span class="line">                        containsString(&quot;\&quot;name\&quot;:\&quot;Bob zip\&quot;&quot;)</span><br><span class="line">                ));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>가게 상세 Demo<br>가게 저장소 생성 in domain   </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package kr.co.fastcampus.eatgo.domain;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public class RestaurantRepository &#123;</span><br><span class="line">    List&lt;Restaurant&gt; restaurants &#x3D; new ArrayList&lt;&gt;(); &#x2F;&#x2F;가게마다 if문을 쓰지 않기 위해 List로 가게 관리</span><br><span class="line">                                                      &#x2F;&#x2F;여러 메서드에서 사용될 수 있도록 멤버변수로    </span><br><span class="line"></span><br><span class="line">    public RestaurantRepository() &#123;</span><br><span class="line">        restaurants.add(new Restaurant(1004L,&quot;Bob zip&quot;,&quot;Seoul&quot;));</span><br><span class="line">        restaurants.add(new Restaurant(2020L,&quot;Cyber Food&quot;,&quot;Seoul&quot;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public List&lt;Restaurant&gt; findAll() &#123;</span><br><span class="line">        return restaurants;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Restaurant findById(Long id) &#123;   &#x2F;&#x2F;찾는 기능을 UI에 구현하지 않고 저장소에서 구현    </span><br><span class="line">        return restaurants.stream()</span><br><span class="line">                .filter(r -&gt; r.getId().equals(id))</span><br><span class="line">                .findFirst()</span><br><span class="line">                .orElse(null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Controller</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package kr.co.fastcampus.eatgo.interfaces;</span><br><span class="line"></span><br><span class="line">import kr.co.fastcampus.eatgo.domain.Restaurant;</span><br><span class="line">import kr.co.fastcampus.eatgo.domain.RestaurantRepository;</span><br><span class="line">import org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">@RestController &#x2F;&#x2F;Rest API 를 사용하는 컨트롤러 임을 명시</span><br><span class="line">public class RestaurantController &#123;</span><br><span class="line"></span><br><span class="line">    private RestaurantRepository repository &#x3D; new RestaurantRepository(); &#x2F;&#x2F;저장소 객체 선언</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;UI 레이어는 사용자와 내부의 비즈니스 로직, 도메인 모델들이 서로 상관 없도록 중간 다리 역할만 하는 것이 좋다</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;&#x2F;restaurants&quot;)</span><br><span class="line">    public List&lt;Restaurant&gt; list() &#123;</span><br><span class="line"></span><br><span class="line">        List&lt;Restaurant&gt; restaurants &#x3D; repository.findAll(); &#x2F;&#x2F;API들의 중복제거를 위해 가게 저장소 사용</span><br><span class="line">        return restaurants;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;&#x2F;restaurants&#x2F;&#123;id&#125;&quot;) &#x2F;&#x2F;&#123;&#125;로 바뀌는 부분을 매핑가능</span><br><span class="line">    public Restaurant detail(@PathVariable(&quot;id&quot;) Long id) &#123; &#x2F;&#x2F;주소의 파라미터를 활용할 수 있음</span><br><span class="line"></span><br><span class="line">        Restaurant restaurant &#x3D; repository.findById(id); &#x2F;&#x2F;저장소에서 기능을 생성하여 사용</span><br><span class="line">        return restaurant;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Controller Test</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package kr.co.fastcampus.eatgo.interfaces;</span><br><span class="line"></span><br><span class="line">import org.junit.Test;</span><br><span class="line">import org.junit.runner.RunWith;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;</span><br><span class="line">import org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line">import org.springframework.test.web.servlet.MockMvc;</span><br><span class="line">import org.springframework.test.web.servlet.request.MockMvcRequestBuilders;</span><br><span class="line"></span><br><span class="line">import static org.hamcrest.core.StringContains.containsString;</span><br><span class="line">import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;</span><br><span class="line">import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;</span><br><span class="line"></span><br><span class="line">@RunWith(SpringRunner.class) &#x2F;&#x2F;spring을 이용하여 테스트 실행</span><br><span class="line">@WebMvcTest(RestaurantController.class) &#x2F;&#x2F;특정 컨트롤러를 테스트한다고 명시</span><br><span class="line">public class RestaurantControllerTest &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired &#x2F;&#x2F;spring에서 알아서 넣어줄 수 있도록</span><br><span class="line">    private MockMvc mvc;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void list() throws Exception &#123;</span><br><span class="line">        mvc.perform(MockMvcRequestBuilders.get(&quot;&#x2F;restaurants&quot;))</span><br><span class="line">                .andExpect(status().isOk())</span><br><span class="line">                .andExpect(content().string(</span><br><span class="line">                        containsString(&quot;\&quot;id\&quot;:1004&quot;)</span><br><span class="line">                ))</span><br><span class="line">                .andExpect(content().string(</span><br><span class="line">                        containsString(&quot;\&quot;name\&quot;:\&quot;Bob zip\&quot;&quot;)</span><br><span class="line">                ));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void detail() throws Exception &#123;</span><br><span class="line">        mvc.perform(MockMvcRequestBuilders.get(&quot;&#x2F;restaurants&#x2F;1004&quot;))</span><br><span class="line">                .andExpect(status().isOk())</span><br><span class="line">                .andExpect(content().string(</span><br><span class="line">                        containsString(&quot;\&quot;id\&quot;:1004&quot;)</span><br><span class="line">                ))</span><br><span class="line">                .andExpect(content().string(</span><br><span class="line">                        containsString(&quot;\&quot;name\&quot;:\&quot;Bob zip\&quot;&quot;)</span><br><span class="line">                ));</span><br><span class="line">        mvc.perform(MockMvcRequestBuilders.get(&quot;&#x2F;restaurants&#x2F;2020&quot;))</span><br><span class="line">                .andExpect(status().isOk())</span><br><span class="line">                .andExpect(content().string(</span><br><span class="line">                        containsString(&quot;\&quot;id\&quot;:2020&quot;)</span><br><span class="line">                ))</span><br><span class="line">                .andExpect(content().string(</span><br><span class="line">                        containsString(&quot;\&quot;name\&quot;:\&quot;Cyber Food\&quot;&quot;)</span><br><span class="line">                ));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Study</category>
        <category>Spring Boot Project</category>
      </categories>
      <tags>
        <tag>spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title>11. 레이어 분리</title>
    <url>/2020/08/12/hexo_springboot_1_11/</url>
    <content><![CDATA[<h1 id="스프링-부트-프로젝트"><a href="#스프링-부트-프로젝트" class="headerlink" title="스프링 부트 프로젝트"></a>스프링 부트 프로젝트</h1><h3 id="레스토랑-예약-사이트-만들기"><a href="#레스토랑-예약-사이트-만들기" class="headerlink" title="레스토랑 예약 사이트 만들기"></a>레스토랑 예약 사이트 만들기</h3><h4 id="11-레이어-분리"><a href="#11-레이어-분리" class="headerlink" title="11. 레이어 분리"></a>11. 레이어 분리</h4><p>UI Layer는 interfaces 패키지로 분리하여 Controller를 저장했다.<br>Domain Layer는 domain 패키지로 분리하여 도메인 모델과 저장소를 저장했다.   </p>
<p>Application Layer를 중간에 추가할 것이다.<br>application 패키지 추가 및 MenuItem 도메인 모델 추가    </p>
<p>application이 없을때 menu를 사용하려면    </p>
<p>MenuItem Repository</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class MenuItemRepositoryImpl implements MenuItemRepository&#123;</span><br><span class="line"></span><br><span class="line">    private List&lt;MenuItem&gt; menuitems &#x3D; new ArrayList&lt;MenuItem&gt;();</span><br><span class="line">    </span><br><span class="line">    public MenuItemRepositoryImpl() &#123;</span><br><span class="line">        menuitems.add(new MenuItem(&quot;Kimchi&quot;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public List&lt;MenuItem&gt; findAllByRestaurantId(Long restaurantId) &#123;</span><br><span class="line">        return this.menuitems;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Controller</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Autowired &#x2F;&#x2F;Spring이 알아서 객체를 생성해서 멤버변수에 넣어준다.</span><br><span class="line">private RestaurantRepository restaurantRepository;</span><br><span class="line"></span><br><span class="line">@Autowired</span><br><span class="line">private MenuItemRepository menuItemRepository;</span><br><span class="line"></span><br><span class="line">@GetMapping(&quot;&#x2F;restaurants&#x2F;&#123;id&#125;&quot;) &#x2F;&#x2F;&#123;&#125;로 바뀌는 부분을 매핑가능</span><br><span class="line">public Restaurant detail(@PathVariable(&quot;id&quot;) Long id) &#123; &#x2F;&#x2F;주소의 파라미터를 활용할 수 있음</span><br><span class="line"></span><br><span class="line">    Restaurant restaurant &#x3D; restaurantRepository.findById(id); &#x2F;&#x2F;저장소에서 기능을 생성하여 사용</span><br><span class="line"></span><br><span class="line">    List&lt;MenuItem&gt; menuItems &#x3D; menuItemRepository.findAllByRestaurantId(id);</span><br><span class="line">    restaurant.setMenuItems(menuItems);</span><br><span class="line"></span><br><span class="line">    return restaurant;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>위처럼 Controller가 복잡해진다…<br>때문에 application layer를 추가해서 기능적인 부분을 분리한다.<br>하려고 하는것은 다음과 같다<br>application layer 역할을 해줄 RestaurantService 객체 생성<br>Service에서 구현된 기능을 Controller에서 사용<br>repository에 대한 의존성을 Service로 이관     </p>
<p>RestaurantService</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Service &#x2F;&#x2F;Spring에서 application으로 정의</span><br><span class="line">public class RestaurantService &#123;</span><br><span class="line">    &#x2F;&#x2F;의존성 연결을 Service에서 미리</span><br><span class="line">    @Autowired </span><br><span class="line">    private RestaurantRepository restaurantRepository;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private MenuItemRepository menuItemRepository;</span><br><span class="line">    </span><br><span class="line">    public RestaurantService(RestaurantRepository restaurantRepository, MenuItemRepository menuItemRepository) &#123;</span><br><span class="line">        this.restaurantRepository &#x3D; restaurantRepository;</span><br><span class="line">        this.menuItemRepository &#x3D; menuItemRepository;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;Controller에서 사용될 기능 구현    </span><br><span class="line">    public List&lt;Restaurant&gt; getRestaurants() &#123;</span><br><span class="line">        List&lt;Restaurant&gt; restaurants &#x3D; restaurantRepository.findAll();</span><br><span class="line">        return restaurants;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Restaurant getRestaurant(Long id) &#123;</span><br><span class="line">        &#x2F;&#x2F;가게 정보 </span><br><span class="line">        Restaurant restaurant &#x3D;  restaurantRepository.findById(id);</span><br><span class="line">        &#x2F;&#x2F;메뉴 정보 </span><br><span class="line">        List&lt;MenuItem&gt; menuItems &#x3D; menuItemRepository.findAllByRestaurantId(id);</span><br><span class="line">        restaurant.setMenuItems(menuItems);</span><br><span class="line"></span><br><span class="line">        return restaurant;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Controller 처럼 Service 또한 Test를 하자<br>Service Test    </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class RestaurantServiceTest &#123;</span><br><span class="line"></span><br><span class="line">    private RestaurantService restaurantService;</span><br><span class="line">    private RestaurantRepository restaurantRepository;</span><br><span class="line">    private MenuItemRepository menuItemRepository;</span><br><span class="line"></span><br><span class="line">    @Before &#x2F;&#x2F;모든 Test가 실행되기 전에 수행 됨</span><br><span class="line">    public void setUp() &#123;</span><br><span class="line">        restaurantRepository &#x3D; new RestaurantRepositoryImpl();</span><br><span class="line">        menuItemRepository &#x3D; new MenuItemRepositoryImpl();</span><br><span class="line">        restaurantService &#x3D; new RestaurantService(restaurantRepository,menuItemRepository);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void getRestaurants() &#123;</span><br><span class="line">        List&lt;Restaurant&gt; restaurants &#x3D; restaurantService.getRestaurants();</span><br><span class="line"></span><br><span class="line">        Restaurant restaurant &#x3D; restaurants.get(0);</span><br><span class="line">        assertThat(restaurant.getId(), is(1004L));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void getRestaurant() &#123;</span><br><span class="line">        Restaurant restaurant &#x3D; restaurantService.getRestaurant(1004L);</span><br><span class="line"></span><br><span class="line">        assertThat(restaurant.getId(), is(1004L));</span><br><span class="line"></span><br><span class="line">        MenuItem menuItem &#x3D; restaurant.getMenuItems().get(0);</span><br><span class="line"></span><br><span class="line">        assertThat(menuItem.getName(), is(&quot;Kimchi&quot;));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Controller가 단순화 된다.     </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class RestaurantController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired &#x2F;&#x2F;Service만 의존성 연결</span><br><span class="line">    private RestaurantService restaurantService;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;&#x2F;restaurants&quot;)</span><br><span class="line">    public List&lt;Restaurant&gt; list() &#123;</span><br><span class="line"></span><br><span class="line">        List&lt;Restaurant&gt; restaurants &#x3D; restaurantService.getRestaurants();</span><br><span class="line">        return restaurants;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;&#x2F;restaurants&#x2F;&#123;id&#125;&quot;)</span><br><span class="line">    public Restaurant detail(@PathVariable(&quot;id&quot;) Long id) &#123;</span><br><span class="line"></span><br><span class="line">        Restaurant restaurant &#x3D; restaurantService.getRestaurant(id); &#x2F;&#x2F;기본 정보 + 메뉴 정보를 가져올 새로운 메서드</span><br><span class="line">        &#x2F;&#x2F;repository가 저장소 역할을 했다면, 복잡한 처리들을 저장할 application layer</span><br><span class="line"></span><br><span class="line">        return restaurant;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Study</category>
        <category>Spring Boot Project</category>
      </categories>
      <tags>
        <tag>spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title>13. 가짜 객체</title>
    <url>/2020/08/12/hexo_springboot_1_13/</url>
    <content><![CDATA[<h1 id="스프링-부트-프로젝트"><a href="#스프링-부트-프로젝트" class="headerlink" title="스프링 부트 프로젝트"></a>스프링 부트 프로젝트</h1><h3 id="레스토랑-예약-사이트-만들기"><a href="#레스토랑-예약-사이트-만들기" class="headerlink" title="레스토랑 예약 사이트 만들기"></a>레스토랑 예약 사이트 만들기</h3><h4 id="13-가짜-객체"><a href="#13-가짜-객체" class="headerlink" title="13. 가짜 객체"></a>13. 가짜 객체</h4><p>의존성 주입이 너무 많이 된 경우,<br>테스트 하고자 하는 대상 외의 것들에 대한 의존성이 너무 커져서 테스트가 어려워지고<br>테스트를 진행하기 위해 의존하는 부분들을 모두 만들어줘야 한다.     </p>
<p>이때 사용할만한 것이 Mock Object.<br>Mock Object를 만들기 위해서 spring에서는 Mockito라는 framework 사용    </p>
<p>Spring은 기본적으로 POJO(Plain Old Java Object),<br>전통적인 자바 오브젝트를 사용할 것을 권장하고 지원한다. (=&gt;Mockito)  </p>
<p>Controller Test, MockBean</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RunWith(SpringRunner.class)</span><br><span class="line">@WebMvcTest(RestaurantController.class)</span><br><span class="line">public class RestaurantControllerTest &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private MockMvc mvc;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;Test하려는 대상은 RestaurantController 이므로 그 외의 대상을 가짜로 배치하려고 함</span><br><span class="line">    @MockBean</span><br><span class="line">    private RestaurantService restaurantService;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void list() throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;가짜 객체 생성, 가짜 처리 정의(willReturn)</span><br><span class="line">        &#x2F;&#x2F;실제 서비스, 저장소와는 무관하게 동작</span><br><span class="line">        List&lt;Restaurant&gt; restaurants &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        restaurants.add(new Restaurant(1004L,&quot;No Bob zip&quot;,&quot;Seoul&quot;));</span><br><span class="line">        given(restaurantService.getRestaurants()).willReturn(restaurants);</span><br><span class="line"></span><br><span class="line">        mvc.perform(MockMvcRequestBuilders.get(&quot;&#x2F;restaurants&quot;))</span><br><span class="line">                .andExpect(status().isOk())</span><br><span class="line">                .andExpect(content().string(</span><br><span class="line">                        containsString(&quot;\&quot;id\&quot;:1004&quot;)</span><br><span class="line">                ))</span><br><span class="line">                .andExpect(content().string(</span><br><span class="line">                        containsString(&quot;\&quot;name\&quot;:\&quot;No Bob zip\&quot;&quot;)</span><br><span class="line">                ));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void detail() throws Exception &#123;</span><br><span class="line">        Restaurant restaurant1 &#x3D; new Restaurant(1004L,&quot;No Bob zip&quot;,&quot;Seoul&quot;);</span><br><span class="line">        restaurant1.addMenuItem(new MenuItem(&quot;Kimchi&quot;));</span><br><span class="line">        given(restaurantService.getRestaurant(1004L)).willReturn(restaurant1);</span><br><span class="line"></span><br><span class="line">        Restaurant restaurant2 &#x3D; new Restaurant(2020L,&quot;Cyber Food&quot;,&quot;Seoul&quot;);</span><br><span class="line">        restaurant2.addMenuItem(new MenuItem(&quot;Kimchi&quot;));</span><br><span class="line">        given(restaurantService.getRestaurant(2020L)).willReturn(restaurant2);</span><br><span class="line"></span><br><span class="line">        mvc.perform(MockMvcRequestBuilders.get(&quot;&#x2F;restaurants&#x2F;1004&quot;))</span><br><span class="line">                .andExpect(status().isOk())</span><br><span class="line">                .andExpect(content().string(</span><br><span class="line">                        containsString(&quot;\&quot;id\&quot;:1004&quot;)</span><br><span class="line">                ))</span><br><span class="line">                .andExpect(content().string(</span><br><span class="line">                        containsString(&quot;\&quot;name\&quot;:\&quot;No Bob zip\&quot;&quot;)</span><br><span class="line">                ))</span><br><span class="line">                .andExpect(content().string(</span><br><span class="line">                        containsString(&quot;Kimchi&quot;)</span><br><span class="line">                ));</span><br><span class="line"></span><br><span class="line">        mvc.perform(MockMvcRequestBuilders.get(&quot;&#x2F;restaurants&#x2F;2020&quot;))</span><br><span class="line">                .andExpect(status().isOk())</span><br><span class="line">                .andExpect(content().string(</span><br><span class="line">                        containsString(&quot;\&quot;id\&quot;:2020&quot;)</span><br><span class="line">                ))</span><br><span class="line">                .andExpect(content().string(</span><br><span class="line">                        containsString(&quot;\&quot;name\&quot;:\&quot;Cyber Food\&quot;&quot;)</span><br><span class="line">                ));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Service Test, Mock, Mockito</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class RestaurantServiceTest &#123;</span><br><span class="line"></span><br><span class="line">    private RestaurantService restaurantService;</span><br><span class="line"></span><br><span class="line">    @Mock &#x2F;&#x2F;저장소를 가짜로 주입</span><br><span class="line">    private RestaurantRepository restaurantRepository;</span><br><span class="line">    @Mock</span><br><span class="line">    private MenuItemRepository menuItemRepository;</span><br><span class="line"></span><br><span class="line">    @Before &#x2F;&#x2F;모든 Test가 실행되기 전에 수행 됨</span><br><span class="line">    public void setUp() &#123;</span><br><span class="line">        MockitoAnnotations.initMocks(this); &#x2F;&#x2F;현재 Class의 Mock annotation이 붙어있는 곳에 객체 설정</span><br><span class="line"></span><br><span class="line">        mockRestaurantRepository();</span><br><span class="line">        mockMenuItemRepository();</span><br><span class="line"></span><br><span class="line">        restaurantService &#x3D; new RestaurantService(restaurantRepository,menuItemRepository);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void mockRestaurantRepository() &#123;</span><br><span class="line">        &#x2F;&#x2F;가짜 restaurant 생성</span><br><span class="line">        List&lt;Restaurant&gt; restaurants &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        Restaurant restaurant &#x3D; new Restaurant(1004L,&quot;Bob zip&quot;,&quot;Seoul&quot;);</span><br><span class="line">        restaurants.add(restaurant);</span><br><span class="line"></span><br><span class="line">        given(restaurantRepository.findAll()).willReturn(restaurants);</span><br><span class="line"></span><br><span class="line">        given(restaurantRepository.findById(1004L)).willReturn(restaurant);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void mockMenuItemRepository() &#123;</span><br><span class="line">        &#x2F;&#x2F;가짜 Menu Item 생성   </span><br><span class="line">        List&lt;MenuItem&gt; menuItems &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        MenuItem menuItem &#x3D; new MenuItem(&quot;Kimchi&quot;);</span><br><span class="line">        menuItems.add(menuItem);</span><br><span class="line"></span><br><span class="line">        given(menuItemRepository.findAllByRestaurantId(1004L)).willReturn(menuItems);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void getRestaurants() &#123;</span><br><span class="line">        List&lt;Restaurant&gt; restaurants &#x3D; restaurantService.getRestaurants();</span><br><span class="line"></span><br><span class="line">        Restaurant restaurant &#x3D; restaurants.get(0);</span><br><span class="line">        assertThat(restaurant.getId(), is(1004L));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void getRestaurant() &#123;</span><br><span class="line">        Restaurant restaurant &#x3D; restaurantService.getRestaurant(1004L);</span><br><span class="line"></span><br><span class="line">        assertThat(restaurant.getId(), is(1004L));</span><br><span class="line"></span><br><span class="line">        MenuItem menuItem &#x3D; restaurant.getMenuItems().get(0);</span><br><span class="line"></span><br><span class="line">        assertThat(menuItem.getName(), is(&quot;Kimchi&quot;));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Study</category>
        <category>Spring Boot Project</category>
      </categories>
      <tags>
        <tag>spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title>14. 가게 추가</title>
    <url>/2020/08/12/hexo_springboot_1_14/</url>
    <content><![CDATA[<h1 id="스프링-부트-프로젝트"><a href="#스프링-부트-프로젝트" class="headerlink" title="스프링 부트 프로젝트"></a>스프링 부트 프로젝트</h1><h3 id="레스토랑-예약-사이트-만들기"><a href="#레스토랑-예약-사이트-만들기" class="headerlink" title="레스토랑 예약 사이트 만들기"></a>레스토랑 예약 사이트 만들기</h3><h4 id="14-가게-추가"><a href="#14-가게-추가" class="headerlink" title="14. 가게 추가"></a>14. 가게 추가</h4><p>POST 메서드를 사용하여 /restaurants 에 추가할 것임<br>성공하면 HTTP status 201<br>넣을 레스토랑 정보는 Header에 담아 보내게 되는데<br>Header Location에 리소스 주소가 들어가게 된다.   </p>
<p>Client에서 보내준 결과를 JSON parser가 수행되도록 할 수 있다.<br>Empty {}</p>
<p>HTTPie 활용하여 확인할 것이다.<br>HTTPie 설치 (MAC OS)</p>
<figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> brew install httpie</span></span><br></pre></td></tr></table></figure>

<p>Controller에 가게를 추가하는 작업을 추가할 것이고,<br>Service에 실제로 기능을 구현할 것이다.   </p>
<p>1.POST 요청을 처리하기 위한 Controller 생성</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@PostMapping(&quot;&#x2F;restaurants&quot;)</span><br><span class="line">public ResponseEntity&lt;?&gt; create(@RequestBody Restaurant resource) &#x2F;&#x2F;content로 넘겨준 내용을 매개변수로 받기</span><br><span class="line">        throws URISyntaxException &#123;</span><br><span class="line"></span><br><span class="line">    String name&#x3D;resource.getName();</span><br><span class="line">    String address&#x3D;resource.getAddress();</span><br><span class="line"></span><br><span class="line">    Restaurant restaurant &#x3D; new Restaurant(1234L,name,address);</span><br><span class="line">    restaurantService.addRestaurant(restaurant);</span><br><span class="line"></span><br><span class="line">    URI location &#x3D; new URI(&quot;&#x2F;restaurants&#x2F;&quot;+restaurant.getId());</span><br><span class="line">    return ResponseEntity.created(location).body(&quot;&#123;&#125;&quot;); &#x2F;&#x2F;빈 내용</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Controller Test</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void create() throws Exception &#123;</span><br><span class="line">    mvc.perform(post(&quot;&#x2F;restaurants&quot;)</span><br><span class="line">            .contentType(MediaType.APPLICATION_JSON) &#x2F;&#x2F;JSON 타입임을 알려준다</span><br><span class="line">            .content(&quot;&#123;\&quot;name\&quot;:\&quot;BeRyong\&quot;,\&quot;address\&quot;:\&quot;Busan\&quot;&#125;&quot;)) &#x2F;&#x2F;JSON 타입으로 데이터 전달</span><br><span class="line">            .andExpect(status().isCreated())</span><br><span class="line">            .andExpect(header().string(&quot;location&quot;, &quot;&#x2F;restaurants&#x2F;1234&quot;))</span><br><span class="line">            .andExpect(content().string(&quot;&#123;&#125;&quot;)); &#x2F;&#x2F;비어있는지 확인</span><br><span class="line"></span><br><span class="line">    verify(restaurantService).addRestaurant(any()); &#x2F;&#x2F;any():뭘 넣든지 작동할 수 있도록, Mockito에서 제공</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.Service 및 Repository 추가<br>Restaurant Service Test</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void addRestaurant() &#123;</span><br><span class="line">    Restaurant restaurant &#x3D; new Restaurant(&quot;BeRyong&quot;, &quot;Busan&quot;);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;가짜 saved</span><br><span class="line">    Restaurant saved &#x3D; new Restaurant(1234L,&quot;BeRyong&quot;, &quot;Busan&quot;);</span><br><span class="line">    given(restaurantRepository.save(any())).willReturn(saved);</span><br><span class="line"></span><br><span class="line">    Restaurant created &#x3D; restaurantService.addRestaurant(restaurant);</span><br><span class="line"></span><br><span class="line">    assertThat(created.getId(), is(1234L));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Restaurant Service</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public Restaurant addRestaurant(Restaurant restaurant) &#123;</span><br><span class="line">    return restaurantRepository.save(restaurant);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Restaurant Repository Test</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class RestaurantRepositoryImplTest &#123;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void save() &#123;</span><br><span class="line">        RestaurantRepository repository &#x3D; new RestaurantRepositoryImpl();</span><br><span class="line"></span><br><span class="line">        int oldCount &#x3D; repository.findAll().size();</span><br><span class="line">        Restaurant restaurant &#x3D; new Restaurant(&quot;BeRyong&quot;,&quot;Busan&quot;);</span><br><span class="line">        repository.save(restaurant);</span><br><span class="line"></span><br><span class="line">        assertThat(restaurant.getId(), is(1234L)); &#x2F;&#x2F;저장된 뒤 id가 생성되었는지 확인    </span><br><span class="line">        int newCount &#x3D; repository.findAll().size();</span><br><span class="line"></span><br><span class="line">        assertThat(newCount-oldCount, is(1)); &#x2F;&#x2F;개수가 늘어났는지 확인</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Restaurant Repository</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Restaurant save(Restaurant restaurant) &#123;</span><br><span class="line">    restaurant.setId(1234L);</span><br><span class="line">    restaurants.add(restaurant);</span><br><span class="line">    return restaurant;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>POST by HTTPie</p>
<figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> http POST localhost:8080/restaurants name=BeRyong address=Busan</span></span><br></pre></td></tr></table></figure>

<p>GET by HTTPie</p>
<figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> http GET localhost:8080/restaurants</span></span><br><span class="line"></span><br><span class="line">HTTP/1.1 200 </span><br><span class="line">Connection: keep-alive</span><br><span class="line">Content-Type: application/json;charset=UTF-8</span><br><span class="line">Date: Mon, 01 Jun 2020 21:07:17 GMT</span><br><span class="line">Keep-Alive: timeout=60</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        "address": "Seoul",</span><br><span class="line">        "id": 1004,</span><br><span class="line">        "information": "Bob zip in Seoul",</span><br><span class="line">        "menuItems": [],</span><br><span class="line">        "name": "Bob zip"</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        "address": "Seoul",</span><br><span class="line">        "id": 2020,</span><br><span class="line">        "information": "Cyber Food in Seoul",</span><br><span class="line">        "menuItems": [],</span><br><span class="line">        "name": "Cyber Food"</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        "address": "Busan",</span><br><span class="line">        "id": 1234,</span><br><span class="line">        "information": "BeRyong in Busan",</span><br><span class="line">        "menuItems": [],</span><br><span class="line">        "name": "BeRyong"</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Study</category>
        <category>Spring Boot Project</category>
      </categories>
      <tags>
        <tag>spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title>16. JPA</title>
    <url>/2020/08/12/hexo_springboot_1_16/</url>
    <content><![CDATA[<h1 id="스프링-부트-프로젝트"><a href="#스프링-부트-프로젝트" class="headerlink" title="스프링 부트 프로젝트"></a>스프링 부트 프로젝트</h1><h3 id="레스토랑-예약-사이트-만들기"><a href="#레스토랑-예약-사이트-만들기" class="headerlink" title="레스토랑 예약 사이트 만들기"></a>레스토랑 예약 사이트 만들기</h3><h4 id="16-JPA"><a href="#16-JPA" class="headerlink" title="16. JPA"></a>16. JPA</h4><p>데이터의 영속화(Persistence) 작업이 필요하다.<br>Java는 영속화에 대한 표준을 가지고 있다.<br>= JPA (Java Persistence API)    </p>
<p>Hibernate : JPA에서 유명한 Library<br>@Entity : Identifier로 구분되는 객체   </p>
<p>Spring Data JPA를 활용하여 쉽게 JPA를 사용할 수 있음  </p>
<p>H2 DBMS를 In-memory로 사용할 것임</p>
<p>build.gradle의 dependencies 부분에 아래와 같이 추가했다.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">	implementation &#39;org.springframework.boot:spring-boot-starter-web&#39;</span><br><span class="line">    &#x2F;&#x2F;추가1 Spring Data JPA</span><br><span class="line">	implementation &#39;org.springframework.boot:spring-boot-starter-data-jpa&#39;</span><br><span class="line">    &#x2F;&#x2F;추가2 H2 Database</span><br><span class="line">	implementation &#39;com.h2database:h2&#39;</span><br><span class="line"></span><br><span class="line">	compileOnly &#39;org.projectlombok:lombok&#39;</span><br><span class="line">	developmentOnly &#39;org.springframework.boot:spring-boot-devtools&#39;</span><br><span class="line">	annotationProcessor &#39;org.projectlombok:lombok&#39;</span><br><span class="line">	testImplementation &#39;org.springframework.boot:spring-boot-starter-test&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>View &gt; Tool Windows &gt; Gradle &gt; Refresh Gradle Dependencies</p>
<p>Restaurant 와 MenuItem 를 Entity로 정의  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Entity</span><br><span class="line">public class Restaurant &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private String address;</span><br><span class="line">    @Id</span><br><span class="line">    @GeneratedValue</span><br><span class="line">    private Long id;</span><br><span class="line"></span><br><span class="line">    @Transient &#x2F;&#x2F;영속화에서 제외   </span><br><span class="line">    private List&lt;MenuItem&gt; menuItems &#x3D; new ArrayList&lt;MenuItem&gt;();</span><br><span class="line"></span><br><span class="line">~</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Entity</span><br><span class="line">public class MenuItem &#123;</span><br><span class="line"></span><br><span class="line">    @Id &#x2F;&#x2F;Identifier for Entity</span><br><span class="line">    @GeneratedValue &#x2F;&#x2F;1부터 순차적으로 들어감</span><br><span class="line">    private Long id;</span><br><span class="line"></span><br><span class="line">    private Long restaurantId;</span><br><span class="line"></span><br><span class="line">~</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Repository 인터페이스를 통해 JPA 사용     </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface MenuItemRepository</span><br><span class="line">        extends CrudRepository&lt;MenuItem, Long&gt; &#123; &#x2F;&#x2F;인터페이스만 이용하여 JPA와 연결하여 사용 &lt;T, ID&gt;</span><br><span class="line">                                                 &#x2F;&#x2F;T : Entity의 타입, ID : id의 타입</span><br><span class="line">    List&lt;MenuItem&gt; findAllByRestaurantId(Long restaurantId);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface RestaurantRepository</span><br><span class="line">        extends CrudRepository&lt;Restaurant, Long&gt; &#123;</span><br><span class="line">    List&lt;Restaurant&gt; findAll();</span><br><span class="line"></span><br><span class="line">    Optional&lt;Restaurant&gt; findById(Long id); &#x2F;&#x2F;Optional : 존재할 수도 있지만 안할수도 있는 객체</span><br><span class="line">                                            &#x2F;&#x2F;NPE 회피..</span><br><span class="line">    Restaurant save(Restaurant restaurant);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Study</category>
        <category>Spring Boot Project</category>
      </categories>
      <tags>
        <tag>spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title>17. 프론트 엔드</title>
    <url>/2020/08/12/hexo_springboot_1_17/</url>
    <content><![CDATA[<h1 id="스프링-부트-프로젝트"><a href="#스프링-부트-프로젝트" class="headerlink" title="스프링 부트 프로젝트"></a>스프링 부트 프로젝트</h1><h3 id="레스토랑-예약-사이트-만들기"><a href="#레스토랑-예약-사이트-만들기" class="headerlink" title="레스토랑 예약 사이트 만들기"></a>레스토랑 예약 사이트 만들기</h3><h4 id="17-프론트-엔드"><a href="#17-프론트-엔드" class="headerlink" title="17. 프론트 엔드"></a>17. 프론트 엔드</h4><p>webpack / webpack-cli / webpack-dev-server 설치</p>
<figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="code"><pre><span class="line">npm install -save-dev webpack webpack-cli webpack-dev-server</span><br></pre></td></tr></table></figure>

<p>start 추가</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;eatgo-web&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;1.0.0&quot;,</span><br><span class="line">  &quot;description&quot;: &quot;EatGo Web Project&quot;,</span><br><span class="line">  &quot;main&quot;: &quot;src&#x2F;index.js&quot;,</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;start&quot;: &quot;webpack-dev-server --port 3000&quot;,</span><br><span class="line">    &quot;test&quot;: &quot;jest&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;author&quot;: &quot;Jeong In&quot;,</span><br><span class="line">  &quot;license&quot;: &quot;ISC&quot;,</span><br><span class="line">  &quot;devDependencies&quot;: &#123;</span><br><span class="line">    &quot;webpack&quot;: &quot;^4.43.0&quot;,</span><br><span class="line">    &quot;webpack-cli&quot;: &quot;^3.3.11&quot;,</span><br><span class="line">    &quot;webpack-dev-server&quot;: &quot;^3.11.0&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>webpack-dev-server 실행</p>
<figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="code"><pre><span class="line">npm start</span><br></pre></td></tr></table></figure>
<p>실제로는 아래와 같은 프로세스가 실행되어 있다   </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ps -ef | grep webpack</span><br><span class="line">                                          </span><br><span class="line">501 43162 43161   0 11:28PM ttys000    0:03.58 node &#x2F;Users&#x2F;ijeong-in&#x2F;Git_repo&#x2F;eatgo&#x2F;eatgo-web&#x2F;node_modules&#x2F;.bin&#x2F;webpack-dev-server --port 3000</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">index.html</span><br><span class="line">webpack-dev-server가 index.js를 main.js로 바꿔준다.</span><br></pre></td></tr></table></figure>
<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>EatGo</title>
</head>
<body>
    <div id="app"></div>
    <script src="./main.js"></script>
</body>
</html>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">index.js</span><br><span class="line">app을 가져와서 내용 고치기    </span><br><span class="line">모든 가게의 id, 이름, 주소 출력</span><br></pre></td></tr></table></figure>
(async () => {
    const url = 'http://localhost:8080/restaurants';
    const response = await fetch(url);
    const restaurants = await response.json();

<pre><code>const element = document.getElementById(&apos;app&apos;);
element.innerHTML = `
    ${restaurants.map(restaurant =&gt; `
    &lt;p&gt;
        ${restaurant.id}
        ${restaurant.name}
        ${restaurant.address}
    &lt;/p&gt;
    `).join(&apos;&apos;)}
`;</code></pre><p>})();</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">별도의 웹서버에서 CORS에 따라 서로 보안을 위해 접근할 수 없기때문에 </span><br><span class="line">Spring에서 CrossOrigin annotation 처리</span><br></pre></td></tr></table></figure>
<p>@CrossOrigin<br>@RestController<br>public class RestaurantController {</p>
<pre><code>@Autowired
private RestaurantService restaurantService;

@GetMapping(&quot;/restaurants&quot;)
public List&lt;Restaurant&gt; list() {

    List&lt;Restaurant&gt; restaurants = restaurantService.getRestaurants(); //API들의 중복제거를 위해 가게 저장소 사용
    return restaurants;
}</code></pre><pre><code></code></pre>]]></content>
      <categories>
        <category>Study</category>
        <category>Spring Boot Project</category>
      </categories>
      <tags>
        <tag>spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title>18. 가게 수정</title>
    <url>/2020/08/12/hexo_springboot_1_18/</url>
    <content><![CDATA[<h1 id="스프링-부트-프로젝트"><a href="#스프링-부트-프로젝트" class="headerlink" title="스프링 부트 프로젝트"></a>스프링 부트 프로젝트</h1><h3 id="레스토랑-예약-사이트-만들기"><a href="#레스토랑-예약-사이트-만들기" class="headerlink" title="레스토랑 예약 사이트 만들기"></a>레스토랑 예약 사이트 만들기</h3><h4 id="18-가게-수정"><a href="#18-가게-수정" class="headerlink" title="18. 가게 수정"></a>18. 가게 수정</h4><p>PATCH /restaurants/{id}<br>성공 http status 200  </p>
<p>Controller Test에서 새로운 기능 테스트    </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void update() throws Exception &#123;</span><br><span class="line">    mvc.perform(patch(&quot;&#x2F;restaurants&#x2F;1&quot;)</span><br><span class="line">            .contentType(MediaType.APPLICATION_JSON)</span><br><span class="line">            .content(&quot;&#123;\&quot;name\&quot;:\&quot;GukBobZip\&quot;,\&quot;address\&quot;:\&quot;Busan\&quot;&#125;&quot;))</span><br><span class="line">            .andExpect(status().isOk());</span><br><span class="line"></span><br><span class="line">    verify(restaurantService).updateRestaurant(1L, &quot;GukBobZip&quot;, &quot;Busan&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Controller에 실제 기능 추가    </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@PatchMapping(&quot;&#x2F;restaurants&#x2F;&#123;id&#125;&quot;)</span><br><span class="line">public String update(@PathVariable(&quot;id&quot;) Long id,</span><br><span class="line">                     @RequestBody Restaurant resource) &#123;</span><br><span class="line"></span><br><span class="line">    String name &#x3D; resource.getName();</span><br><span class="line">    String address &#x3D; resource.getAddress();</span><br><span class="line"></span><br><span class="line">    restaurantService.updateRestaurant(id, name, address);</span><br><span class="line">    return &quot;&#123;&#125;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Service Test</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void updateRestaurant() &#123;</span><br><span class="line"></span><br><span class="line">    Restaurant restaurant &#x3D; new Restaurant(1L, &quot;BobZip&quot;, &quot;Seoul&quot;);</span><br><span class="line">    given(restaurantRepository.findById(1L)).willReturn(java.util.Optional.of(restaurant));</span><br><span class="line"></span><br><span class="line">    restaurantService.updateRestaurant(1L,&quot;GukBobZip&quot;,&quot;Busan&quot;);</span><br><span class="line"></span><br><span class="line">    assertThat(restaurant.getName(), is(&quot;GukBobZip&quot;));</span><br><span class="line">    assertThat(restaurant.getAddress(), is(&quot;Busan&quot;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Service 추가</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Transactional &#x2F;&#x2F;트랜젝션 범위에서 처리되고 범위에서 처리가 벗어났을때 내용이 적용됨</span><br><span class="line">public Restaurant updateRestaurant(Long id, String name, String address) &#123;</span><br><span class="line">    Restaurant restaurant &#x3D; restaurantRepository.findById(id).orElse(null);</span><br><span class="line"></span><br><span class="line">    restaurant.setInformation(name,address);</span><br><span class="line">    return restaurant;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>테스트</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ http PATCH localhost:8080&#x2F;restaurants&#x2F;1 name&#x3D;BeRyong address&#x3D;Seoul</span><br><span class="line">HTTP&#x2F;1.1 200 </span><br><span class="line">~</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Study</category>
        <category>Spring Boot Project</category>
      </categories>
      <tags>
        <tag>spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title>19. Lombok</title>
    <url>/2020/08/12/hexo_springboot_1_19/</url>
    <content><![CDATA[<h1 id="스프링-부트-프로젝트"><a href="#스프링-부트-프로젝트" class="headerlink" title="스프링 부트 프로젝트"></a>스프링 부트 프로젝트</h1><h3 id="레스토랑-예약-사이트-만들기"><a href="#레스토랑-예약-사이트-만들기" class="headerlink" title="레스토랑 예약 사이트 만들기"></a>레스토랑 예약 사이트 만들기</h3><h4 id="19-Lombok"><a href="#19-Lombok" class="headerlink" title="19. Lombok"></a>19. Lombok</h4><p>Annotation Processor 를 이용해서 코딩 자동화</p>
<p>@Setter<br>@Getter<br>@Builder    </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Entity</span><br><span class="line">@Getter &#x2F;&#x2F;모든 속성들에 대한 getter 가 알아서 만들어 진다</span><br><span class="line">@NoArgsConstructor &#x2F;&#x2F;디폴트 생성자</span><br><span class="line">@AllArgsConstructor &#x2F;&#x2F;모든 속성 조합을 사용하는 생성자들</span><br><span class="line">@Builder &#x2F;&#x2F;Builder 패턴을 사용</span><br><span class="line">public class Restaurant &#123;</span><br><span class="line">    @Id</span><br><span class="line">    @Setter</span><br><span class="line">    @GeneratedValue</span><br><span class="line">    private Long id;</span><br><span class="line">    @Setter &#x2F;&#x2F;name에 대한 setter 가 알아서 만들어 진다</span><br><span class="line">    private String name;</span><br><span class="line">    private String address;</span><br><span class="line"></span><br><span class="line">    @Transient  </span><br><span class="line">    private List&lt;MenuItem&gt; menuItems;</span><br><span class="line"></span><br><span class="line">    public String getInformation() &#123;</span><br><span class="line">        return name+&quot; in &quot;+address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setMenuItems(List&lt;MenuItem&gt; menuItems) &#123;</span><br><span class="line">        this.menuItems &#x3D; new ArrayList&lt;MenuItem&gt;(menuItems);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setInformation(String name, String address) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">        this.address &#x3D; address;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Builder로 인스턴스 생성시</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void creation() &#123;</span><br><span class="line">    Restaurant restaurant &#x3D; Restaurant.builder() &#x2F;&#x2F;@Builder 패턴을 사용, 가독이 좋고 순서가 없다는 장점이 있다.  </span><br><span class="line">            .id(1004L)</span><br><span class="line">            .name(&quot;Bob zip&quot;)</span><br><span class="line">            .address(&quot;Seoul&quot;)</span><br><span class="line">            .build();</span><br><span class="line"></span><br><span class="line">    assertThat(restaurant.getId(), is(1004L));</span><br><span class="line">    assertThat(restaurant.getName(), is(&quot;Bob zip&quot;));</span><br><span class="line">    assertThat(restaurant.getAddress(), is(&quot;Seoul&quot;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Study</category>
        <category>Spring Boot Project</category>
      </categories>
      <tags>
        <tag>spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title>21. Validation, 에러 처리</title>
    <url>/2020/08/12/hexo_springboot_1_21/</url>
    <content><![CDATA[<h1 id="스프링-부트-프로젝트"><a href="#스프링-부트-프로젝트" class="headerlink" title="스프링 부트 프로젝트"></a>스프링 부트 프로젝트</h1><h3 id="레스토랑-예약-사이트-만들기"><a href="#레스토랑-예약-사이트-만들기" class="headerlink" title="레스토랑 예약 사이트 만들기"></a>레스토랑 예약 사이트 만들기</h3><h4 id="21-Validation-에러-처리"><a href="#21-Validation-에러-처리" class="headerlink" title="21. Validation, 에러 처리"></a>21. Validation, 에러 처리</h4><p>Validation : 유효성 검사<br>사용자들이 입력한 데이터가 올바른지 검증하는 작업이다.  </p>
<p>@Valid</p>
<p>@NotNull<br>@NotEmpty<br>@Size(max=10)</p>
<p>올바르지 않을 시 Error(http status 400)를 리턴하도록</p>
<p>Controller의 기능에 @Valid 추가   </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@PostMapping(&quot;&#x2F;restaurants&quot;)</span><br><span class="line">public ResponseEntity&lt;?&gt; create(@Valid @RequestBody Restaurant resource) &#x2F;&#x2F;Valid: 검증할 것이라 정의</span><br><span class="line">        throws URISyntaxException &#123;</span><br><span class="line"></span><br><span class="line">            Restaurant restaurant &#x3D; Restaurant.builder()</span><br><span class="line">            .name(resource.getName())</span><br><span class="line">            .address(resource.getAddress())</span><br><span class="line">            .build();</span><br><span class="line">    restaurantService.addRestaurant(restaurant);</span><br><span class="line"></span><br><span class="line">    URI location &#x3D; new URI(&quot;&#x2F;restaurants&#x2F;&quot;+restaurant.getId());</span><br><span class="line">    return ResponseEntity.created(location).body(&quot;&#123;&#125;&quot;); &#x2F;&#x2F;빈 내용</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@PatchMapping(&quot;&#x2F;restaurants&#x2F;&#123;id&#125;&quot;)</span><br><span class="line">public String update(@PathVariable(&quot;id&quot;) Long id,</span><br><span class="line">                     @Valid @RequestBody Restaurant resource) &#123;</span><br><span class="line"></span><br><span class="line">    restaurantService.updateRestaurant(id, resource.getName(), resource.getAddress());</span><br><span class="line">    return &quot;&#123;&#125;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Model에서 속성 특징 변경</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@NotEmpty &#x2F;&#x2F;비어있으면 안된다고 정의</span><br><span class="line">private String name;</span><br><span class="line">@NotEmpty</span><br><span class="line">private String address;</span><br></pre></td></tr></table></figure>

<p>Controller Test</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void createWithInvalidData() throws Exception &#123;</span><br><span class="line">    mvc.perform(post(&quot;&#x2F;restaurants&quot;)</span><br><span class="line">            .contentType(MediaType.APPLICATION_JSON)</span><br><span class="line">            .content(&quot;&#123;\&quot;name\&quot;:\&quot;\&quot;,\&quot;address\&quot;:\&quot;\&quot;&#125;&quot;))</span><br><span class="line">            .andExpect(status().isBadRequest());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void updateWithInvalidData() throws Exception &#123;</span><br><span class="line">    mvc.perform(patch(&quot;&#x2F;restaurants&#x2F;1&quot;)</span><br><span class="line">            .contentType(MediaType.APPLICATION_JSON)</span><br><span class="line">            .content(&quot;&#123;\&quot;name\&quot;:\&quot;\&quot;,\&quot;address\&quot;:\&quot;\&quot;&#125;&quot;))</span><br><span class="line">            .andExpect(status().isBadRequest());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Not Found에 대한 처리 =&gt; Exception (http status 404)<br>ex) 없는 URL</p>
<p>@ControllerAdvice : 예외를 받아 처리할 클래스  </p>
<p>Demo<br>존재하지 않는 id의 가게를 조회했을 때 http status 404를 response하려면</p>
<p>id:404(없는 id)의 디테일을 Get했을때 not found를 받고싶다.  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void detailWithNotExist() throws Exception &#123;</span><br><span class="line">    given(restaurantService.getRestaurant(404L))</span><br><span class="line">            .willThrow(new RestaurantNotFoundException(404L)); &#x2F;&#x2F;서비스는 사용자 예외를 던질건데  </span><br><span class="line"></span><br><span class="line">    mvc.perform(MockMvcRequestBuilders.get(&quot;&#x2F;restaurants&#x2F;404&quot;))</span><br><span class="line">            .andExpect(status().isNotFound()) &#x2F;&#x2F;status 404인지 확인하고싶다.</span><br><span class="line">            .andExpect(content().string(&quot;&#123;&#125;&quot;)); &#x2F;&#x2F;빈 body도 받는지 확인하고싶다.  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>사용자 예외 클래스 생성 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class RestaurantNotFoundException extends RuntimeException &#123;</span><br><span class="line"></span><br><span class="line">    public RestaurantNotFoundException(long id) &#123;</span><br><span class="line">        super(&quot;Could not find restaurant &quot;+id); &#x2F;&#x2F;RuntimeException의 매개변수 massage(String)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Controller에서 try/catch로 예외처리 해줄수도 있겠지만<br>예외처리를 맡아줄 ControllerAdvice를 생성해준다.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@ControllerAdvice &#x2F;&#x2F;예외를 처리할 클래스  </span><br><span class="line">public class RestaurantErrorAdvice &#123;</span><br><span class="line"></span><br><span class="line">    @ResponseBody</span><br><span class="line">    @ResponseStatus(HttpStatus.NOT_FOUND) &#x2F;&#x2F;response 404 할것임</span><br><span class="line">    @ExceptionHandler(RestaurantNotFoundException.class) &#x2F;&#x2F;어떤 예외에 대한 정의</span><br><span class="line">    public String handleNotFound() &#123;</span><br><span class="line">        return &quot;&#123;&#125;&quot;; &#x2F;&#x2F;예외 처리하고 비어있는 body를 보낼것이다.</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Service에서도 test 진행</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test(expected &#x3D; RestaurantNotFoundException.class) &#x2F;&#x2F;사용자 예외가 발생할까?  </span><br><span class="line">public void getRestaurantWithNotExisted() &#123;</span><br><span class="line"></span><br><span class="line">    Restaurant restaurant &#x3D; restaurantService.getRestaurant(404L);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>orElseThrow()로 예외 처리</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public Restaurant getRestaurant(Long id) &#123;</span><br><span class="line"></span><br><span class="line">    Restaurant restaurant &#x3D;  restaurantRepository.findById(id)</span><br><span class="line">            .orElseThrow(() -&gt; new RestaurantNotFoundException(id)); &#x2F;&#x2F;사용자 예외 처리</span><br><span class="line">    List&lt;MenuItem&gt; menuItems &#x3D; menuItemRepository.findAllByRestaurantId(id);</span><br><span class="line">    restaurant.setMenuItems(menuItems);</span><br><span class="line"></span><br><span class="line">    return restaurant;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Study</category>
        <category>Spring Boot Project</category>
      </categories>
      <tags>
        <tag>spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title>23. 메뉴 관리</title>
    <url>/2020/08/12/hexo_springboot_1_23/</url>
    <content><![CDATA[<h1 id="스프링-부트-프로젝트"><a href="#스프링-부트-프로젝트" class="headerlink" title="스프링 부트 프로젝트"></a>스프링 부트 프로젝트</h1><h3 id="레스토랑-예약-사이트-만들기"><a href="#레스토랑-예약-사이트-만들기" class="headerlink" title="레스토랑 예약 사이트 만들기"></a>레스토랑 예약 사이트 만들기</h3><h4 id="23-메뉴-관리"><a href="#23-메뉴-관리" class="headerlink" title="23. 메뉴 관리"></a>23. 메뉴 관리</h4><p>메뉴 관리 : 추가 수정 삭제 기능 추가</p>
<p>한번에 여러게 업데이트 : Bulk Update<br>Patch “/restaurants/{id}/menuitems”<br>http status : 200</p>
<p>restaurant은 추가할때 save(), 수정할때 @Transactional으로 직접 수정했었는데,<br>메뉴는 Bulk Update를 할거고 save()와 deleteById()를 동시에 사용할 것임.  </p>
<p>MenuItem Controller Test</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void bulkUpdate() throws Exception &#123;</span><br><span class="line">    mvc.perform(patch(&quot;&#x2F;restaurants&#x2F;1&#x2F;menuitems&quot;) &#x2F;&#x2F;1번 가게의 menuitem을 bulk로 수정할껀데</span><br><span class="line">            .contentType(MediaType.APPLICATION_JSON) &#x2F;&#x2F;헤더에 content-Type이 Application&#x2F;json 이고</span><br><span class="line">            .content(&quot;[\n&quot; +</span><br><span class="line">                    &quot;  &#123;\n&quot; +</span><br><span class="line">                    &quot;    \&quot;name\&quot;: \&quot;Kimchi\&quot;\n&quot; +</span><br><span class="line">                    &quot;  &#125;,\n&quot; +</span><br><span class="line">                    &quot;  &#123;\n&quot; +</span><br><span class="line">                    &quot;    \&quot;name\&quot;: \&quot;Gukbob\&quot;\n&quot; +</span><br><span class="line">                    &quot;  &#125;\n&quot; +</span><br><span class="line">                    &quot;]&quot;)) &#x2F;&#x2F;이런 array를 입력할꺼야</span><br><span class="line">            .andExpect(status().isOk()); &#x2F;&#x2F;http status 200이야?</span><br><span class="line">            </span><br><span class="line">    verify(menuItemServices).bulkUpdate(eq(1L), any()); &#x2F;&#x2F;서비스에서 bulkUpdate()가 올바른 id(1L)로 호출되나?</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Controller에 PatchMapping 추가</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@PatchMapping(&quot;&#x2F;restaurants&#x2F;&#123;restaurantId&#125;&#x2F;menuitems&quot;)</span><br><span class="line">public void bulkUpdate(</span><br><span class="line">        @PathVariable(&quot;restaurantId&quot;) Long restaurantId,</span><br><span class="line">        @RequestBody List&lt;MenuItem&gt; menuItems &#x2F;&#x2F;MenuItem List를 사용자로부터 입력받는다. </span><br><span class="line">) &#123;</span><br><span class="line">    menuItemServices.bulkUpdate(restaurantId, menuItems);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>Service 테스트</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Mock</span><br><span class="line">private MenuItemRepository menuItemRepository;</span><br><span class="line"></span><br><span class="line">@Before</span><br><span class="line">public void setUp() &#123;</span><br><span class="line">    MockitoAnnotations.initMocks(this);</span><br><span class="line">    menuItemServices &#x3D; new MenuItemService(menuItemRepository);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void bulkUpdate() &#123;</span><br><span class="line">    </span><br><span class="line">    List&lt;MenuItem&gt; menuItems &#x3D; new ArrayList&lt;MenuItem&gt;();</span><br><span class="line">    </span><br><span class="line">    menuItems.add(MenuItem.builder().name(&quot;Kimchi&quot;).build()); &#x2F;&#x2F;add</span><br><span class="line">    menuItems.add(MenuItem.builder().id(12L).name(&quot;Gukbob&quot;).build()); &#x2F;&#x2F;add</span><br><span class="line">    menuItems.add(MenuItem.builder().id(1004L).destroy(true).build()); &#x2F;&#x2F;delete</span><br><span class="line">    menuItems.add(MenuItem.builder().id(12L).name(&quot;Guk Bob&quot;).build()); &#x2F;&#x2F;update</span><br><span class="line"></span><br><span class="line">    menuItemServices.bulkUpdate(1L,menuItems);</span><br><span class="line"></span><br><span class="line">    verify(menuItemRepository, times(3)).save(any()); &#x2F;&#x2F;save 함수가 3회 호출되나?</span><br><span class="line">    verify(menuItemRepository, times(1)).deleteById(1004L); &#x2F;&#x2F;deleteById 함수가 1회 호출되나?</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Restaurant Model의 menuItem이 안보이게 수정 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Transient</span><br><span class="line">@JsonInclude(JsonInclude.Include.NON_NULL) &#x2F;&#x2F;Null이 아닐때만 json에 넣어줘라</span><br><span class="line">private List&lt;MenuItem&gt; menuItems;</span><br></pre></td></tr></table></figure>

<p>MenuItem Model에 destory라는 속성 추가</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Transient</span><br><span class="line">@JsonInclude(JsonInclude.Include.NON_DEFAULT) &#x2F;&#x2F;json에 포함 X</span><br><span class="line">private boolean destroy;</span><br></pre></td></tr></table></figure>

<p>Service</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class MenuItemService &#123;</span><br><span class="line"></span><br><span class="line">    private MenuItemRepository menuItemRepository;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    public MenuItemService(MenuItemRepository menuItemRepository) &#123;</span><br><span class="line">        this.menuItemRepository&#x3D;menuItemRepository;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public void bulkUpdate(Long restaurantId, List&lt;MenuItem&gt; menuItems) &#123;</span><br><span class="line"></span><br><span class="line">        for(MenuItem menuItem : menuItems) &#123;</span><br><span class="line">            update(restaurantId, menuItem);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void update(Long restaurantId, MenuItem menuItem) &#123;</span><br><span class="line">        if (menuItem.isDestroy()) &#123;</span><br><span class="line">            menuItemRepository.deleteById(menuItem.getId());</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        menuItem.setRestaurantId(restaurantId);</span><br><span class="line">        menuItemRepository.save(menuItem);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Study</category>
        <category>Spring Boot Project</category>
      </categories>
      <tags>
        <tag>spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title>26. 리뷰 작성</title>
    <url>/2020/08/12/hexo_springboot_1_26/</url>
    <content><![CDATA[<h1 id="스프링-부트-프로젝트"><a href="#스프링-부트-프로젝트" class="headerlink" title="스프링 부트 프로젝트"></a>스프링 부트 프로젝트</h1><h3 id="레스토랑-예약-사이트-만들기"><a href="#레스토랑-예약-사이트-만들기" class="headerlink" title="레스토랑 예약 사이트 만들기"></a>레스토랑 예약 사이트 만들기</h3><h4 id="26-리뷰-작성"><a href="#26-리뷰-작성" class="headerlink" title="26. 리뷰 작성"></a>26. 리뷰 작성</h4><p>POST /restaurants/{id}/reviews</p>
<p>Review Controller Test</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RunWith(SpringRunner.class)</span><br><span class="line">@WebMvcTest(ReviewController.class)</span><br><span class="line">public class ReviewControllerTest &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private MockMvc mvc;</span><br><span class="line"></span><br><span class="line">    @MockBean</span><br><span class="line">    private ReviewService reviewService;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void createWithValidAttributes() throws Exception &#123;</span><br><span class="line">        given(reviewService.addReview(any(),eq(1L))).willReturn(</span><br><span class="line">                Review.builder().id(1004L).build()</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        mvc.perform(post(&quot;&#x2F;restaurants&#x2F;1&#x2F;reviews&quot;)</span><br><span class="line">                .contentType(MediaType.APPLICATION_JSON) &#x2F;&#x2F;json 타입이고</span><br><span class="line">                .content(&quot;&#123;\&quot;name\&quot;:\&quot;jilee\&quot;,\&quot;score\&quot;:3,\&quot;description\&quot;:\&quot;Mat-it-da\&quot;&#125;&quot;)) &#x2F;&#x2F;이렇게 넣을거야</span><br><span class="line">                .andExpect(status().isCreated()) &#x2F;&#x2F;잘 만들어지나?(status 201?)</span><br><span class="line">                .andExpect(header().string(&quot;location&quot;, &quot;&#x2F;restaurants&#x2F;1&#x2F;reviews&#x2F;1004&quot;)); &#x2F;&#x2F;header의 location 확인</span><br><span class="line"></span><br><span class="line">        verify(reviewService).addReview(any(),eq(1L)); &#x2F;&#x2F;addReview가 호출되니?</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void createWithInValidAttributes() throws Exception &#123;</span><br><span class="line">        mvc.perform(post(&quot;&#x2F;restaurants&#x2F;1&#x2F;reviews&quot;)</span><br><span class="line">                .contentType(MediaType.APPLICATION_JSON) &#x2F;&#x2F;json 타입이고</span><br><span class="line">                .content(&quot;&#123;&#125;&quot;)) &#x2F;&#x2F;이렇게 넣을거야</span><br><span class="line">                .andExpect(status().isBadRequest()); &#x2F;&#x2F;status 404?</span><br><span class="line"></span><br><span class="line">        verify(reviewService,never()).addReview(any(),eq(1L)); &#x2F;&#x2F;addReview가 호출되지 않니?</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Review Controller</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class ReviewController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private ReviewService reviewService;</span><br><span class="line"></span><br><span class="line">    @PostMapping(&quot;&#x2F;restaurants&#x2F;&#123;restaurantId&#125;&#x2F;reviews&quot;)</span><br><span class="line">    public ResponseEntity&lt;?&gt; create(</span><br><span class="line">            @PathVariable(&quot;restaurantId&quot;) Long restaurantId,</span><br><span class="line">            @Valid @RequestBody Review resource</span><br><span class="line">    ) throws URISyntaxException &#123;</span><br><span class="line"></span><br><span class="line">        Review review &#x3D; reviewService.addReview(resource,restaurantId);</span><br><span class="line"></span><br><span class="line">        String url &#x3D; &quot;&#x2F;restaurants&#x2F;&quot;+restaurantId+&quot;&#x2F;reviews&#x2F;&quot;+review.getId();</span><br><span class="line">        return ResponseEntity.created(new URI(url))</span><br><span class="line">                .body(&quot;&#123;&#125;&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Service Test</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ReviewServiceTest &#123;</span><br><span class="line"></span><br><span class="line">    private ReviewService reviewService;</span><br><span class="line"></span><br><span class="line">    @Mock</span><br><span class="line">    private ReviewRepository reviewRepository;</span><br><span class="line"></span><br><span class="line">    @Before</span><br><span class="line">    public void setUp() &#123;</span><br><span class="line">        MockitoAnnotations.initMocks(this);</span><br><span class="line"></span><br><span class="line">        reviewService &#x3D; new ReviewService(reviewRepository);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void addReview() &#123;</span><br><span class="line">        Review review &#x3D; Review.builder().name(&quot;jilee&quot;).score(3).description(&quot;Mat-it-da&quot;).build(); &#x2F;&#x2F;Review 객체 생성</span><br><span class="line">        reviewService.addReview(review,1004L); &#x2F;&#x2F;기능 실행할때</span><br><span class="line"></span><br><span class="line">        verify(reviewRepository).save(any()); &#x2F;&#x2F;save가 호출되니?</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Service</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class ReviewService &#123;</span><br><span class="line"></span><br><span class="line">    private ReviewRepository reviewRepository;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    public ReviewService(ReviewRepository reviewRepository) &#123;</span><br><span class="line">        this.reviewRepository &#x3D; reviewRepository;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Review addReview(Review review,Long restaurantId) &#123;</span><br><span class="line">        review.setRestaurantId(restaurantId);</span><br><span class="line">        return reviewRepository.save(review);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Review Repository</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface ReviewRepository extends CrudRepository&lt;Review, Long&gt; &#123;</span><br><span class="line"></span><br><span class="line">    Review save(Review review);</span><br><span class="line"></span><br><span class="line">    List&lt;Review&gt; findAllByRestaurantId(Long restaurantId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Study</category>
        <category>Spring Boot Project</category>
      </categories>
      <tags>
        <tag>spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title>29. 프로젝트 분리</title>
    <url>/2020/08/12/hexo_springboot_1_29/</url>
    <content><![CDATA[<h1 id="스프링-부트-프로젝트"><a href="#스프링-부트-프로젝트" class="headerlink" title="스프링 부트 프로젝트"></a>스프링 부트 프로젝트</h1><h3 id="레스토랑-예약-사이트-만들기"><a href="#레스토랑-예약-사이트-만들기" class="headerlink" title="레스토랑 예약 사이트 만들기"></a>레스토랑 예약 사이트 만들기</h3><h4 id="29-프로젝트-분리"><a href="#29-프로젝트-분리" class="headerlink" title="29. 프로젝트 분리"></a>29. 프로젝트 분리</h4><p>./gradlew build<br>./gradlew assamble<br>./gradlew test //전체 테스트 실행<br>./gradlew check  </p>
<p>사용자에 따른 API 분리  </p>
<p>기존 settings.gradle</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rootProject.name &#x3D; &#39;eatgo&#39;</span><br><span class="line"></span><br><span class="line">include &#39;eatgo-api&#39;</span><br></pre></td></tr></table></figure>
<p>변경 후 settings.gradle<br>eatgo-common : 공동으로 사용될 package들 (domain)<br>eatgo-admin-api : 가게 관리자용<br>eatgo-customer-api : 고객용    </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rootProject.name &#x3D; &#39;eatgo&#39;</span><br><span class="line"></span><br><span class="line">include &#39;eatgo-common&#39;</span><br><span class="line">include &#39;eatgo-admin-api&#39;</span><br><span class="line">include &#39;eatgo-customer-api&#39;</span><br></pre></td></tr></table></figure>

<p>eatgo-common의 build.gradle 수정<br>참고 : <a href="https://docs.spring.io/spring-boot/docs/current/gradle-plugin/reference/html/#packaging-executable-and-normal" target="_blank" rel="noopener">https://docs.spring.io/spring-boot/docs/current/gradle-plugin/reference/html/#packaging-executable-and-normal</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jar &#123; </span><br><span class="line">    enabled &#x3D; true &#x2F;&#x2F;default가 false이기때문에, false면 import에서 문제 발생  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bootJar &#123;</span><br><span class="line">    enabled &#x3D; false &#x2F;&#x2F;true면 gradle assamble&#x2F;build 에서 문제발생 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>eatgo-admin-api, eatgo-customer-api의 build.gradle 수정<br>eatgo-common 의존성 추가  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">	implementation project(&#39;:eatgo-common&#39;)</span><br><span class="line"></span><br><span class="line">    ~</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Study</category>
        <category>Spring Boot Project</category>
      </categories>
      <tags>
        <tag>spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title>34. 진짜 영속화</title>
    <url>/2020/08/12/hexo_springboot_1_34/</url>
    <content><![CDATA[<h1 id="스프링-부트-프로젝트"><a href="#스프링-부트-프로젝트" class="headerlink" title="스프링 부트 프로젝트"></a>스프링 부트 프로젝트</h1><h3 id="레스토랑-예약-사이트-만들기"><a href="#레스토랑-예약-사이트-만들기" class="headerlink" title="레스토랑 예약 사이트 만들기"></a>레스토랑 예약 사이트 만들기</h3><h4 id="34-진짜-영속화"><a href="#34-진짜-영속화" class="headerlink" title="34. 진짜 영속화"></a>34. 진짜 영속화</h4><p>database(h2)를 이제부터 file로 생성할 예정이다.<br>file을 사용하게 되면 test에 실행되는 내용도 file에 작성될 수 있기때문에<br>test, 개발, 서비스 등 다른 영역에서 각각 다른 설정으로 처리될 수 있도록 profiles를 사용한다.    </p>
<p>eatgo-admin-api &amp; eatgo-customer-api<br>resource에 application.yml 파일 추가</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">##spring:</span><br><span class="line">##  key: value</span><br><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    url: jdbc:h2:~&#x2F;data&#x2F;eatgo</span><br><span class="line">  jpa:</span><br><span class="line">    hibernate:</span><br><span class="line">      ddl-auto: update</span><br><span class="line">      </span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  profiles: test</span><br><span class="line">  datasource:</span><br><span class="line">    url: jdbc:h2:mem:test</span><br></pre></td></tr></table></figure>

<p>여러개의 설정을 나누려면 ‘—‘<br>SPRING_PROFILES_ACTIVE=test 일때, profiles: test의 설정이 적용된다.<br>ex) SPRING_PROFILES_ACTIVE=test ./gradlew test<br>intellij에서는 Test edit configuration에서 Environment value에 추가해주면 된다.</p>
]]></content>
      <categories>
        <category>Study</category>
        <category>Spring Boot Project</category>
      </categories>
      <tags>
        <tag>spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title>35. 가게 목록 필터링</title>
    <url>/2020/08/12/hexo_springboot_1_35/</url>
    <content><![CDATA[<h1 id="스프링-부트-프로젝트"><a href="#스프링-부트-프로젝트" class="headerlink" title="스프링 부트 프로젝트"></a>스프링 부트 프로젝트</h1><h3 id="레스토랑-예약-사이트-만들기"><a href="#레스토랑-예약-사이트-만들기" class="headerlink" title="레스토랑 예약 사이트 만들기"></a>레스토랑 예약 사이트 만들기</h3><h4 id="35-가게-목록-필터링"><a href="#35-가게-목록-필터링" class="headerlink" title="35. 가게 목록 필터링"></a>35. 가게 목록 필터링</h4><p>필터링 (지역, 분류 (Region, Category))</p>
<p>Region과 Category를 도메인 모델로 관리</p>
<ul>
<li><p>eatgo-admin-api<br>GET /regions<br>POST /regions<br>GET /categories<br>POST /categories  </p>
</li>
<li><p>eatgo-customer-api<br>GET /regions<br>GET /categories  </p>
</li>
</ul>
<p>JPA<br>findAllByAddressContaining<br>findAllByAddressStartingWith  </p>
<p>H2 Console<br><a href="http://localhost:8080/h2-console" target="_blank" rel="noopener">http://localhost:8080/h2-console</a> 에서 h2DB를 관리할 수 있다.  </p>
<p>eatgo-customer-api<br>Restaurant Controller 수정</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@GetMapping(&quot;&#x2F;restaurants&quot;)</span><br><span class="line">public List&lt;Restaurant&gt; list(</span><br><span class="line">        @RequestParam(&quot;region&quot;) String region, &#x2F;&#x2F;region 파라미터 추가</span><br><span class="line">        @RequestParam(&quot;category&quot;) Long categoryId &#x2F;&#x2F;category 파라미터 추가 </span><br><span class="line">) &#123;</span><br><span class="line">    List&lt;Restaurant&gt; restaurants &#x3D; restaurantService.getRestaurants(region,categoryId);</span><br><span class="line">    return restaurants;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Restaurant Service의 getRestaurants 메서드 매개변수 추가 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public List&lt;Restaurant&gt; getRestaurants(String region, long categoryId) &#123;</span><br><span class="line">    List&lt;Restaurant&gt; restaurants &#x3D;</span><br><span class="line">            restaurantRepository.findByAddressContainingAndCategoryId(region,categoryId);</span><br><span class="line">            &#x2F;&#x2F;입력받은 region을 포함하는 address &#x2F; 일치하는 categoryId </span><br><span class="line">    return restaurants;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Restaurant Repository JPA</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List&lt;Restaurant&gt; findByAddressContainingAndCategoryId(</span><br><span class="line">        String region, long categoryId);</span><br></pre></td></tr></table></figure>

<p>TEST</p>
<figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="code"><pre><span class="line">http GET "localhost:8080/restaurants?region=서울&amp;category=1"</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Study</category>
        <category>Spring Boot Project</category>
      </categories>
      <tags>
        <tag>spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title>41. 사용자 관리</title>
    <url>/2020/08/12/hexo_springboot_1_41/</url>
    <content><![CDATA[<h1 id="스프링-부트-프로젝트"><a href="#스프링-부트-프로젝트" class="headerlink" title="스프링 부트 프로젝트"></a>스프링 부트 프로젝트</h1><h3 id="레스토랑-예약-사이트-만들기"><a href="#레스토랑-예약-사이트-만들기" class="headerlink" title="레스토랑 예약 사이트 만들기"></a>레스토랑 예약 사이트 만들기</h3><h4 id="41-사용자-관리"><a href="#41-사용자-관리" class="headerlink" title="41. 사용자 관리"></a>41. 사용자 관리</h4><p>User 도메인 모델을 추가할것이다.<br>User의 속성<br>String name<br>Integer level : 1일반고객,2가게,100관리자,0deactive계정…<br>String email</p>
<p>User model</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Entity</span><br><span class="line">@Builder</span><br><span class="line">@Getter</span><br><span class="line">@AllArgsConstructor</span><br><span class="line">@NoArgsConstructor</span><br><span class="line">public class User &#123;</span><br><span class="line"></span><br><span class="line">    @Id</span><br><span class="line">    @GeneratedValue</span><br><span class="line">    Long id;</span><br><span class="line"></span><br><span class="line">    @NotEmpty</span><br><span class="line">    @Setter</span><br><span class="line">    String email;</span><br><span class="line"></span><br><span class="line">    @NotEmpty</span><br><span class="line">    @Setter</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    @NotNull</span><br><span class="line">    @Setter</span><br><span class="line">    Long level;</span><br><span class="line"></span><br><span class="line">    public boolean isAdmin() &#123;</span><br><span class="line">        return level &gt;&#x3D; 100;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean isActive() &#123;</span><br><span class="line">        return level &gt; 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void deactivate() &#123;</span><br><span class="line">        level &#x3D; 0L;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>Controller에 실제 계정을 제거하는 대신 deactive하는 기능구현  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void delete() throws Exception &#123;</span><br><span class="line">    mvc.perform(MockMvcRequestBuilders.delete(&quot;&#x2F;users&#x2F;1004&quot;))</span><br><span class="line">            .andExpect(status().isOk());</span><br><span class="line"></span><br><span class="line">    Long id &#x3D; 1004L;</span><br><span class="line">    verify(userService).deactiveUser(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Service  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Service</span><br><span class="line">@Transactional &#x2F;&#x2F;DB에 Transaction처리를 위함이다</span><br><span class="line">               &#x2F;&#x2F;안해주면 update&#x2F;delete 안되었음</span><br><span class="line">public class UserService &#123;</span><br><span class="line"></span><br><span class="line">~</span><br><span class="line"></span><br><span class="line">    public User updateUser(Long id, String email, String name, Long level) &#123;</span><br><span class="line">        &#x2F;&#x2F;TODO 예외처리 추가 필요</span><br><span class="line">        User user &#x3D; userRepository.findById(id).orElse(null);</span><br><span class="line">        user.setEmail(email);</span><br><span class="line">        user.setName(name);</span><br><span class="line">        user.setLevel(level);</span><br><span class="line">        return user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public User deactiveUser(Long id) &#123;</span><br><span class="line">        User user &#x3D; userRepository.findById(id).orElse(null);</span><br><span class="line">        user.deactivate();</span><br><span class="line">        return user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>패스워드, 회원가입등은 추후 추가 예정   </p>
]]></content>
      <categories>
        <category>Study</category>
        <category>Spring Boot Project</category>
      </categories>
      <tags>
        <tag>spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title>45. 회원가입</title>
    <url>/2020/08/12/hexo_springboot_1_45/</url>
    <content><![CDATA[<h1 id="스프링-부트-프로젝트"><a href="#스프링-부트-프로젝트" class="headerlink" title="스프링 부트 프로젝트"></a>스프링 부트 프로젝트</h1><h3 id="레스토랑-예약-사이트-만들기"><a href="#레스토랑-예약-사이트-만들기" class="headerlink" title="레스토랑 예약 사이트 만들기"></a>레스토랑 예약 사이트 만들기</h3><h4 id="45-회원가입"><a href="#45-회원가입" class="headerlink" title="45. 회원가입"></a>45. 회원가입</h4><p>BCrypt를 이용한 Hash 암호화를 사용하기 위해<br>제공되는 Spring Security 프로젝트 사용<br>HttpSecurity 부분을 직접 설정할 예정이다  </p>
<p>회원가입 변수<br>Email<br>Name<br>Password (2회 인증은 보통 front에서)  </p>
<ul>
<li>eatgo-customer-api<br>Gradle - Spring security 의존성 추가<br>build.gradle<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation project(&#39;:eatgo-common&#39;)</span><br><span class="line"></span><br><span class="line">    implementation &#39;org.springframework.boot:spring-boot-starter-web&#39;</span><br><span class="line">    implementation &#39;org.springframework.boot:spring-boot-starter-security&#39;</span><br><span class="line">    implementation &#39;org.springframework.boot:spring-boot-starter-data-jpa&#39;</span><br><span class="line">    implementation &#39;com.h2database:h2&#39;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>Spring security를 의존성으로 추가하면 기본적으로 <a href="http://localhost:8080/login" target="_blank" rel="noopener">http://localhost:8080/login</a> 페이지가 제공된다. </p>
<p>그러나 따로 API 서버를 사용하기 때문에 위와같은 페이지가 불필요하다.  </p>
<p>WebSecurityConfig Class를 상속받는 Config Class를 SpringBootApplication Class와 같은 위치에 생성하고<br>configure 메서드를 Overriding하여 설정 변경    </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableWebSecurity</span><br><span class="line">public class SecurityJavaConfig extends WebSecurityConfigurerAdapter &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void configure(HttpSecurity http) throws Exception &#123;</span><br><span class="line">        http</span><br><span class="line">                .formLogin().disable() &#x2F;&#x2F;login page 사용안함  </span><br><span class="line">                &#x2F;&#x2F;Connection 관련된 부분인데 </span><br><span class="line">                &#x2F;&#x2F;disable하지 않으면 h2-console을 사용할 수 없어서 일단 설정</span><br><span class="line">                .cors().disable() </span><br><span class="line">                .csrf().disable()</span><br><span class="line">                .headers().frameOptions().disable();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Service에서 회원가입하는 기능인 registerUser()를 생성하는데<br>중복 이메일에 대한 예외클래스를 생성하고 사용하며<br>BCryptPasswordEncoder 클래스를 통해 password를 암호화한다.  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public User registerUser(String email, String name, String password) &#123;</span><br><span class="line">    Optional&lt;User&gt; existed &#x3D; userRepository.findByEmail(email);</span><br><span class="line">    if (existed.isPresent()) &#123; &#x2F;&#x2F;email로 찾은 User가 존재한다면 if문 수행</span><br><span class="line">        throw new EmailExistedException(email);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PasswordEncoder passwordEncoder &#x3D; new BCryptPasswordEncoder();</span><br><span class="line">    String encodedPassword &#x3D; passwordEncoder.encode(password); &#x2F;&#x2F;암호화 </span><br><span class="line">    User user &#x3D; User.builder()</span><br><span class="line">            .email(email)</span><br><span class="line">            .name(name)</span><br><span class="line">            .level(1L)</span><br><span class="line">            .password(encodedPassword)</span><br><span class="line">            .build();</span><br><span class="line"></span><br><span class="line">    return userRepository.save(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Service Test</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;회원가입 테스트 </span><br><span class="line">@Test</span><br><span class="line">public void registerUser() &#123;</span><br><span class="line">    String email &#x3D; &quot;rockintuna@naver.com&quot;;</span><br><span class="line">    String name &#x3D; &quot;이정인&quot;;</span><br><span class="line">    String password &#x3D; &quot;test&quot;;</span><br><span class="line">    User mockUser &#x3D; User.builder().name(name).email(email).password(password).build();</span><br><span class="line">    given(userRepository.save(any())).willReturn(mockUser);</span><br><span class="line"></span><br><span class="line">    User user &#x3D; userService.registerUser(email, name, password);</span><br><span class="line"></span><br><span class="line">    assertThat(user.getName(), is(&quot;이정인&quot;));</span><br><span class="line"></span><br><span class="line">    verify(userRepository).save(any());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;email 중복 테스트 </span><br><span class="line">@Test(expected &#x3D; EmailExistedException.class)</span><br><span class="line">public void registerUserWithExistEmail() &#123;</span><br><span class="line">    String email &#x3D; &quot;rockintuna@naver.com&quot;;</span><br><span class="line">    String name &#x3D; &quot;이정인&quot;;</span><br><span class="line">    String password &#x3D; &quot;test&quot;;</span><br><span class="line">    User mockUser &#x3D; User.builder().name(name).email(email).password(password).build();</span><br><span class="line"></span><br><span class="line">    given(userRepository.findByEmail(email)).willReturn(Optional.of(mockUser));</span><br><span class="line"></span><br><span class="line">    userService.registerUser(email, name, password);</span><br><span class="line"></span><br><span class="line">    verify(userRepository,never()).save(any());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>사용자 예외 클래스  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class EmailExistedException extends RuntimeException&#123;</span><br><span class="line"></span><br><span class="line">    EmailExistedException(String email) &#123;</span><br><span class="line">        super(&quot;Email is already registered: &quot;+email);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>계정 생성</p>
<figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> http POST localhost:8080/users email=<span class="built_in">test</span>@example.com name=Tester password=<span class="built_in">test</span></span></span><br></pre></td></tr></table></figure>

<p>DB에는 암호화된 암호가 저장된다.<br><img src="encode.png" alt="password encoding"></p>
<p>한번더 같은 메일로 생성하면 생성한 예외 발생</p>
<figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> http POST localhost:8080/users email=<span class="built_in">test</span>@example.com name=Tester password=<span class="built_in">test</span></span></span><br><span class="line">HTTP/1.1 500 </span><br><span class="line">Cache-Control: no-cache, no-store, max-age=0, must-revalidate</span><br><span class="line">Connection: close</span><br><span class="line">Content-Type: application/json;charset=UTF-8</span><br><span class="line">Date: Fri, 19 Jun 2020 09:39:13 GMT</span><br><span class="line">Expires: 0</span><br><span class="line">Pragma: no-cache</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">X-Content-Type-Options: nosniff</span><br><span class="line">X-XSS-Protection: 1; mode=block</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    "error": "Internal Server Error",</span><br><span class="line">    "message": "Email is already registered: test@example.com",</span><br><span class="line">    "path": "/users",</span><br><span class="line">    "status": 500,</span><br><span class="line">    "timestamp": "2020-06-19T09:39:13.802+0000",</span><br><span class="line">    "trace": </span><br><span class="line">~~~</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Study</category>
        <category>Spring Boot Project</category>
      </categories>
      <tags>
        <tag>spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title>48. 인증</title>
    <url>/2020/08/12/hexo_springboot_1_48/</url>
    <content><![CDATA[<h1 id="스프링-부트-프로젝트"><a href="#스프링-부트-프로젝트" class="headerlink" title="스프링 부트 프로젝트"></a>스프링 부트 프로젝트</h1><h3 id="레스토랑-예약-사이트-만들기"><a href="#레스토랑-예약-사이트-만들기" class="headerlink" title="레스토랑 예약 사이트 만들기"></a>레스토랑 예약 사이트 만들기</h3><h4 id="48-인증"><a href="#48-인증" class="headerlink" title="48. 인증"></a>48. 인증</h4><p>POST /session<br>session이라는 resource를 구현할것이다<br>session이 올바르게 만들어졌다는 정보를 유지하기위해 accessToken을 사용한다<br>DTO(Data Transfer Object)를 통해 데이터 교환<br>SessionResponseDto session 결과(accessToken 등) 교환<br>SessionRequestDto session을 만들기위한 request 데이터 교환</p>
<p>SessionResponseDto</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;SessionDTO는 accessToken등 그 외 데이터를 처리하는 Class</span><br><span class="line">@Data &#x2F;&#x2F;DTO는 순수한 data객체이기 때문에 @Data 사용하면 유용하다</span><br><span class="line">@Builder</span><br><span class="line">public class SessionResponseDto &#123;</span><br><span class="line"></span><br><span class="line">    private String accessToken;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SessionRequestDto</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Data</span><br><span class="line">public class SessionRequestDto &#123;</span><br><span class="line"></span><br><span class="line">    private String email;</span><br><span class="line">    private String password;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Session Controller</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class SessionController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private UserService userService;</span><br><span class="line"></span><br><span class="line">    @PostMapping(&quot;&#x2F;session&quot;)</span><br><span class="line">    public ResponseEntity&lt;SessionResponseDto&gt; create(</span><br><span class="line">            @RequestBody SessionRequestDto resource  &#x2F;&#x2F;리소스 확인용 requestDTO </span><br><span class="line">    ) throws URISyntaxException &#123;</span><br><span class="line">        String email &#x3D; resource.getEmail();</span><br><span class="line">        String password &#x3D; resource.getPassword();</span><br><span class="line">        User user &#x3D; userService.authenticate(email,password);</span><br><span class="line"></span><br><span class="line">        String accessToken &#x3D; user.getAccessToken();</span><br><span class="line"></span><br><span class="line">        String url &#x3D; &quot;&#x2F;session&quot;;</span><br><span class="line">        return ResponseEntity.created(new URI(url)).body(</span><br><span class="line">                SessionResponseDto.builder()  &#x2F;&#x2F;responseDTO 객체를 전달  </span><br><span class="line">                        .accessToken(accessToken)</span><br><span class="line">                        .build());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>User 도메인 모델에 토큰 확인 기능 추가</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;@JsonIgnore : requestedbody에 password가 없는경우 그냥 무시할수도 있음</span><br><span class="line">public String getAccessToken() &#123;</span><br><span class="line">    if (password &#x3D;&#x3D; null) &#123;</span><br><span class="line">        return &quot;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    return password.substring(0, 10);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JPA - User Repository findByEmail(email) 추가    </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Optional&lt;User&gt; findByEmail(String email);</span><br></pre></td></tr></table></figure>

<p>Service에 인가 기능 추가   </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public User authenticate(String email, String password) &#123;</span><br><span class="line">    &#x2F;&#x2F;email확인 후 없는 경우(아마도 비어있는 Optinal) 예외 처리</span><br><span class="line">    User user &#x3D; userRepository.findByEmail(email)</span><br><span class="line">            .orElseThrow(() -&gt; new EmailNotExistedException(email)); </span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;저장되어있는 암호화된 password와 비교하여 일치하지 않는 경우 예외처리</span><br><span class="line">    if (!passwordEncoder.matches(password, user.getPassword())) &#123;</span><br><span class="line">        throw new PasswordWrongException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SpringSecurityConfig에<br>encode(), matches() 사용을 위한 PasswordEncoder 종속 추가</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public PasswordEncoder passwordEncoder() &#123;</span><br><span class="line">    return new BCryptPasswordEncoder();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Session 예외처리를 위한 Advice 추가</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@ControllerAdvice</span><br><span class="line">public class SessionErrorAdvice &#123;</span><br><span class="line"></span><br><span class="line">    @ResponseBody</span><br><span class="line">    @ResponseStatus(HttpStatus.BAD_REQUEST)</span><br><span class="line">    @ExceptionHandler(PasswordWrongException.class)</span><br><span class="line">    public String handlePasswordWrong() &#123;</span><br><span class="line">        return &quot;&#123;&#125;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @ResponseBody</span><br><span class="line">    @ResponseStatus(HttpStatus.BAD_REQUEST)</span><br><span class="line">    @ExceptionHandler(EmailNotExistedException.class)</span><br><span class="line">    public String handleEmailNotExisted() &#123;</span><br><span class="line">        return &quot;&#123;&#125;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>사용자 예외 2가지 추가  </p>
<p>패스워드 불일치 예외</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package kr.co.fastcampus.eatgo.application;</span><br><span class="line"></span><br><span class="line">public class PasswordWrongException extends RuntimeException&#123;</span><br><span class="line"></span><br><span class="line">    PasswordWrongException() &#123;</span><br><span class="line">        super(&quot;Password is wrong.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>존재하지 않는 메일 주소 예외</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package kr.co.fastcampus.eatgo.application;</span><br><span class="line"></span><br><span class="line">public class EmailNotExistedException extends RuntimeException&#123;</span><br><span class="line"></span><br><span class="line">    EmailNotExistedException(String email) &#123;</span><br><span class="line">        super(&quot;Email is not registered : &quot;+email);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Study</category>
        <category>Spring Boot Project</category>
      </categories>
      <tags>
        <tag>spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title>52. JWT</title>
    <url>/2020/08/12/hexo_springboot_1_52/</url>
    <content><![CDATA[<h1 id="스프링-부트-프로젝트"><a href="#스프링-부트-프로젝트" class="headerlink" title="스프링 부트 프로젝트"></a>스프링 부트 프로젝트</h1><h3 id="레스토랑-예약-사이트-만들기"><a href="#레스토랑-예약-사이트-만들기" class="headerlink" title="레스토랑 예약 사이트 만들기"></a>레스토랑 예약 사이트 만들기</h3><h4 id="52-JWT"><a href="#52-JWT" class="headerlink" title="52. JWT"></a>52. JWT</h4><p>JWT (Json Web Tokens)<br>Json 포맷을 이용해 웹에서 활용할 수 있는 Access Token을 다루는 표준  </p>
<p>3 Parts<br>Header - Type, 알고리즘<br>Payload - 실제 데이터(Claims)<br>Signature - 위변조 서명  </p>
<p>Base64 URL Encoding을 통해 Json 포맷을 문자열로 변경한다.<br>문자열로 변경되면 Header.Payload.Signature 형식으로 된다.<br>위변조 되지 않았음을 증명하기 위해 HS256 알고리즘을 이용할 것이다.  </p>
<p>eatgo-common-api, build.gradle<br>Java JWT library 추가  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation &#39;org.springframework.boot:spring-boot-starter-web&#39;</span><br><span class="line">    implementation &#39;org.springframework.boot:spring-boot-starter-data-jpa&#39;</span><br><span class="line">    implementation &#39;com.h2database:h2&#39;</span><br><span class="line">    implementation &#39;io.jsonwebtoken:jjwt-api:0.10.7&#39;</span><br></pre></td></tr></table></figure>


<p>JwtUtil 클래스 추가</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class JwtUtil &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private Key key;</span><br><span class="line"></span><br><span class="line">    public JwtUtil(String secret) &#123;</span><br><span class="line">        this.key &#x3D; Keys.hmacShaKeyFor(secret.getBytes()); &#x2F;&#x2F;secret HS key 생성  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String createToken(long userId, String name) &#123;</span><br><span class="line">        String token &#x3D; Jwts.builder()  </span><br><span class="line">                .claim(&quot;userId&quot;,userId)  </span><br><span class="line">                .claim(&quot;name&quot;,name)  </span><br><span class="line">                .signWith(key, SignatureAlgorithm.HS256)  &#x2F;&#x2F;HS256 알고리즘 사용  </span><br><span class="line">                .compact();</span><br><span class="line"></span><br><span class="line">        return token;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SecurityJavaConfig 클래스에서<br>secret 참조<br>JwtUtil Bean 설정  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Value(&quot;$&#123;jwt.secret&#125;&quot;)</span><br><span class="line">private String secret;</span><br><span class="line"></span><br><span class="line">@Bean</span><br><span class="line">public JwtUtil jwtUtil() &#123;</span><br><span class="line">    return new JwtUtil(secret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SessionController accessToken 변경  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@PostMapping(&quot;&#x2F;session&quot;)</span><br><span class="line">public ResponseEntity&lt;SessionResponseDto&gt; create(</span><br><span class="line">        @RequestBody SessionRequestDto resource</span><br><span class="line">) throws URISyntaxException &#123;</span><br><span class="line">    String email &#x3D; resource.getEmail();</span><br><span class="line">    String password &#x3D; resource.getPassword();</span><br><span class="line">    User user &#x3D; userService.authenticate(email,password);</span><br><span class="line"></span><br><span class="line">    String accessToken &#x3D; jwtUtil.createToken(user.getId(), user.getName());</span><br><span class="line"></span><br><span class="line">    String url &#x3D; &quot;&#x2F;session&quot;;</span><br><span class="line">    return ResponseEntity.created(new URI(url)).body(</span><br><span class="line">            SessionResponseDto.builder()</span><br><span class="line">                    .accessToken(accessToken)</span><br><span class="line">                    .build());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>application.yml 파일에<br>Signature를 위한 코드 저장  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jwt:</span><br><span class="line">  secret: 4abcdef2148724243984789347298634934</span><br></pre></td></tr></table></figure>

<p>test<br>accessToken : Header.Payload.Signature</p>
<figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="code"><pre><span class="line">http POST localhost:8080/session email=test.example.com password=test</span><br><span class="line">HTTP/1.1 201 </span><br><span class="line">Cache-Control: no-cache, no-store, max-age=0, must-revalidate</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Content-Type: application/json;charset=UTF-8</span><br><span class="line">Date: Mon, 29 Jun 2020 14:37:00 GMT</span><br><span class="line">Expires: 0</span><br><span class="line">Keep-Alive: timeout=60</span><br><span class="line">Location: /session</span><br><span class="line">Pragma: no-cache</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">X-Content-Type-Options: nosniff</span><br><span class="line">X-XSS-Protection: 1; mode=block</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    "accessToken": "eyJhbGciOiJIUzI1NiJ9.eyJ1c2VySWQiOjIxLCJuYW1lIjoidGVzdGVyIn0.GXdLiebW_gngO3Tpi8r-MbgCQzCJgxFZg1Kf5ojG0PI"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Study</category>
        <category>Spring Boot Project</category>
      </categories>
      <tags>
        <tag>spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title>54. 인가(Authorization)</title>
    <url>/2020/08/12/hexo_springboot_1_54/</url>
    <content><![CDATA[<h1 id="스프링-부트-프로젝트"><a href="#스프링-부트-프로젝트" class="headerlink" title="스프링 부트 프로젝트"></a>스프링 부트 프로젝트</h1><h3 id="레스토랑-예약-사이트-만들기"><a href="#레스토랑-예약-사이트-만들기" class="headerlink" title="레스토랑 예약 사이트 만들기"></a>레스토랑 예약 사이트 만들기</h3><h4 id="54-인가-Authorization"><a href="#54-인가-Authorization" class="headerlink" title="54. 인가(Authorization)"></a>54. 인가(Authorization)</h4><p>인증은 사용자를 증명하는 단계였다면,<br>인가는 발급된 access Token을 어떻게 다루고<br>어떤 서비스를 사용할 수 있는지 다루는 부분이다.  </p>
<p>Http의 Header를 통해서 Access Token을 전달한다.<br>Header의 key와 value는 아래와 같은 쌍으로 전달할것이다.<br>Authorization : Bearer  </p>
<p>StateLess<br>따로 세션에 대한 정보를 저장하지 않고 받은 Token을 Filter가 계속해서 작업하도록 할 것이다.  </p>
<p>BasicAuthenticationFilter<br>Filter 추가로 모든 요청에 대해 JWT Token이 실제로 세팅되었는지 확인하고<br>Access Token에서 정보를 얻어서 사용자 정보를 활용한다.</p>
<p>UsernamePasswordAuthenticationToken<br>AuthenticationToken 객체를 활용하여 어떤사용자가 사용중인지 확인<br>JWT를 분석하여 내부적으로 사용할 AuthenticationToken을 만들것이다.  </p>
<p>eatgo-customer-api</p>
<p>JwtAuthenticationFilter 클래스 작성<br>(BasicAuthenticationFilter 클래스를 참조하고<br>doFilterInternal 메서드를 오버라이딩)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class JwtAuthenticationFilter extends BasicAuthenticationFilter &#123;</span><br><span class="line"></span><br><span class="line">    private JwtUtil jwtUtil;</span><br><span class="line"></span><br><span class="line">    public JwtAuthenticationFilter(</span><br><span class="line">            AuthenticationManager authenticationManager, JwtUtil jwtUtil) &#123;</span><br><span class="line">        super(authenticationManager);</span><br><span class="line">        this.jwtUtil &#x3D; jwtUtil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">    protected void doFilterInternal(HttpServletRequest request,</span><br><span class="line">                                    HttpServletResponse response,</span><br><span class="line">                                    FilterChain chain</span><br><span class="line">    ) throws IOException, ServletException &#123;</span><br><span class="line">        Authentication authentication &#x3D; getAuthentication(request);</span><br><span class="line"></span><br><span class="line">        if (authentication !&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F;SecurityContext 객체를 통해 인증정보 관리</span><br><span class="line">            SecurityContext context &#x3D; SecurityContextHolder.getContext();</span><br><span class="line">            context.setAuthentication(authentication);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        chain.doFilter(request,response); &#x2F;&#x2F;다음 작업으로 연결됨</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;request Header의 Authrization부분(token)으로부터 Claims 객체 생성</span><br><span class="line">    &#x2F;&#x2F;Claims으로 authentication 객체 생성 및 반환</span><br><span class="line">    private Authentication getAuthentication(HttpServletRequest request) &#123;</span><br><span class="line">        String token &#x3D; request.getHeader(&quot;Authorization&quot;);</span><br><span class="line">        if (token&#x3D;&#x3D;null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Claims claims &#x3D; jwtUtil.getClaims(token.substring(&quot;Bearer &quot;.length()));</span><br><span class="line"></span><br><span class="line">        Authentication authentication &#x3D; new UsernamePasswordAuthenticationToken(</span><br><span class="line">                claims, null); &#x2F;&#x2F;간단하게 principal로 claims 만 사용</span><br><span class="line">        return authentication;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SecurityJavaConfig 클래스 변경   </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void configure(HttpSecurity http) throws Exception &#123;</span><br><span class="line">    &#x2F;&#x2F;Filter 객체 생성</span><br><span class="line">    Filter filter &#x3D; new JwtAuthenticationFilter(</span><br><span class="line">            authenticationManager(), jwtUtil());</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    http</span><br><span class="line">            .formLogin().disable()</span><br><span class="line">            .cors().disable()</span><br><span class="line">            .csrf().disable()</span><br><span class="line">            .headers().frameOptions().disable()</span><br><span class="line">    &#x2F;&#x2F;filter 추가, session stateless 처리</span><br><span class="line">            .and()</span><br><span class="line">            .addFilter(filter)</span><br><span class="line">            .sessionManagement()</span><br><span class="line">            .sessionCreationPolicy(SessionCreationPolicy.STATELESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JwtUtil 클래스에 claim을 얻는 메서드 추가  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public Claims getClaims(String token) &#123;</span><br><span class="line"></span><br><span class="line">    Claims claims &#x3D; Jwts.parser()</span><br><span class="line">            .setSigningKey(key) &#x2F;&#x2F;key는 기존 HSkey를 활용</span><br><span class="line">            .parseClaimsJws(token) &#x2F;&#x2F;Jws : sign이 포함된 Jwt</span><br><span class="line">            .getBody();</span><br><span class="line"></span><br><span class="line">    return claims;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ReviewController의 POST 메서드<br>name을 Claim으로부터 가져오도록 변경  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@PostMapping(&quot;&#x2F;restaurants&#x2F;&#123;restaurantId&#125;&#x2F;reviews&quot;)</span><br><span class="line">public ResponseEntity&lt;?&gt; create(</span><br><span class="line">        Authentication authentication,</span><br><span class="line">        @PathVariable(&quot;restaurantId&quot;) Long restaurantId,</span><br><span class="line">        @Valid @RequestBody Review resource</span><br><span class="line">) throws URISyntaxException &#123;</span><br><span class="line">    Claims claims &#x3D; (Claims) authentication.getPrincipal();</span><br><span class="line"></span><br><span class="line">    Review review &#x3D; reviewService.addReview(</span><br><span class="line">            restaurantId,</span><br><span class="line">            claims.get(&quot;name&quot;, String.class),</span><br><span class="line">            resource.getScore(),</span><br><span class="line">            resource.getDescription());</span><br><span class="line"></span><br><span class="line">    String url &#x3D; &quot;&#x2F;restaurants&#x2F;&quot;+restaurantId+&quot;&#x2F;reviews&#x2F;&quot;+review.getId();</span><br><span class="line">    return ResponseEntity.created(new URI(url))</span><br><span class="line">            .body(&quot;&#123;&#125;&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>test(http)<br>header의 “Authorization”을 참조하여 인증 및 name 활용</p>
<figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> http POST localhost:8080/restaurants/1/reviews score=3 description=<span class="string">"종습니다."</span> <span class="string">"Authorization:Bearer eyJhbGciOiJIUzI1NiJ9.eyJ1c2VySWQiOjEwMDQsIm5hbWUiOiLsnbTsoJXsnbgifQ.wKrAIT-cOCfQwBO_8UkhK_IOy4tl8uuIeBS4nppu_Vw"</span></span></span><br><span class="line">HTTP/1.1 201 </span><br><span class="line">Cache-Control: no-cache, no-store, max-age=0, must-revalidate</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Content-Length: 2</span><br><span class="line">Content-Type: application/json;charset=UTF-8</span><br><span class="line">Date: Fri, 03 Jul 2020 11:16:35 GMT</span><br><span class="line">Expires: 0</span><br><span class="line">Keep-Alive: timeout=60</span><br><span class="line">Location: /restaurants/1/reviews/22</span><br><span class="line">Pragma: no-cache</span><br><span class="line">X-Content-Type-Options: nosniff</span><br><span class="line">X-XSS-Protection: 1; mode=block</span><br><span class="line"></span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> http GET localhost:8080/restaurants/1                                                                                     HTTP/1.1 200                                                                               </span></span><br><span class="line">Cache-Control: no-cache, no-store, max-age=0, must-revalidate</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Content-Type: application/json;charset=UTF-8</span><br><span class="line">Date: Fri, 03 Jul 2020 11:16:37 GMT</span><br><span class="line">Expires: 0</span><br><span class="line">Keep-Alive: timeout=60</span><br><span class="line">Pragma: no-cache</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">X-Content-Type-Options: nosniff</span><br><span class="line">X-XSS-Protection: 1; mode=block</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    "address": "서울 마포구",</span><br><span class="line">    "categoryId": 1,</span><br><span class="line">    "id": 1,</span><br><span class="line">    "information": "밥집 in 서울 마포구",</span><br><span class="line">    "menuItems": [</span><br><span class="line">        &#123;</span><br><span class="line">            "id": 2,</span><br><span class="line">            "name": "Kimchi",</span><br><span class="line">            "restaurantId": 1</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            "id": 3,</span><br><span class="line">            "name": "Gukbob",</span><br><span class="line">            "restaurantId": 1</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            "id": 6,</span><br><span class="line">            "name": "Kimchi",</span><br><span class="line">            "restaurantId": 1</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            "id": 7,</span><br><span class="line">            "name": "Rice",</span><br><span class="line">            "restaurantId": 1</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    "name": "밥집",</span><br><span class="line">    "reviews": [</span><br><span class="line">        &#123;</span><br><span class="line">            "description": "Cool",</span><br><span class="line">            "id": 10,</span><br><span class="line">            "name": "jilee",</span><br><span class="line">            "restaurantId": 1,</span><br><span class="line">            "score": 4</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            "description": "종습니다.",</span><br><span class="line">            "id": 22,</span><br><span class="line">            "name": "이정인",</span><br><span class="line">            "restaurantId": 1,</span><br><span class="line">            "score": 3</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Study</category>
        <category>Spring Boot Project</category>
      </categories>
      <tags>
        <tag>spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title>56. 로그인 API 분리</title>
    <url>/2020/08/12/hexo_springboot_1_56/</url>
    <content><![CDATA[<h1 id="스프링-부트-프로젝트"><a href="#스프링-부트-프로젝트" class="headerlink" title="스프링 부트 프로젝트"></a>스프링 부트 프로젝트</h1><h3 id="레스토랑-예약-사이트-만들기"><a href="#레스토랑-예약-사이트-만들기" class="headerlink" title="레스토랑 예약 사이트 만들기"></a>레스토랑 예약 사이트 만들기</h3><h4 id="56-로그인-API-분리"><a href="#56-로그인-API-분리" class="headerlink" title="56. 로그인 API 분리"></a>56. 로그인 API 분리</h4><p>eatgo-login-api를 새로 만들어 로그인 처리를 할것이다.<br>이게 가능한 이유는 Stateless이기 때문인데<br>사용자의 로그인 등 활동에 대해서는 관리하지 않지만 JWT의 accessToken을 활용할 수 있다.  </p>
<p>eatgo-login-api<br>UserService에서 인증 부분만 login API로 옮겼다.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Service</span><br><span class="line">@Transactional</span><br><span class="line">public class UserService &#123;</span><br><span class="line"></span><br><span class="line">    private UserRepository userRepository;</span><br><span class="line">    private PasswordEncoder passwordEncoder;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    public UserService(UserRepository userRepository, PasswordEncoder passwordEncoder) &#123;</span><br><span class="line">        this.userRepository &#x3D; userRepository;</span><br><span class="line">        this.passwordEncoder &#x3D; passwordEncoder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public User authenticate(String email, String password) &#123;</span><br><span class="line">        User user &#x3D; userRepository.findByEmail(email)</span><br><span class="line">                .orElseThrow(() -&gt; new EmailNotExistedException(email));</span><br><span class="line"></span><br><span class="line">        if (!passwordEncoder.matches(password, user.getPassword())) &#123;</span><br><span class="line">            throw new PasswordWrongException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Session과 관련된 부분을 모두 login API로 Move하였다.<br>SessionController, SessionRequestDto, SessionResponseDto, SessionErrorAdvice  </p>
<p>일반 고객과 가게 주인의 계정 정보를 구분하기 위하여<br>User 객체의 restaurantId 속성을 만들어서 null이 아니면 가게 주인으로 인식되도록 하였고<br>setrestaurantId()를 실행하면 level이 자동으로 바뀌도록 하였다.</p>
<p>User Class</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private Long restaurantId;</span><br><span class="line"></span><br><span class="line">public void setRestaurantId(Long restaurantId) &#123;</span><br><span class="line">    this.level &#x3D; 50L;</span><br><span class="line">    this.restaurantId &#x3D; restaurantId;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public boolean isRestaurantOwner() &#123;</span><br><span class="line">    return level &#x3D;&#x3D; 50;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>로그인 할때 JWT token을 생성하는 부분에서<br>가게 주인일 경우에만 Claims에 restaurantId까지 추가하기 위해<br>JwtUtil, SessionController 수정  </p>
<p>JwtUtil.creation() 메서드 수정</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public String createToken(long userId, String name, Long restaurantId) &#123;</span><br><span class="line">    JwtBuilder builder &#x3D; Jwts.builder()</span><br><span class="line">            .claim(&quot;userId&quot;, userId)</span><br><span class="line">            .claim(&quot;name&quot;, name);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;restaurantId가 null이 아닌경우만 restaurantId를 claims에 추가</span><br><span class="line">    if (restaurantId !&#x3D; null) &#123;</span><br><span class="line">        builder.claim(&quot;restaurantId&quot;,restaurantId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String token &#x3D; builder</span><br><span class="line">            .signWith(key, SignatureAlgorithm.HS256)</span><br><span class="line">            .compact();</span><br><span class="line"></span><br><span class="line">    return token ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SessionController POST 메서드 수정</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@PostMapping(&quot;&#x2F;session&quot;)</span><br><span class="line">public ResponseEntity&lt;SessionResponseDto&gt; create(</span><br><span class="line">        @RequestBody SessionRequestDto resource</span><br><span class="line">) throws URISyntaxException &#123;</span><br><span class="line">    String email &#x3D; resource.getEmail();</span><br><span class="line">    String password &#x3D; resource.getPassword();</span><br><span class="line"></span><br><span class="line">    User user &#x3D; userService.authenticate(email,password);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;가게 주인인경우만 restaurantId를 보내고 아니면 null</span><br><span class="line">    String accessToken &#x3D; jwtUtil.createToken(</span><br><span class="line">            user.getId(),</span><br><span class="line">            user.getName(),</span><br><span class="line">            user.isRestaurantOwner() ? user.getRestaurantId(): null);</span><br><span class="line"></span><br><span class="line">    String url &#x3D; &quot;&#x2F;session&quot;;</span><br><span class="line">    return ResponseEntity.created(new URI(url)).body(</span><br><span class="line">            SessionResponseDto.builder()</span><br><span class="line">                    .accessToken(accessToken)</span><br><span class="line">                    .build());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Study</category>
        <category>Spring Boot Project</category>
      </categories>
      <tags>
        <tag>spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title>59. 테이블 예약 기능</title>
    <url>/2020/08/12/hexo_springboot_1_59/</url>
    <content><![CDATA[<h1 id="스프링-부트-프로젝트"><a href="#스프링-부트-프로젝트" class="headerlink" title="스프링 부트 프로젝트"></a>스프링 부트 프로젝트</h1><h3 id="레스토랑-예약-사이트-만들기"><a href="#레스토랑-예약-사이트-만들기" class="headerlink" title="레스토랑 예약 사이트 만들기"></a>레스토랑 예약 사이트 만들기</h3><h4 id="59-테이블-예약-기능"><a href="#59-테이블-예약-기능" class="headerlink" title="59. 테이블 예약 기능"></a>59. 테이블 예약 기능</h4><p>eatgo-restaurant-api 를 추가하여 가게 주인이 사용하는 부분 추가할 것이다.  </p>
<p>Reservation 도메인 모델을 추가 할 것이다.<br>속성 : userId, name, date, time, partySize…  </p>
<p>예약<br>POST /reservations  </p>
<p>예약 확인<br>GET /reservations  </p>
<p>eatgo-common-api<br>Reservation 모델 생성</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Entity</span><br><span class="line">@Getter</span><br><span class="line">@Builder</span><br><span class="line">@AllArgsConstructor</span><br><span class="line">@NoArgsConstructor</span><br><span class="line">public class Reservation &#123;</span><br><span class="line"></span><br><span class="line">    @Id</span><br><span class="line">    @GeneratedValue</span><br><span class="line">    private Long id;</span><br><span class="line"></span><br><span class="line">    private Long restaurantId;</span><br><span class="line"></span><br><span class="line">    private Long userId;</span><br><span class="line"></span><br><span class="line">    @Setter</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    @Setter</span><br><span class="line">    @NotEmpty</span><br><span class="line">    private String date;</span><br><span class="line"></span><br><span class="line">    @Setter</span><br><span class="line">    @NotEmpty</span><br><span class="line">    private String time;</span><br><span class="line"></span><br><span class="line">    @Setter</span><br><span class="line">    @NotNull</span><br><span class="line">    private Integer partySize;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Reservation Repository</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface ReservationRepository extends CrudRepository&lt;Reservation, Long&gt; &#123;</span><br><span class="line"></span><br><span class="line">    Reservation save(Reservation reservation);</span><br><span class="line"></span><br><span class="line">    List&lt;Reservation&gt; findAllByRestaurantId(Long restaurantId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>eatgo-customer-api<br>Reservation Controller</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class ReservationController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private ReservationService reservationService;</span><br><span class="line"></span><br><span class="line">    @PostMapping(&quot;&#x2F;restaurants&#x2F;&#123;restaurantId&#125;&#x2F;reservations&quot;)</span><br><span class="line">    public ResponseEntity&lt;?&gt; create(</span><br><span class="line">            Authentication authentication,</span><br><span class="line">            @RequestBody Reservation resource,</span><br><span class="line">            @Valid @PathVariable(&quot;restaurantId&quot;) Long restaurantId</span><br><span class="line">    ) throws URISyntaxException &#123;</span><br><span class="line">        Claims claims &#x3D; (Claims) authentication.getPrincipal();</span><br><span class="line"></span><br><span class="line">        Reservation reservation &#x3D; reservationService.addReservation(</span><br><span class="line">                restaurantId,</span><br><span class="line">                claims.get(&quot;userId&quot;, Long.class),</span><br><span class="line">                claims.get(&quot;name&quot;, String.class),</span><br><span class="line">                resource.getDate(),</span><br><span class="line">                resource.getTime(),</span><br><span class="line">                resource.getPartySize()</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        String url &#x3D; &quot;&#x2F;restaurants&#x2F;&quot;+restaurantId+&quot;&#x2F;reservations&quot;+reservation.getId();</span><br><span class="line"></span><br><span class="line">        return ResponseEntity.created(new URI(url)).body(&quot;&#123;&#125;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Reservation Service</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Service</span><br><span class="line">@Transactional</span><br><span class="line">public class ReservationService &#123;</span><br><span class="line"></span><br><span class="line">    private ReservationRepository reservationRepository;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    public ReservationService(ReservationRepository reservationRepository) &#123;</span><br><span class="line">        this.reservationRepository &#x3D; reservationRepository;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Reservation addReservation(</span><br><span class="line">            Long restaurantId,</span><br><span class="line">            Long userId,</span><br><span class="line">            String name,</span><br><span class="line">            String date,</span><br><span class="line">            String time,</span><br><span class="line">            Integer partySize) &#123;</span><br><span class="line"></span><br><span class="line">        Reservation reservation &#x3D; Reservation.builder()</span><br><span class="line">                        .restaurantId(restaurantId)</span><br><span class="line">                        .userId(userId)</span><br><span class="line">                        .name(name)</span><br><span class="line">                        .date(date)</span><br><span class="line">                        .time(time)</span><br><span class="line">                        .partySize(partySize)</span><br><span class="line">                        .build();</span><br><span class="line"></span><br><span class="line">        return reservationRepository.save(reservation);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>test(http) 예약</p>
<figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> http POST localhost:8080/restaurants/1/reservations date=2019-12-24 time=30:00 partySize=10 <span class="string">"Authorization:Bearer eyJhbGciOiJIUzI1NiJ9.eyJ1c2VySWQiOjEwMDQsIm5hbWUiOiLsnbTsoJXsnbgifQ.wKrAIT-cOCfQwBO_8UkhK_IOy4tl8uuIeBS4nppu_Vw"</span>         </span></span><br><span class="line">HTTP/1.1 201 </span><br><span class="line">Cache-Control: no-cache, no-store, max-age=0, must-revalidate</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Content-Length: 2</span><br><span class="line">Content-Type: application/json;charset=UTF-8</span><br><span class="line">Date: Fri, 03 Jul 2020 16:36:17 GMT</span><br><span class="line">Expires: 0</span><br><span class="line">Keep-Alive: timeout=60</span><br><span class="line">Location: /restaurants/1/reservations24</span><br><span class="line">Pragma: no-cache</span><br><span class="line">X-Content-Type-Options: nosniff</span><br><span class="line">X-XSS-Protection: 1; mode=block</span><br><span class="line"></span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>


<p>eatgo-restaurant-api에서 예약 확인용으로 사용될 Reservation Controller와 Service를 다르게 생성  </p>
<p>Reservation Service</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Service</span><br><span class="line">@Transactional</span><br><span class="line">public class ReservationService &#123;</span><br><span class="line"></span><br><span class="line">    private ReservationRepository reservationRepository;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    public ReservationService(ReservationRepository reservationRepository) &#123;</span><br><span class="line">        this.reservationRepository &#x3D; reservationRepository;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;Claim으로부터 얻은 restaurantId 기준으로 예약을 조회할것이다.</span><br><span class="line">    public List&lt;Reservation&gt; getReservations(Long restaurantId) &#123;</span><br><span class="line">        return reservationRepository.findAllByRestaurantId(restaurantId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Reservation Controller</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class ReservationController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private ReservationService reservationService;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;&#x2F;reservations&quot;)</span><br><span class="line">    public List&lt;Reservation&gt; list(</span><br><span class="line">            Authentication authentication</span><br><span class="line">    ) &#123;</span><br><span class="line">        Claims claims &#x3D; (Claims) authentication.getPrincipal();</span><br><span class="line"></span><br><span class="line">        Long restaurantId &#x3D; claims.get(&quot;restaurantId&quot;,Long.class);</span><br><span class="line">        return reservationService.getReservations(restaurantId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>test(http) 예약 확인  </p>
<figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> http localhost:8080/reservations <span class="string">"Authorization:Bearer eyJhbGciOiJIUzI1NiJ9.eyJ1c2VySWQiOjIsIm5hbWUiOiLqsIDqsozso7zsnbgiLCJyZXN0YXVyYW50SWQiOjF9.0mje-W_SREwyp6JLxkVPl-MsxwzAiQo4xVZcb-a7pFo"</span>                                              </span></span><br><span class="line">HTTP/1.1 200 </span><br><span class="line">Cache-Control: no-cache, no-store, max-age=0, must-revalidate</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Content-Type: application/json;charset=UTF-8</span><br><span class="line">Date: Fri, 03 Jul 2020 16:42:27 GMT</span><br><span class="line">Expires: 0</span><br><span class="line">Keep-Alive: timeout=60</span><br><span class="line">Pragma: no-cache</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">X-Content-Type-Options: nosniff</span><br><span class="line">X-XSS-Protection: 1; mode=block</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        "date": "2019-12-24",</span><br><span class="line">        "id": 24,</span><br><span class="line">        "name": "이정인",</span><br><span class="line">        "partySize": 10,</span><br><span class="line">        "restaurantId": 1,</span><br><span class="line">        "time": "30:00",</span><br><span class="line">        "userId": 1004</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Study</category>
        <category>Spring Boot Project</category>
      </categories>
      <tags>
        <tag>spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title>62. API 한번에 실행하기</title>
    <url>/2020/08/12/hexo_springboot_1_62/</url>
    <content><![CDATA[<h1 id="스프링-부트-프로젝트"><a href="#스프링-부트-프로젝트" class="headerlink" title="스프링 부트 프로젝트"></a>스프링 부트 프로젝트</h1><h3 id="레스토랑-예약-사이트-만들기"><a href="#레스토랑-예약-사이트-만들기" class="headerlink" title="레스토랑 예약 사이트 만들기"></a>레스토랑 예약 사이트 만들기</h3><h4 id="62-API-한번에-실행하기"><a href="#62-API-한번에-실행하기" class="headerlink" title="62. API 한번에 실행하기"></a>62. API 한번에 실행하기</h4><p>MySQL DB를 사용할것임<br>Container 기술을 활용하여 하나의 컴퓨터에서 가상화된 여러 개의 Container를 올려 여러 서버를 동시에 실행 (Docker)<br>Docker Compose를 활용  </p>
<p>build.gradle 의존성 추가</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">~</span><br><span class="line">	implementation &#39;mysql:mysql-connector-java&#39;</span><br><span class="line">~</span><br></pre></td></tr></table></figure>

<p>application.yml datasource 추가</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  profiles: mysql</span><br><span class="line">  datasource:</span><br><span class="line">    url: jdbc:mysql:&#x2F;&#x2F;$&#123;MYSQL_HOST&#125;:3306&#x2F;$&#123;MYSQL_DATABASE&#125;</span><br><span class="line">    username: $&#123;MYSQL_USER&#125;</span><br><span class="line">    password: $&#123;MYSQL_PASSWORD&#125;</span><br></pre></td></tr></table></figure>

<p>docker-compose.yml 생성<br>각 서비스 등록  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">version: &#39;3&#39;</span><br><span class="line">services:</span><br><span class="line">  mysql:</span><br><span class="line">    image: mariadb:10.4.7</span><br><span class="line">    env_file: .env</span><br><span class="line">    volumes:</span><br><span class="line">      - .&#x2F;data&#x2F;mariadb:&#x2F;var&#x2F;lib&#x2F;mysql</span><br><span class="line">    ports:</span><br><span class="line">      - 13306:3306</span><br><span class="line">    command: |</span><br><span class="line">      --character-set-server&#x3D;utf8mb4</span><br><span class="line">      --collation-server&#x3D;utf8mb4_unicode_ci</span><br><span class="line">    healthcheck:</span><br><span class="line">      test: [&quot;CMD&quot;, &quot;mysqladmin&quot; ,&quot;ping&quot;, &quot;-h&quot;, &quot;localhost&quot;]</span><br><span class="line">      timeout: 10s</span><br><span class="line">      retries: 10</span><br><span class="line">  login-api:</span><br><span class="line">    image: openjdk:11</span><br><span class="line">    env_file: .env</span><br><span class="line">    volumes:</span><br><span class="line">      - .&#x2F;run.sh:&#x2F;Users&#x2F;ijeong-in&#x2F;Git_repo&#x2F;eatgo&#x2F;run.sh</span><br><span class="line">      - .&#x2F;eatgo-login-api&#x2F;build&#x2F;libs:&#x2F;Users&#x2F;ijeong-in&#x2F;Git_repo&#x2F;eatgo&#x2F;libs</span><br><span class="line">    ports:</span><br><span class="line">      - 8001:8080</span><br><span class="line">    depends_on:</span><br><span class="line">      - mysql</span><br><span class="line">    command: bash -c &quot;cd &#x2F;Users&#x2F;ijeong-in&#x2F;Git_repo&#x2F;eatgo &amp;&amp; sh run.sh&quot;</span><br><span class="line">  admin-api:</span><br><span class="line">    image: openjdk:11</span><br><span class="line">    env_file: .env</span><br><span class="line">    volumes:</span><br><span class="line">      - .&#x2F;run.sh:&#x2F;Users&#x2F;ijeong-in&#x2F;Git_repo&#x2F;eatgo&#x2F;run.sh</span><br><span class="line">      - .&#x2F;eatgo-admin-api&#x2F;build&#x2F;libs:&#x2F;Users&#x2F;ijeong-in&#x2F;Git_repo&#x2F;eatgo&#x2F;libs</span><br><span class="line">    ports:</span><br><span class="line">      - 8002:8080</span><br><span class="line">    depends_on:</span><br><span class="line">      - mysql</span><br><span class="line">    command: bash -c &quot;cd &#x2F;Users&#x2F;ijeong-in&#x2F;Git_repo&#x2F;eatgo &amp;&amp; sh run.sh&quot;</span><br><span class="line">  customer-api:</span><br><span class="line">    image: openjdk:11</span><br><span class="line">    env_file: .env</span><br><span class="line">    volumes:</span><br><span class="line">      - .&#x2F;run.sh:&#x2F;Users&#x2F;ijeong-in&#x2F;Git_repo&#x2F;eatgo&#x2F;run.sh</span><br><span class="line">      - .&#x2F;eatgo-customer-api&#x2F;build&#x2F;libs:&#x2F;Users&#x2F;ijeong-in&#x2F;Git_repo&#x2F;eatgo&#x2F;libs</span><br><span class="line">    ports:</span><br><span class="line">      - 8003:8080</span><br><span class="line">    depends_on:</span><br><span class="line">      - mysql</span><br><span class="line">    command: bash -c &quot;cd &#x2F;Users&#x2F;ijeong-in&#x2F;Git_repo&#x2F;eatgo &amp;&amp; sh run.sh&quot;</span><br><span class="line">  restaurant-api:</span><br><span class="line">    image: openjdk:11</span><br><span class="line">    env_file: .env</span><br><span class="line">    volumes:</span><br><span class="line">      - .&#x2F;run.sh:&#x2F;Users&#x2F;ijeong-in&#x2F;Git_repo&#x2F;eatgo&#x2F;run.sh</span><br><span class="line">      - .&#x2F;eatgo-restaurant-api&#x2F;build&#x2F;libs:&#x2F;Users&#x2F;ijeong-in&#x2F;Git_repo&#x2F;eatgo&#x2F;libs</span><br><span class="line">    ports:</span><br><span class="line">      - 8004:8080</span><br><span class="line">    depends_on:</span><br><span class="line">      - mysql</span><br><span class="line">    command: bash -c &quot;cd &#x2F;Users&#x2F;ijeong-in&#x2F;Git_repo&#x2F;eatgo &amp;&amp; sh run.sh&quot;</span><br><span class="line">  admin-web:</span><br><span class="line">    image: node:10.16.3</span><br><span class="line">    volumes:</span><br><span class="line">      - .&#x2F;eatgo-admin-web:&#x2F;Users&#x2F;ijeong-in&#x2F;Git_repo&#x2F;eatgo</span><br><span class="line">    ports:</span><br><span class="line">      - 8082:3000</span><br><span class="line">    environment:</span><br><span class="line">      - VUE_APP_API_BASE_URL&#x3D;http:&#x2F;&#x2F;localhost:8002</span><br><span class="line">      - VUE_APP_LOGIN_API_BASE_URL&#x3D;http:&#x2F;&#x2F;localhost:8001</span><br><span class="line">    command: bash -c &quot;cd &#x2F;Users&#x2F;ijeong-in&#x2F;Git_repo&#x2F;eatgo &amp;&amp; npm run serve&quot;</span><br><span class="line">    healthcheck:</span><br><span class="line">      test: curl -sS http:&#x2F;&#x2F;localhost:8080 || exit 1</span><br><span class="line">      timeout: 10s</span><br><span class="line">      retries: 10</span><br><span class="line">  customer-web:</span><br><span class="line">    image: node:10.16.3</span><br><span class="line">    volumes:</span><br><span class="line">      - .&#x2F;eatgo-customer-web:&#x2F;Users&#x2F;ijeong-in&#x2F;Git_repo&#x2F;eatgo</span><br><span class="line">    ports:</span><br><span class="line">      - 8083:3000</span><br><span class="line">    environment:</span><br><span class="line">      - VUE_APP_API_BASE_URL&#x3D;http:&#x2F;&#x2F;localhost:8003</span><br><span class="line">      - VUE_APP_LOGIN_API_BASE_URL&#x3D;http:&#x2F;&#x2F;localhost:8001</span><br><span class="line">    command: bash -c &quot;cd &#x2F;Users&#x2F;ijeong-in&#x2F;Git_repo&#x2F;eatgo &amp;&amp; npm run serve&quot;</span><br><span class="line">    healthcheck:</span><br><span class="line">      test: curl -sS http:&#x2F;&#x2F;localhost:8080 || exit 1</span><br><span class="line">      timeout: 10s</span><br><span class="line">      retries: 10</span><br><span class="line">  restaurant-web:</span><br><span class="line">    image: node:10.16.3</span><br><span class="line">    volumes:</span><br><span class="line">      - .&#x2F;eatgo-restaurant-web:&#x2F;Users&#x2F;ijeong-in&#x2F;Git_repo&#x2F;eatgo</span><br><span class="line">    ports:</span><br><span class="line">      - 8084:3000</span><br><span class="line">    environment:</span><br><span class="line">      - VUE_APP_API_BASE_URL&#x3D;http:&#x2F;&#x2F;localhost:8004</span><br><span class="line">      - VUE_APP_LOGIN_API_BASE_URL&#x3D;http:&#x2F;&#x2F;localhost:8001</span><br><span class="line">    command: bash -c &quot;cd &#x2F;Users&#x2F;ijeong-in&#x2F;Git_repo&#x2F;eatgo &amp;&amp; npm run serve&quot;</span><br><span class="line">    healthcheck:</span><br><span class="line">      test: curl -sS http:&#x2F;&#x2F;localhost:8080 || exit 1</span><br><span class="line">      timeout: 10s</span><br><span class="line">      retries: 10</span><br></pre></td></tr></table></figure>

<p>DB 및 API 서비스 실행시 적용되는 환경설정 파일(.env)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MYSQL_ROOT_PASSWORD&#x3D;password</span><br><span class="line">MYSQL_USER&#x3D;root</span><br><span class="line">MYSQL_PASSWORD&#x3D;password</span><br><span class="line">MYSQL_DATABASE&#x3D;eatgo</span><br><span class="line">MYSQL_HOST&#x3D;mysql</span><br><span class="line"></span><br><span class="line">SPRING_PROFILES_ACTIVE&#x3D;mysql</span><br></pre></td></tr></table></figure>

<p>각 API 서비스에서 jar파일을 실행할 run.sh</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">until java -jar libs&#x2F;*.jar</span><br><span class="line">do</span><br><span class="line">  printf &quot;******************************************************************&quot;</span><br><span class="line">  sleep 5</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>docker-compose를 통하여 묶어서 단계적으로 실행</p>
<figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker-compose up</span></span><br></pre></td></tr></table></figure>

<p>Docker Container list 확인</p>
<figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker-compose ps</span></span><br><span class="line">         Name                       Command                State     Ports</span><br><span class="line">--------------------------------------------------------------------------</span><br><span class="line">eatgo_admin-api_1        bash -c cd /Users/ijeong-i ...   Exit 137        </span><br><span class="line">eatgo_admin-web_1        docker-entrypoint.sh bash  ...   Exit 0          </span><br><span class="line">eatgo_customer-api_1     bash -c cd /Users/ijeong-i ...   Exit 137        </span><br><span class="line">eatgo_customer-web_1     docker-entrypoint.sh bash  ...   Exit 0          </span><br><span class="line">eatgo_login-api_1        bash -c cd /Users/ijeong-i ...   Exit 137        </span><br><span class="line">eatgo_mysql_1            docker-entrypoint.sh --cha ...   Exit 0          </span><br><span class="line">eatgo_restaurant-api_1   bash -c cd /Users/ijeong-i ...   Exit 137        </span><br><span class="line">eatgo_restaurant-web_1   docker-entrypoint.sh bash  ...   Exit 0</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Study</category>
        <category>Spring Boot Project</category>
      </categories>
      <tags>
        <tag>spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title>05.HelloWorld</title>
    <url>/2020/08/12/hexo_springboot_2_05/</url>
    <content><![CDATA[<h1 id="스프링-부트-프로젝트"><a href="#스프링-부트-프로젝트" class="headerlink" title="스프링 부트 프로젝트"></a>스프링 부트 프로젝트</h1><h3 id="지인-정보-관리-시스템-만들기"><a href="#지인-정보-관리-시스템-만들기" class="headerlink" title="지인 정보 관리 시스템 만들기"></a>지인 정보 관리 시스템 만들기</h3><h4 id="05-HelloWorld"><a href="#05-HelloWorld" class="headerlink" title="05.HelloWorld"></a>05.HelloWorld</h4><ul>
<li>Junit5, MockMvc  </li>
</ul>
<p>@RestController 에는 @Controller와 @ResponseBody가 포함되어 있다.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class HelloWorldController &#123;</span><br><span class="line"></span><br><span class="line">    @GetMapping(value &#x3D; &quot;&#x2F;api&#x2F;helloWorld&quot;)</span><br><span class="line">    public String helloWorld() &#123;</span><br><span class="line">        return &quot;Hello World!&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>junit5에서는 junit4와 다르게 테스트 메서드가 public이 강제되지 않는다.<br>여기서는 public 대신 default 접근자를 사용하였다.<br>모의 http request와 response를 만들어서 테스트하는 것이 MockMvc test이다.  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@SpringBootTest &#x2F;&#x2F;Spring Boot Test임을 명</span><br><span class="line">class HelloWorldControllerTest &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private HelloWorldController helloWorldController;</span><br><span class="line"></span><br><span class="line">    private MockMvc mockMvc;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    void mockMvcTest() throws Exception &#123;</span><br><span class="line">        &#x2F;&#x2F;MockMvc setting </span><br><span class="line">        mockMvc &#x3D; MockMvcBuilders.standaloneSetup(helloWorldController).build();</span><br><span class="line"></span><br><span class="line">        mockMvc.perform(</span><br><span class="line">                MockMvcRequestBuilders.get(&quot;&#x2F;api&#x2F;helloWorld&quot;)</span><br><span class="line">        ).andDo(MockMvcResultHandlers.print()) &#x2F;&#x2F;request, response 상세 출력  </span><br><span class="line">        .andExpect(MockMvcResultMatchers.status().isOk()) &#x2F;&#x2F;status 200?  </span><br><span class="line">        .andExpect(MockMvcResultMatchers.content().string(&quot;Hello World!&quot;));  &#x2F;&#x2F;body 확인  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>JPA  </li>
</ul>
<p>JPA 및 H2 DB 의존성 추가  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    ~</span><br><span class="line">    implementation &#39;org.springframework.boot:spring-boot-starter-data-jpa&#39;</span><br><span class="line">    implementation &#39;com.h2database.h2&#39;</span><br><span class="line">    ~</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Entity, Repository 생성 및 테스트  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Entity</span><br><span class="line">@Builder</span><br><span class="line">@Setter</span><br><span class="line">@Getter</span><br><span class="line">@ToString&#x2F;&#x2F;toString 메서드 오버라이딩  </span><br><span class="line">@AllArgsConstructor</span><br><span class="line">@NoArgsConstructor</span><br><span class="line">@EqualsAndHashCode &#x2F;&#x2F;속성이 모두 동일하면 같은 객체로 인식하도록</span><br><span class="line">&#x2F;&#x2F;@RequiredArgsConstructor &#x2F;&#x2F;NonNull 어노테이션으로 정의된 속성으로만 생성자 정의  </span><br><span class="line">public class Person &#123;</span><br><span class="line"></span><br><span class="line">    @Id</span><br><span class="line">    @GeneratedValue</span><br><span class="line">    private long id;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;@NonNull</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;@NonNull</span><br><span class="line">    private int age;</span><br><span class="line"></span><br><span class="line">    private String hobby;</span><br><span class="line"></span><br><span class="line">    private String bloodType;</span><br><span class="line"></span><br><span class="line">    private String address;</span><br><span class="line"></span><br><span class="line">    private LocalDate birthDay;</span><br><span class="line"></span><br><span class="line">    private String job;</span><br><span class="line"></span><br><span class="line">    @ToString.Exclude &#x2F;&#x2F;toString 오버라이딩에서 제외  </span><br><span class="line">    private String phoneNumber;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface PersonRepository extends JpaRepository&lt;Person, Long&gt; &#123;</span><br><span class="line">&#x2F;&#x2F;Person을 Entity로 가지는 JPA Repository 생성, @Id의 타입은 Long  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JPA 실제 수행되는 SQL문 확인하기<br>application.yml</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  jpa:</span><br><span class="line">    show-sql: true</span><br></pre></td></tr></table></figure>

<p>Create / Read Test</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@SpringBootTest</span><br><span class="line">class PersonRepositoryTest &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private PersonRepository personRepository;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    void crud() &#123;</span><br><span class="line">        Person person &#x3D; Person.builder()</span><br><span class="line">                .name(&quot;robin&quot;)</span><br><span class="line">                .age(10)</span><br><span class="line">                .build();</span><br><span class="line">        personRepository.save(person);</span><br><span class="line"></span><br><span class="line">        List&lt;Person&gt; people &#x3D; personRepository.findAll();</span><br><span class="line">        assertThat(people.size()).isEqualTo(1);</span><br><span class="line">        assertThat(people.get(0).getName()).isEqualTo(&quot;robin&quot;);</span><br><span class="line">        assertThat(people.get(0).getAge()).isEqualTo(10);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Study</category>
        <category>Spring Boot Project</category>
      </categories>
      <tags>
        <tag>spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title>10. JPA Relation</title>
    <url>/2020/08/12/hexo_springboot_2_10/</url>
    <content><![CDATA[<h1 id="스프링-부트-프로젝트"><a href="#스프링-부트-프로젝트" class="headerlink" title="스프링 부트 프로젝트"></a>스프링 부트 프로젝트</h1><h3 id="지인-정보-관리-시스템-만들기"><a href="#지인-정보-관리-시스템-만들기" class="headerlink" title="지인 정보 관리 시스템 만들기"></a>지인 정보 관리 시스템 만들기</h3><h4 id="10-JPA-Relation"><a href="#10-JPA-Relation" class="headerlink" title="10. JPA Relation"></a>10. JPA Relation</h4><p>차단 사람을 구분하기 위한 Block Entity 생성  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Entity</span><br><span class="line">@NoArgsConstructor</span><br><span class="line">@Data</span><br><span class="line">@Builder</span><br><span class="line">@AllArgsConstructor</span><br><span class="line">@RequiredArgsConstructor</span><br><span class="line">public class Block &#123;</span><br><span class="line"></span><br><span class="line">    @Id</span><br><span class="line">    @GeneratedValue</span><br><span class="line">    private long id;</span><br><span class="line"></span><br><span class="line">    @NonNull</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    private String reason;</span><br><span class="line"></span><br><span class="line">    private LocalDate startDate;</span><br><span class="line"></span><br><span class="line">    private LocalDate endDate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Person Entity와 Relation 설정<br>Block의 유무만 판단할 것이므로 일대일 단방향<br>@JoinColumn 어노테이션이 없으면 @Id로 제약조건이 생성됨  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;CascadeType.PERSIST는 이 엔티티에서 Block에 대한 영속성을 관리하겠다는 의미이다.</span><br><span class="line">&#x2F;&#x2F;MERGE, REMOVE, REFRESH, DETACH 등은 엔티티의 변경에 있어서 보유된 엔티티(Block)의 해당 작업에 대해서도 변경하는 것이다.   </span><br><span class="line">&#x2F;&#x2F;ALL은 위의 5가지를 모두 적용하는 것이다.</span><br><span class="line">&#x2F;&#x2F;@OneToOne(cascade &#x3D; &#123;CascadeType.PERSIST, CascadeType.MERGE, CascadeType.REMOVE&#125;)</span><br><span class="line">&#x2F;&#x2F;orphanRemoval &#x3D; true는 해당 Block이 해제(setBlock(null))되는 순간 삭제시킨다. -&gt; 불필요 엔티티 관리  </span><br><span class="line">&#x2F;&#x2F;fetch type 은 EAGER(default)와 LAZY가 있는데 LAZY의 경우에는 이 엔티티를 호출(select)할때 Block을 호출하지 않고 필요할때 호출한다.  </span><br><span class="line">&#x2F;&#x2F;optional &#x3D; true(default), false인 경우는 이 속성이 null일 수 없게 된다.  </span><br><span class="line">@OneToOne(cascade &#x3D; CascadeType.ALL, orphanRemoval &#x3D; true, fetch &#x3D; FetchType.EAGER)</span><br><span class="line">private Block block;</span><br></pre></td></tr></table></figure>

<p>Person Service에서 차단된 사람을 제외하고 가져오는 메서드와 id로 조회하는 메서드 생성     </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Service</span><br><span class="line">@Slf4j</span><br><span class="line">public class PersonService &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private PersonRepository personRepository;</span><br><span class="line"></span><br><span class="line">    public List&lt;Person&gt; getPeopleExcludeBlocks() &#123;</span><br><span class="line">        List&lt;Person&gt; people &#x3D; personRepository.findAll();</span><br><span class="line"></span><br><span class="line">        return people.stream().filter(</span><br><span class="line">                person -&gt; person.getBlock() &#x3D;&#x3D; null</span><br><span class="line">        ).collect(Collectors.toList());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Person getPerson(Long id) &#123;</span><br><span class="line">        Person person &#x3D; personRepository.findById(id).get();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;System.out은 모든 로그를 출력하지만</span><br><span class="line">        &#x2F;&#x2F;log.info(Slf4j)는 로그백을 이용하여 로그 출력을 제한할 수 있다.  </span><br><span class="line">        &#x2F;&#x2F;System.out.println(&quot;person : &quot;+ person);</span><br><span class="line">        log.info(&quot;person : &#123;&#125;&quot;, person);</span><br><span class="line">        &#x2F;&#x2F;ex) 2020-07-17 17:01:52.918  INFO 2781 --- [    Test worker] c.f.j.p.mycontact.service.PersonService  : person : Person(id&#x3D;3, name&#x3D;Dennis, age&#x3D;7, hobby&#x3D;null, bloodType&#x3D;O, address&#x3D;null, birthDay&#x3D;null, job&#x3D;null, block&#x3D;Block(id&#x3D;4, name&#x3D;Dennis, reason&#x3D;null, startDate&#x3D;null, endDate&#x3D;null))</span><br><span class="line">        &#x2F;&#x2F;이때 로그를 출력하는 중에 사용되는 SQL이 fetch type에 따라 다른데</span><br><span class="line">        &#x2F;&#x2F;EAGER에서는 모든 Block을 Person이 호출될때(toString(person)에서) 호출한다. (left join을 사용한 1개 select문)</span><br><span class="line">        &#x2F;&#x2F;이때 optional &#x3D; false 인 경우에 inner join을 사용하게 된다.</span><br><span class="line">        &#x2F;&#x2F;LAZY에서는 Person 먼저 호출하고 그 후 해당되는 id의 Block을 따로 호출한다. (2개 select문)</span><br><span class="line">        &#x2F;&#x2F;또한 LAZY인 경우에 Block 속성에 @ToString.Exclude 처리를 하면 toString에서 빠지게 되므로 block에 대한 호출은 없어진다.   </span><br><span class="line">        &#x2F;&#x2F;LAZY는 간단하지 않지만 불필요한 쿼리 호출을 줄여 성능을 개선할 수 있다는 장점이 있다.  </span><br><span class="line"></span><br><span class="line">        return person;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Study</category>
        <category>Spring Boot Project</category>
      </categories>
      <tags>
        <tag>spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title>13. JPA Query Method</title>
    <url>/2020/08/12/hexo_springboot_2_13/</url>
    <content><![CDATA[<h1 id="스프링-부트-프로젝트"><a href="#스프링-부트-프로젝트" class="headerlink" title="스프링 부트 프로젝트"></a>스프링 부트 프로젝트</h1><h3 id="지인-정보-관리-시스템-만들기"><a href="#지인-정보-관리-시스템-만들기" class="headerlink" title="지인 정보 관리 시스템 만들기"></a>지인 정보 관리 시스템 만들기</h3><h4 id="13-JPA-Query-Method"><a href="#13-JPA-Query-Method" class="headerlink" title="13. JPA Query Method"></a>13. JPA Query Method</h4><p>일반적으로 우리가 테스트에서 자주 사용하는 JPA의 findall()은 실제 운영에서는 사용하지 않는다.<br>그 대신 where절이 걸려있는 sql을 원하게 되는데 이때 JPA Query Method를 사용하여 쿼리를 만들어 쓸 수 있다.<br>find : select<br>By : where<br>And : and<br>Or : or<br>Between : between A and B<br>LessThan : tab.col &lt; val<br>LessThanEqual : tab.col &lt;= val<br>GreaterThan : tab.col &gt; val<br>GreaterThanEqual : tab.col &gt;= val<br>After : tab.date &gt; val(date)<br>Before : tab.date &lt; val(date)<br>IsNull : is null, = null<br>(Is)NotNull : not null, != null<br>Like : like %val%<br>NotLike : not like %val%<br>StartingWith : like val%<br>EndingWith : like %val<br>Containing : like %val%<br>OrderBy : order by<br>Not : &lt;&gt;<br>In : in ()<br>NotIn : not in ()<br>True : = true<br>False : = false<br>IgnoreCase : UPPER(tab.col) / UPPER(val)</p>
<p>ex)<br>만약 무조건 1 row만 리턴하는 쿼리라면 리턴타입을 Person으로 해도 되지만 2 rows 이상 리턴할 때 에러가 발생한다.  </p>
<p>이름으로 찾기 : List<Person> findByName(String name)<br>이름 포함 : List<Person> findByNameContaining(String name) / List<Person> findByNameLike(String name)<br>차단되지 않은 사람 : List<Person> findByBlockIsNull()<br>특정 기간동안에 생일이 있는 사람 : List<Person> findByBirthDayBetween(LocalDate startDate, LocalDate endDate);</p>
<p>만약 이번달에 생일인 사람을 찾는 기능을 추가하고 싶을때<br>LocalDate에서 월만 분류하면 성능적으로 바람직하지 못함.<br>그렇기 때문에 BirthDay라는 Entity를 추가하여 생일의 연월일을 나눈다.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.fastcampus.javaallinone.project3.mycontact.domain.dto;</span><br><span class="line"></span><br><span class="line">import lombok.AllArgsConstructor;</span><br><span class="line">import lombok.Data;</span><br><span class="line">import lombok.NoArgsConstructor;</span><br><span class="line"></span><br><span class="line">import javax.persistence.Embeddable;</span><br><span class="line"></span><br><span class="line">@Embeddable &#x2F;&#x2F;Entity에 속할 DTO라는것을 명시</span><br><span class="line">@Data</span><br><span class="line">@NoArgsConstructor</span><br><span class="line">public class Birthday &#123;</span><br><span class="line">    private int yearOfBirthday;</span><br><span class="line"></span><br><span class="line">    @Min(1)</span><br><span class="line">    @Max(12)</span><br><span class="line">    private int monthOfBirthday;</span><br><span class="line"></span><br><span class="line">    @Min(1)</span><br><span class="line">    @Max(31)</span><br><span class="line">    private int DayOfBirthday;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;여기서 생성자를 따로 만들었는데 LocalDate 타입을 사용해서 날짜 제한을 두기 위함임.</span><br><span class="line">    public Birthday(LocalDate birthday) &#123;</span><br><span class="line">        this.yearOfBirthDay &#x3D; birthday.getYear();</span><br><span class="line">        this.monthOfBirthDay &#x3D; birthday.getMonthValue();</span><br><span class="line">        this.dayOfBirthday &#x3D; birthday.getDayOfMonth();</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Person의 BitrhDay 속성 변경</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">~</span><br><span class="line">    @Valid</span><br><span class="line">    @Embedded &#x2F;&#x2F;Embeddable DTO 사용</span><br><span class="line">    private BirthDay birthDay;</span><br><span class="line">~</span><br></pre></td></tr></table></figure>

<p>Person Repository에 기능 추가<br>@Query는 JPQL이라는 Entity기반으로 쿼리를 실행하는 로직을 이용할 어노테이션이다.<br>아래에서 사용하지 않으면 Person에는 monthOfBirthDay라는 속성이 없으므로 에러가 발생한다.<br>아래 JPQL문의 ?1은 메서드의 첫번째 인자를 의미한다.   </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Query(value &#x3D; &quot;select person from Person person where person.birthDay.monthOfBirthday &#x3D; ?1&quot;)</span><br><span class="line">List&lt;Person&gt; findByMonthOfBirthday(int monthOfBirthday);</span><br></pre></td></tr></table></figure>

<p>명시적인 파라미터를 사용하고 싶다면 아래와 같이 사용할 수 있다.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Query(value &#x3D; &quot;select person from Person person where person.birthDay.monthOfBirthday &#x3D; :monthOfBirthDay and person.birthDay.dayOfBirthday &#x3D; :dayOfBirthday&quot;)</span><br><span class="line">List&lt;Person&gt; findByMonthOfBirthday(@Param(&quot;monthOfBirthday&quot;) int monthOfBirthday,@Param(&quot;dayOfBirthday&quot;) int dayOfBirthday);</span><br></pre></td></tr></table></figure>

<p>실제 DB에서 수행될 SQL문 그대로를 만들고 싶을때는 nativeQuery 옵션을 사용할 수 있다.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Query(value &#x3D; &quot;select * from person where month_of_birthday &#x3D; :monthOfBirthday and day_of_birthday &#x3D; :dayOfBirthday&quot;, nativeQuery &#x3D; true)</span><br><span class="line">List&lt;Person&gt; findByMonthOfBirthday(@Param(&quot;monthOfBirthday&quot;) int monthOfBirthday,@Param(&quot;dayOfBirthday&quot;) int dayOfBirthday);</span><br></pre></td></tr></table></figure>

<p>test 디렉토리에 resources 디렉토리 생성 후 data.sql 파일 생성</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">insert into person(&#96;id&#96;, &#96;name&#96;, &#96;age&#96;, &#96;blood_type&#96;, &#96;year_of_birthday&#96;, &#96;month_of_birthday&#96;, &#96;day_of_birthday&#96;) values (1,&#39;martin&#39;,10,&#39;A&#39;,1992,1,30);</span><br><span class="line">insert into person(&#96;id&#96;, &#96;name&#96;, &#96;age&#96;, &#96;blood_type&#96;, &#96;year_of_birthday&#96;, &#96;month_of_birthday&#96;, &#96;day_of_birthday&#96;) values (2,&#39;david&#39;,9,&#39;B&#39;,1994,3,24);</span><br><span class="line">insert into person(&#96;id&#96;, &#96;name&#96;, &#96;age&#96;, &#96;blood_type&#96;, &#96;year_of_birthday&#96;, &#96;month_of_birthday&#96;, &#96;day_of_birthday&#96;) values (3,&#39;dennis&#39;,8,&#39;AB&#39;,2000,12,24);</span><br><span class="line">insert into person(&#96;id&#96;, &#96;name&#96;, &#96;age&#96;, &#96;blood_type&#96;, &#96;year_of_birthday&#96;, &#96;month_of_birthday&#96;, &#96;day_of_birthday&#96;) values (4,&#39;sophia&#39;,7,&#39;O&#39;,1999,8,15);</span><br><span class="line">insert into person(&#96;id&#96;, &#96;name&#96;, &#96;age&#96;, &#96;blood_type&#96;, &#96;year_of_birthday&#96;, &#96;month_of_birthday&#96;, &#96;day_of_birthday&#96;) values (5,&#39;benny&#39;,6,&#39;A&#39;,2001,2,24);</span><br><span class="line"></span><br><span class="line">insert into block(&#96;id&#96;, &#96;name&#96;) values (1, &#39;dennis&#39;);</span><br><span class="line">insert into block(&#96;id&#96;, &#96;name&#96;) values (2, &#39;sophia&#39;);</span><br><span class="line"></span><br><span class="line">update person set block_id &#x3D; 1 where id &#x3D; 3;</span><br><span class="line">update person set block_id &#x3D; 2 where id &#x3D; 4;</span><br></pre></td></tr></table></figure>
<p>테스트 진행 시 위의 SQL문을 먼저 실행한 뒤 테스트가 진행된다.  </p>
]]></content>
      <categories>
        <category>Study</category>
        <category>Spring Boot Project</category>
      </categories>
      <tags>
        <tag>spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title>16. Controller HTTP Method</title>
    <url>/2020/08/12/hexo_springboot_2_16/</url>
    <content><![CDATA[<h1 id="스프링-부트-프로젝트"><a href="#스프링-부트-프로젝트" class="headerlink" title="스프링 부트 프로젝트"></a>스프링 부트 프로젝트</h1><h3 id="지인-정보-관리-시스템-만들기"><a href="#지인-정보-관리-시스템-만들기" class="headerlink" title="지인 정보 관리 시스템 만들기"></a>지인 정보 관리 시스템 만들기</h3><h4 id="16-Controller-HTTP-Method"><a href="#16-Controller-HTTP-Method" class="headerlink" title="16. Controller HTTP Method"></a>16. Controller HTTP Method</h4><p>Controller에 각 HTTP 메서드를 이용한 기능 생성  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@Slf4j</span><br><span class="line">@RequestMapping(value &#x3D; &quot;&#x2F;api&#x2F;person&quot;)</span><br><span class="line">public class PersonController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private PersonService personService;</span><br><span class="line">    @Autowired</span><br><span class="line">    private PersonRepository personRepository;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;&#x2F;&#123;id&#125;&quot;)</span><br><span class="line">    public Person getPerson(@PathVariable Long id) &#123;</span><br><span class="line">        return personService.getPerson(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;회원 정보 변경에서 받을 용도로 PersonDto Class를 만들었다.  </span><br><span class="line">    @PostMapping</span><br><span class="line">    public ResponseEntity&lt;?&gt; postPerson(@RequestBody Person resource) throws URISyntaxException &#123;</span><br><span class="line">        Person person &#x3D; personService.put(resource);</span><br><span class="line"></span><br><span class="line">        log.info(&quot;person -&gt; &#123;&#125;&quot;,personRepository.findAll());</span><br><span class="line"></span><br><span class="line">        String url &#x3D; &quot;&#x2F;api&#x2F;person&#x2F;&quot;+person.getId();</span><br><span class="line">        return ResponseEntity.created(new URI(url)).body(&quot;&#123;&#125;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @PutMapping(&quot;&#x2F;&#123;id&#125;&quot;)</span><br><span class="line">    public void modifyPerson(@PathVariable Long id,@RequestBody PersonDto personDto) &#123;</span><br><span class="line">        personService.modify(id, personDto);</span><br><span class="line"></span><br><span class="line">        log.info(&quot;person -&gt; &#123;&#125;&quot;,personRepository.findAll());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @PatchMapping(&quot;&#x2F;&#123;id&#125;&quot;)</span><br><span class="line">    public void modifyPerson(@PathVariable Long id,String name) &#123;</span><br><span class="line">        personService.modify(id, name);</span><br><span class="line"></span><br><span class="line">        log.info(&quot;person -&gt; &#123;&#125;&quot;,personRepository.findAll());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @DeleteMapping(&quot;&#x2F;&#123;id&#125;&quot;)</span><br><span class="line">    public void deletePerson(@PathVariable Long id) &#123;</span><br><span class="line">        personService.delete(id);</span><br><span class="line"></span><br><span class="line">        log.info(&quot;person -&gt; &#123;&#125;&quot;,personRepository.findAll());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>회원 정보 변경에서 받을 용도로 PersonDto Class를 만들었다.  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Data</span><br><span class="line">public class PersonDto &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    private String hobby;</span><br><span class="line">    private String address;</span><br><span class="line">    private String bloodType;</span><br><span class="line">    private String job;</span><br><span class="line">    private String phoneNumber;</span><br><span class="line">    private LocalDate Birthday;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>personService.modify 메서드 오버로딩을 통해 회원 정보 변경과 이름 변경을 따로 구현하였다.  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Service</span><br><span class="line">@Slf4j</span><br><span class="line">public class PersonService &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private PersonRepository personRepository;</span><br><span class="line"></span><br><span class="line">    public List&lt;Person&gt; getPeopleExcludeBlocks() &#123;</span><br><span class="line">        return personRepository.findByBlockIsNull();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Transactional(readOnly &#x3D; true)</span><br><span class="line">    public Person getPerson(Long id) &#123;</span><br><span class="line">        Person person &#x3D; personRepository.findById(id).orElse(null);</span><br><span class="line"></span><br><span class="line">        log.info(&quot;person : &#123;&#125;&quot;, person);</span><br><span class="line"></span><br><span class="line">        return person;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public List&lt;Person&gt; getPeopleByName(String name) &#123;</span><br><span class="line">        return personRepository.findByName(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public List&lt;Person&gt; getPeopleNameContaining(String name) &#123;</span><br><span class="line">        return personRepository.findByNameLike(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Transactional</span><br><span class="line">    public Person put(Person person) &#123;</span><br><span class="line">        return personRepository.save(person);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void modify(Long id, PersonDto personDto) &#123;</span><br><span class="line">        Person personAtDb &#x3D;  personRepository.findById(id)</span><br><span class="line">                .orElseThrow(() -&gt; new RuntimeException(&quot;아이디가 존재하지 않습니다.&quot;));</span><br><span class="line"></span><br><span class="line">        if (!personAtDb.getName().equals(personDto.getName())) &#123;</span><br><span class="line">            throw new RuntimeException(&quot;이름이 다릅니다.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;Person 클래스에 정보 변경을 위한 set 메서드를 만들었다.  </span><br><span class="line">        personAtDb.set(personDto);</span><br><span class="line"></span><br><span class="line">        personRepository.save(personAtDb);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;오버로딩(이름만 변경)</span><br><span class="line">    public void modify(Long id, String name) &#123;</span><br><span class="line">        Person person &#x3D; personRepository.findById(id)</span><br><span class="line">                .orElseThrow(() -&gt; new RuntimeException(&quot;아이디가 존재하지 않습니다.&quot;));</span><br><span class="line"></span><br><span class="line">        person.setName(name);</span><br><span class="line">        personRepository.save(person);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;DB에서 delete하는 대신 flag(deleted)를 사용하였다.  </span><br><span class="line">    public void delete(Long id) &#123;</span><br><span class="line">        Person person &#x3D; personRepository.findById(id)</span><br><span class="line">                .orElseThrow(() -&gt; new RuntimeException(&quot;아이디가 존재하지 않습니다.&quot;));</span><br><span class="line"></span><br><span class="line">        person.setDeleted(true);</span><br><span class="line">        personRepository.save(person);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Person Class  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">~</span><br><span class="line">&#x2F;&#x2F; 모든 JPA 작업에서 아래 조건이 자동으로 추가된다.</span><br><span class="line">@Where(clause &#x3D; &quot;deleted &#x3D; false&quot;)</span><br><span class="line">public class Person &#123;</span><br><span class="line"></span><br><span class="line">    ~</span><br><span class="line">    &#x2F;&#x2F;디폴트값은 false로 설정</span><br><span class="line">    @ColumnDefault(&quot;0&quot;)</span><br><span class="line">    private boolean deleted;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;정보 변경을 위한 메서드 구현, 빈값이면 변경하지 않도록  </span><br><span class="line">    public void set(PersonDto personDto) &#123;</span><br><span class="line">        if (personDto.getAge() !&#x3D; 0) &#123;</span><br><span class="line">            this.setAge(personDto.getAge());</span><br><span class="line">        &#125;</span><br><span class="line">        if (!StringUtils.isEmpty(personDto.getAddress())) &#123;</span><br><span class="line">            this.setAddress(personDto.getAddress());</span><br><span class="line">        &#125;</span><br><span class="line">        if (!StringUtils.isEmpty(personDto.getAge())) &#123;</span><br><span class="line">            this.setAge(personDto.getAge());</span><br><span class="line">        &#125;</span><br><span class="line">        if (!StringUtils.isEmpty(personDto.getHobby())) &#123;</span><br><span class="line">            this.setHobby(personDto.getHobby());</span><br><span class="line">        &#125;</span><br><span class="line">        if (!StringUtils.isEmpty(personDto.getBloodType())) &#123;</span><br><span class="line">            this.setBloodType(personDto.getBloodType());</span><br><span class="line">        &#125;</span><br><span class="line">        if (!StringUtils.isEmpty(personDto.getJob())) &#123;</span><br><span class="line">            this.setJob(personDto.getJob());</span><br><span class="line">        &#125;</span><br><span class="line">        if (!StringUtils.isEmpty(personDto.getPhoneNumber())) &#123;</span><br><span class="line">            this.setPhoneNumber(personDto.getPhoneNumber());</span><br><span class="line">        &#125;</span><br><span class="line">        if (personDto.getBirthday() !&#x3D; null) &#123;</span><br><span class="line">            this.setBirthday(new Birthday(personDto.getBirthday()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@Where(clause = “deleted = false”) 를 걸어두었기 때문에<br>만약, deleted = true인 값을 조회하고 싶을땐 nativeQuery를 사용하여야 한다.  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Query(value &#x3D; &quot;select * from person where deleted &#x3D; true&quot;, nativeQuery &#x3D; true)</span><br><span class="line">List&lt;Person&gt; findPeopleDeleted();</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Study</category>
        <category>Spring Boot Project</category>
      </categories>
      <tags>
        <tag>spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title>20. 리팩토링 도메인코드</title>
    <url>/2020/08/12/hexo_springboot_2_20/</url>
    <content><![CDATA[<h1 id="스프링-부트-프로젝트"><a href="#스프링-부트-프로젝트" class="headerlink" title="스프링 부트 프로젝트"></a>스프링 부트 프로젝트</h1><h3 id="지인-정보-관리-시스템-만들기"><a href="#지인-정보-관리-시스템-만들기" class="headerlink" title="지인 정보 관리 시스템 만들기"></a>지인 정보 관리 시스템 만들기</h3><h4 id="20-리팩토링-도메인코드"><a href="#20-리팩토링-도메인코드" class="headerlink" title="20. 리팩토링 도메인코드"></a>20. 리팩토링 도메인코드</h4><p>bloodType 속성 제거<br>block 속성 제거<br>age 속성은 제거하고 birthday를 통해 나이를 계산하는 getAge 메서드 추가<br>오늘이 생일인지 확인하는 기능 추가 (isBirthdayToday)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Entity</span><br><span class="line">@Setter</span><br><span class="line">@Getter</span><br><span class="line">@ToString</span><br><span class="line">@NoArgsConstructor</span><br><span class="line">@EqualsAndHashCode</span><br><span class="line">@RequiredArgsConstructor</span><br><span class="line">@AllArgsConstructor</span><br><span class="line">@Where(clause &#x3D; &quot;deleted &#x3D; false&quot;)</span><br><span class="line">public class Person &#123;</span><br><span class="line"></span><br><span class="line">    @Id</span><br><span class="line">    @GeneratedValue(strategy &#x3D; GenerationType.IDENTITY)</span><br><span class="line">    private long id;</span><br><span class="line"></span><br><span class="line">    @NonNull</span><br><span class="line">    @NotEmpty</span><br><span class="line">    @Column(nullable &#x3D; false)</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    private String hobby;</span><br><span class="line"></span><br><span class="line">    private String address;</span><br><span class="line"></span><br><span class="line">    @Valid</span><br><span class="line">    @Embedded</span><br><span class="line">    private Birthday birthday;</span><br><span class="line"></span><br><span class="line">    private String job;</span><br><span class="line"></span><br><span class="line">    private String phoneNumber;</span><br><span class="line"></span><br><span class="line">    @ColumnDefault(&quot;0&quot;)</span><br><span class="line">    private boolean deleted;</span><br><span class="line"></span><br><span class="line">    public Integer getAge() &#123;</span><br><span class="line">        if (this.birthday !&#x3D; null) &#123;</span><br><span class="line">            return LocalDate.now().getYear() - this.birthday.getYearOfBirthday() + 1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean isBirthdayToday() &#123;</span><br><span class="line">        return LocalDate.now().equals(LocalDate.of(</span><br><span class="line">                this.birthday.getYearOfBirthday(),this.birthday.getMonthOfBirthday(),this.birthday.getDayOfBirthday()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void set(PersonDto personDto) &#123;</span><br><span class="line">        if (!StringUtils.isEmpty(personDto.getAddress())) &#123;</span><br><span class="line">            this.setAddress(personDto.getAddress());</span><br><span class="line">        &#125;</span><br><span class="line">        if (!StringUtils.isEmpty(personDto.getHobby())) &#123;</span><br><span class="line">            this.setHobby(personDto.getHobby());</span><br><span class="line">        &#125;</span><br><span class="line">        if (!StringUtils.isEmpty(personDto.getJob())) &#123;</span><br><span class="line">            this.setJob(personDto.getJob());</span><br><span class="line">        &#125;</span><br><span class="line">        if (!StringUtils.isEmpty(personDto.getPhoneNumber())) &#123;</span><br><span class="line">            this.setPhoneNumber(personDto.getPhoneNumber());</span><br><span class="line">        &#125;</span><br><span class="line">        if (personDto.getBirthday() !&#x3D; null) &#123;</span><br><span class="line">            this.setBirthday(Birthday.of(personDto.getBirthday()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>Birthday 속성 출력 변경을 위하여 Configuration 생성 및 JsonSerializer 사용  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class BirthdaySerializer extends JsonSerializer&lt;Birthday&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void serialize(Birthday value, JsonGenerator gen, SerializerProvider serializers)</span><br><span class="line">            throws IOException &#123;</span><br><span class="line">        if (value !&#x3D; null) &#123;</span><br><span class="line">            gen.writeObject(</span><br><span class="line">                    LocalDate.of(value.getYearOfBirthday(), value.getMonthOfBirthday(), value.getDayOfBirthday()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class JsonConfig &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public MappingJackson2HttpMessageConverter mappingJackson2HttpMessageConverter(ObjectMapper objectMapper) &#123;</span><br><span class="line">        MappingJackson2HttpMessageConverter converter &#x3D; new MappingJackson2HttpMessageConverter();</span><br><span class="line">        converter.setObjectMapper(objectMapper);</span><br><span class="line"></span><br><span class="line">        return converter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public ObjectMapper objectMapper() &#123;</span><br><span class="line">        ObjectMapper objectMapper &#x3D; new ObjectMapper();</span><br><span class="line">        objectMapper.registerModule(new BirthdayModule());</span><br><span class="line">        objectMapper.registerModule(new JavaTimeModule());</span><br><span class="line"></span><br><span class="line">        objectMapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false);</span><br><span class="line"></span><br><span class="line">        return objectMapper;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class BirthdayModule extends SimpleModule &#123;</span><br><span class="line">        BirthdayModule() &#123;</span><br><span class="line">            super();</span><br><span class="line">            addSerializer(Birthday.class, new BirthdaySerializer());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Controller 테스트 구체화</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@SpringBootTest</span><br><span class="line">@Transactional</span><br><span class="line">class PersonControllerTest &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private PersonController personController;</span><br><span class="line">    @Autowired</span><br><span class="line">    private PersonRepository personRepository;</span><br><span class="line">    @Autowired</span><br><span class="line">    private ObjectMapper objectMapper;</span><br><span class="line">    @Autowired</span><br><span class="line">    private MappingJackson2HttpMessageConverter messageConverter;</span><br><span class="line"></span><br><span class="line">    private MockMvc mockMvc;</span><br><span class="line"></span><br><span class="line">    @BeforeEach</span><br><span class="line">    void beforeEach() &#123;</span><br><span class="line">        mockMvc &#x3D; MockMvcBuilders.standaloneSetup(personController).setMessageConverters(messageConverter).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    void getPerson() throws Exception &#123;</span><br><span class="line">        mockMvc.perform(MockMvcRequestBuilders.get(&quot;&#x2F;api&#x2F;person&#x2F;1&quot;))</span><br><span class="line">                .andDo(print())</span><br><span class="line">                .andExpect(status().isOk())</span><br><span class="line">                .andExpect(jsonPath(&quot;$.name&quot;).value(&quot;martin&quot;))</span><br><span class="line">                .andExpect(jsonPath(&quot;$.hobby&quot;).isEmpty())</span><br><span class="line">                .andExpect(jsonPath(&quot;$.address&quot;).isEmpty())</span><br><span class="line">                &#x2F;&#x2F;아래처럼 birthday를 체이닝할 필요 없이 serializing된 값을 사용  </span><br><span class="line">                .andExpect(jsonPath(&quot;$.birthday&quot;).value(&quot;1992-01-30&quot;))</span><br><span class="line">                &#x2F;&#x2F;.andExpect(jsonPath(&quot;$.birthday.yearOfBirthday&quot;).value(1992))</span><br><span class="line">                &#x2F;&#x2F;.andExpect(jsonPath(&quot;$.birthday.monthOfBirthday&quot;).value(1))</span><br><span class="line">                &#x2F;&#x2F;.andExpect(jsonPath(&quot;$.birthday.dayOfBirthday&quot;).value(30))</span><br><span class="line">                .andExpect(jsonPath(&quot;$.job&quot;).isEmpty())</span><br><span class="line">                .andExpect(jsonPath(&quot;$.phoneNumber&quot;).isEmpty())</span><br><span class="line">                .andExpect(jsonPath(&quot;$.deleted&quot;).value(false))</span><br><span class="line">                &#x2F;&#x2F;age나 birthdayToday는 시간에 따라 바뀌므로 타입만 검증  </span><br><span class="line">                .andExpect(jsonPath(&quot;$.age&quot;).isNumber())</span><br><span class="line">                .andExpect(jsonPath(&quot;$.birthdayToday&quot;).isBoolean());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    void postPerson() throws Exception &#123;</span><br><span class="line">        PersonDto personDto &#x3D; PersonDto.of(&quot;martin&quot;,</span><br><span class="line">                &quot;programming&quot;,</span><br><span class="line">                &quot;판교&quot;,</span><br><span class="line">                &quot;programmer&quot;,</span><br><span class="line">                &quot;010-1111-1111&quot;,</span><br><span class="line">                LocalDate.now());</span><br><span class="line"></span><br><span class="line">        mockMvc.perform(MockMvcRequestBuilders.post(&quot;&#x2F;api&#x2F;person&quot;)</span><br><span class="line">                .contentType(MediaType.APPLICATION_JSON)</span><br><span class="line">                .content(toJsonString(personDto)))</span><br><span class="line">                .andDo(print())</span><br><span class="line">                .andExpect(status().isCreated())</span><br><span class="line">                .andExpect(content().string(&quot;\&quot;&#123;&#125;\&quot;&quot;));</span><br><span class="line"></span><br><span class="line">        Person result &#x3D; personRepository.findAll(Sort.by(Direction.DESC, &quot;id&quot;)).get(0);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;assertAll에 속한 모든 테스트를 모두 실행한다.</span><br><span class="line">        &#x2F;&#x2F;assertAll이 아니면 순차적으로 실행하며 실패할 시 다음 테스트를 진행하지 않는다. </span><br><span class="line">        assertAll(</span><br><span class="line">                () -&gt; assertThat(result.getName()).isEqualTo(&quot;martin&quot;),</span><br><span class="line">                () -&gt; assertThat(result.getHobby()).isEqualTo(&quot;programming&quot;),</span><br><span class="line">                () -&gt; assertThat(result.getAddress()).isEqualTo(&quot;판교&quot;),</span><br><span class="line">                () -&gt; assertThat(result.getJob()).isEqualTo(&quot;programmer&quot;),</span><br><span class="line">                () -&gt; assertThat(result.getPhoneNumber()).isEqualTo(&quot;010-1111-1111&quot;),</span><br><span class="line">                () -&gt; assertThat(result.getBirthday()).isEqualTo(Birthday.of(LocalDate.now()))</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    void modifyPerson() throws Exception &#123;</span><br><span class="line">        PersonDto personDto &#x3D; PersonDto.of(&quot;martin&quot;,</span><br><span class="line">                &quot;programming&quot;,</span><br><span class="line">                &quot;판교&quot;,</span><br><span class="line">                &quot;programmer&quot;,</span><br><span class="line">                &quot;010-1111-1111&quot;,</span><br><span class="line">                LocalDate.now());</span><br><span class="line"></span><br><span class="line">        mockMvc.perform(MockMvcRequestBuilders.put(&quot;&#x2F;api&#x2F;person&#x2F;1&quot;)</span><br><span class="line">                .contentType(MediaType.APPLICATION_JSON)</span><br><span class="line">                .content(toJsonString(personDto)))</span><br><span class="line">                .andDo(print())</span><br><span class="line">                .andExpect(status().isOk());</span><br><span class="line"></span><br><span class="line">        Person result &#x3D; personRepository.findById(1L).get();</span><br><span class="line"></span><br><span class="line">        assertAll(</span><br><span class="line">                () -&gt; assertThat(result.getName()).isEqualTo(&quot;martin&quot;),</span><br><span class="line">                () -&gt; assertThat(result.getHobby()).isEqualTo(&quot;programming&quot;),</span><br><span class="line">                () -&gt; assertThat(result.getAddress()).isEqualTo(&quot;판교&quot;),</span><br><span class="line">                () -&gt; assertThat(result.getJob()).isEqualTo(&quot;programmer&quot;),</span><br><span class="line">                () -&gt; assertThat(result.getPhoneNumber()).isEqualTo(&quot;010-1111-1111&quot;),</span><br><span class="line">                () -&gt; assertThat(result.getBirthday()).isEqualTo(Birthday.of(LocalDate.now()))</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    void modifyPersonIfNameIsDifferent() throws Exception &#123;</span><br><span class="line">        PersonDto personDto &#x3D; PersonDto.of(&quot;martin&quot;,</span><br><span class="line">                &quot;programming&quot;,</span><br><span class="line">                &quot;판교&quot;,</span><br><span class="line">                &quot;programmer&quot;,</span><br><span class="line">                &quot;010-1111-1111&quot;,</span><br><span class="line">                LocalDate.now());</span><br><span class="line"></span><br><span class="line">        assertThrows(NestedServletException.class, () -&gt;</span><br><span class="line">                mockMvc.perform(MockMvcRequestBuilders.put(&quot;&#x2F;api&#x2F;person&#x2F;1&quot;)</span><br><span class="line">                    .contentType(MediaType.APPLICATION_JSON)</span><br><span class="line">                    .content(toJsonString(personDto)))</span><br><span class="line">                .andDo(print())</span><br><span class="line">                .andExpect(status().isOk()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    void modifyName() throws Exception &#123;</span><br><span class="line">        mockMvc.perform(MockMvcRequestBuilders.patch(&quot;&#x2F;api&#x2F;person&#x2F;1&quot;)</span><br><span class="line">                .param(&quot;name&quot;,&quot;martinModified&quot;))</span><br><span class="line">                .andDo(print())</span><br><span class="line">                .andExpect(status().isOk());</span><br><span class="line"></span><br><span class="line">        assertThat(personRepository.findById(1L).get().getName()).isEqualTo(&quot;martinModified&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    void deletePerson() throws Exception &#123;</span><br><span class="line">        mockMvc.perform(MockMvcRequestBuilders.delete(&quot;&#x2F;api&#x2F;person&#x2F;1&quot;))</span><br><span class="line">                .andDo(print())</span><br><span class="line">                .andExpect(status().isOk());</span><br><span class="line"></span><br><span class="line">        assertTrue(personRepository.findPeopleDeleted().stream().anyMatch(person -&gt; person.getId().equals(1L)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;PersonDto를 json으로 변환해주는 메서드를 생성하여 사용한다.  </span><br><span class="line">    private String toJsonString(PersonDto personDto) throws JsonProcessingException &#123;</span><br><span class="line">        return objectMapper.writeValueAsString(personDto);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Study</category>
        <category>Spring Boot Project</category>
      </categories>
      <tags>
        <tag>spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title>30. Exception Handling</title>
    <url>/2020/08/12/hexo_springboot_2_30/</url>
    <content><![CDATA[<h1 id="스프링-부트-프로젝트"><a href="#스프링-부트-프로젝트" class="headerlink" title="스프링 부트 프로젝트"></a>스프링 부트 프로젝트</h1><h3 id="지인-정보-관리-시스템-만들기"><a href="#지인-정보-관리-시스템-만들기" class="headerlink" title="지인 정보 관리 시스템 만들기"></a>지인 정보 관리 시스템 만들기</h3><h4 id="30-Exception-Handling"><a href="#30-Exception-Handling" class="headerlink" title="30. Exception Handling"></a>30. Exception Handling</h4><p>Custom Exception 활용하기<br>프로젝트 내에서 의도적으로 발생시키는 예외는 별도의 Custom Exception으로 처리하는것이 좋다.  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">public class PersonNotFoundException extends RuntimeException&#123;</span><br><span class="line"></span><br><span class="line">    private static final String MESSAGE &#x3D; &quot;Person Entity가 존재하지 않습니다.&quot;;</span><br><span class="line">    public PersonNotFoundException() &#123;</span><br><span class="line">        super(MESSAGE);</span><br><span class="line">        log.error(MESSAGE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">public class RenameNotPermittedException extends RuntimeException&#123;</span><br><span class="line">    private static final String MESSAGE &#x3D; &quot;이름 변경이 허용되지 않았습니다.&quot;;</span><br><span class="line">    public RenameNotPermittedException() &#123;</span><br><span class="line">        super(MESSAGE);</span><br><span class="line">        log.error(MESSAGE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Exception의 정보 전달을 위한 DTO 생성</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Data</span><br><span class="line">@AllArgsConstructor(access &#x3D; AccessLevel.PRIVATE)</span><br><span class="line">public class ErrorResponse &#123;</span><br><span class="line">    private int code;</span><br><span class="line">    private String message;</span><br><span class="line"></span><br><span class="line">    public static ErrorResponse of(HttpStatus httpStatus, String message) &#123;</span><br><span class="line">        return new ErrorResponse(httpStatus.value(), message);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    public static ErrorResponse of(HttpStatus httpStatus, FieldError fieldError) &#123;</span><br><span class="line">        if (fieldError &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return new ErrorResponse(httpStatus.value(), &quot;invalid params&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return new ErrorResponse(httpStatus.value(), fieldError.getDefaultMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>Custom Exception이 아니더라도 응답은 일관성있게 나가는 것이 좋다.<br>=&gt; Exception Handler 사용<br>특정 클래스에서만 사용하지 않고 API 전역적으로 사용하려고 한다.<br>=&gt; RestControllerAdvice</p>
<p>서버의 오류메세지를 클라이언트로 보내는것은 보안적으로 위험하다.<br>=&gt; 실제 error 메세지 대신 일반적인 문구를 사용</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">@RestControllerAdvice</span><br><span class="line">public class GlobalExceptionHandler &#123;</span><br><span class="line"></span><br><span class="line">    @ExceptionHandler(RenameNotPermittedException.class)</span><br><span class="line">    @ResponseStatus(HttpStatus.BAD_REQUEST)</span><br><span class="line">    public ErrorResponse handleRenameNotPermittedException(RenameNotPermittedException ex) &#123;</span><br><span class="line">        return ErrorResponse.of(HttpStatus.BAD_REQUEST,ex.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @ExceptionHandler(PersonNotFoundException.class)</span><br><span class="line">    @ResponseStatus(HttpStatus.BAD_REQUEST)</span><br><span class="line">    public ErrorResponse handlePersonNotFoundException(PersonNotFoundException ex) &#123;</span><br><span class="line">        return ErrorResponse.of(HttpStatus.BAD_REQUEST,ex.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @ExceptionHandler(MethodArgumentNotValidException.class)</span><br><span class="line">    @ResponseStatus(HttpStatus.BAD_REQUEST)</span><br><span class="line">    public ErrorResponse handleMethodArgumentNotValidException(MethodArgumentNotValidException ex) &#123;</span><br><span class="line">        return ErrorResponse.of(HttpStatus.BAD_REQUEST,ex.getBindingResult().getFieldError());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @ExceptionHandler(RuntimeException.class)</span><br><span class="line">    @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)</span><br><span class="line">    public ErrorResponse handleRuntimeException(RuntimeException ex) &#123;</span><br><span class="line">        log.error(&quot;서버 오류 : &#123;&#125;&quot;, ex.getMessage(), ex);</span><br><span class="line">        return ErrorResponse.of(HttpStatus.INTERNAL_SERVER_ERROR,&quot;알 수 없는 서버 오류가 발생하였습니다.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Parameter Validator</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class PersonDto &#123;</span><br><span class="line">    &#x2F;&#x2F;null, empty, blank 예외처리, 디폴트 메시지 설정</span><br><span class="line">    @NotBlank(message &#x3D; &quot;이름은 필수값입니다.&quot;)</span><br><span class="line">    private String name;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Study</category>
        <category>Spring Boot Project</category>
      </categories>
      <tags>
        <tag>spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title>34. getAll() 추가 및 Paging</title>
    <url>/2020/08/12/hexo_springboot_2_34/</url>
    <content><![CDATA[<h1 id="스프링-부트-프로젝트"><a href="#스프링-부트-프로젝트" class="headerlink" title="스프링 부트 프로젝트"></a>스프링 부트 프로젝트</h1><h3 id="지인-정보-관리-시스템-만들기"><a href="#지인-정보-관리-시스템-만들기" class="headerlink" title="지인 정보 관리 시스템 만들기"></a>지인 정보 관리 시스템 만들기</h3><h4 id="34-getAll-추가-및-Paging"><a href="#34-getAll-추가-및-Paging" class="headerlink" title="34. getAll() 추가 및 Paging"></a>34. getAll() 추가 및 Paging</h4><p>Controller</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@GetMapping()</span><br><span class="line">public Page&lt;Person&gt; getAll(@PageableDefault Pageable pageable) &#123;</span><br><span class="line">    return personService.getAll(pageable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Service</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public Page&lt;Person&gt; getAll(Pageable pageable) &#123;</span><br><span class="line">    return personRepository.findAll(pageable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Controller Test</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">void getAll() throws Exception &#123;</span><br><span class="line">    mockMvc.perform(</span><br><span class="line">            MockMvcRequestBuilders.get(&quot;&#x2F;api&#x2F;person&quot;)</span><br><span class="line">                &#x2F;&#x2F;default 대신 사용</span><br><span class="line">                .param(&quot;page&quot;,&quot;1&quot;) &#x2F;&#x2F;2번째 페이지</span><br><span class="line">                .param(&quot;size&quot;,&quot;2&quot;)) &#x2F;&#x2F;페이지 별 사이즈</span><br><span class="line">            .andExpect(status().isOk())</span><br><span class="line">            .andExpect(jsonPath(&quot;$.totalPages&quot;).value(3)) &#x2F;&#x2F;페이지 수</span><br><span class="line">            .andExpect(jsonPath(&quot;$.totalElements&quot;).value(6)) &#x2F;&#x2F;총 요소 수</span><br><span class="line">            .andExpect(jsonPath(&quot;$.numberOfElements&quot;).value(2)) &#x2F;&#x2F;페이지의 요소 수 </span><br><span class="line">            .andExpect(jsonPath(&quot;$.content.[0].name&quot;).value(&quot;dennis&quot;))</span><br><span class="line">            .andExpect(jsonPath(&quot;$.content.[1].name&quot;).value(&quot;sophia&quot;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Study</category>
        <category>Spring Boot Project</category>
      </categories>
      <tags>
        <tag>spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title>sample</title>
    <url>/2020/08/12/sample/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Resource / Validation</title>
    <url>/2020/08/15/hexo_spring_project_5/</url>
    <content><![CDATA[<h2 id="Resource-Validation"><a href="#Resource-Validation" class="headerlink" title="Resource / Validation"></a>Resource / Validation</h2><h4 id="Resource-추상화"><a href="#Resource-추상화" class="headerlink" title="Resource 추상화"></a>Resource 추상화</h4><p>Spring에서는 java.net.URL을 추상화한 Resource 가 있다.  </p>
<p>추상화한 이유…<br>Resource는 classpath 기준으로 읽어올 수 있다.<br>ServletContext를 기준으로 읽어올 수 없다.<br>구현이 복잡하고 편의성 메소드가 부족하다.  </p>
<p>구현체…<br>UrlResource<br>ClassPathResource (classpath: 접두어 지원)<br>FileSystemResource<br>ServletContextResource : 웹 어플리케이션 루트에서 상대 경로로 리소스를 찾는다.  </p>
<p>Resource의 타입은 ApplicationContext의 타입에 따라 결정된다.<br>ex)</p>
<ul>
<li>ClassPathXmlApplicationContext -&gt; ClassPathResource</li>
<li>FileSystemXmlApplicationContext -&gt; FileSystemResource</li>
<li>WebXmlApplicationContext -&gt; ServletContextResource</li>
</ul>
<p>ApplicationContext 타입과 무관하게 Resource 타입을 정하려면<br>java.net.URL 접두어를 사용한다. (classpath:, file:)</p>
<p>접두어가 있으면 가시성이 좋아지기 때문에 접두어를 쓰는 것이 좋다.<br>(ApplicationContext 타입을 모르면 복잡해지기 때문에)</p>
<h4 id="Validation-추상화"><a href="#Validation-추상화" class="headerlink" title="Validation 추상화"></a>Validation 추상화</h4><p>애플리케이션에서 사용하는 객체들을 검증할때 사용하는 인터페이스.  </p>
<p>Validation 인터페이스는 두개의 메소드를 구현해야 한다.<br>boolean supports(Class clazz) : 검증할 Class가 Validator가 지원하는지 확인하는 메소드<br>void validate(Object target, Errors errors) : 실제 검증 로직을 구현 (ValidationUtils를 사용)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class EventValidator implements Validator &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean supports(Class&lt;?&gt; clazz) &#123;</span><br><span class="line">        return Event.class.equals(clazz);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void validate(Object target, Errors errors) &#123;</span><br><span class="line">        ValidationUtils.rejectIfEmptyOrWhitespace</span><br><span class="line">            (errors, &quot;title&quot;, &quot;NotEmpty&quot;, &quot;Empty title is not allowed.&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>한편, 스프링 부트에서는 간단한 검증은 Validator를 따로 작성하지 않아도<br>LocalValidatorFactoryBean이 빈으로 등록되어 있다.</p>
]]></content>
      <categories>
        <category>Study</category>
        <category>Spring Framework</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>데이터 바인딩</title>
    <url>/2020/08/15/hexo_spring_project_6/</url>
    <content><![CDATA[<h2 id="데이터-바인딩"><a href="#데이터-바인딩" class="headerlink" title="데이터 바인딩"></a>데이터 바인딩</h2><p>프로퍼티 값을 타겟 객체에 설정하는 기능.<br>즉, 사용자 입력값(문자열)을 객체가 가지고 있는 int, Date, Boolean 또는 도메인 타입 등으로 변환해 넣어주는 기능이다.  </p>
<h4 id="PropertyEditor"><a href="#PropertyEditor" class="headerlink" title="PropertyEditor"></a>PropertyEditor</h4><p>DataBinder가 변환 작업에 사용하는 인터페이스.  </p>
<p>문자열을 객체로 변환하는 Editor 만들기</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class EventEditor extends PropertyEditorSupport &#123;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public String setAsText(String text) throws IllegalArgumentException &#123;</span><br><span class="line">        setValue(new Event(Integer.parseInt(text)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PropertyEditorSupport는 PropertyEditor의 구현체이다.<br>참고로 PropertyEditor는 쓰레드 세이프 하지 않기 때문에 절대로 싱글톤 빈으로 등록하지 않는다.<br>그리고 Object / String 간 변환만 지원한다.<br>사용할 때는 @InitBinder로 사용할 PropertyEditor를 등록할 수 있다.  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@InitBinder</span><br><span class="line">public void init(WebDataBinder webDataBinder) &#123;</span><br><span class="line">    webDataBinder.registerCustomEditor(Event.class, new EventEditor());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Converter와-Formatter"><a href="#Converter와-Formatter" class="headerlink" title="Converter와 Formatter"></a>Converter와 Formatter</h4><h5 id="Converter"><a href="#Converter" class="headerlink" title="Converter"></a>Converter</h5><p>Source 타입을 Target 타입으로 변환, 상태 정보가 없기 때문에(stateless) 쓰레드 세이프하다.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class StringToEventConverter implements Converter&lt;String, Event&gt; &#123;</span><br><span class="line">        </span><br><span class="line">    @Override</span><br><span class="line">    public Event convert(String source) &#123;</span><br><span class="line">        return new Event(Integer.parseInt(source));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>WebMvcConfigurer 에서 설정, ConverterRegistry에 등록하여 사용한다.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class WebConfig implements WebMvcConfigurer &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void addFormatters(FormatterRegistry registry) &#123;</span><br><span class="line">        registry.addConverter(new StringToEventConverter());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Formatter"><a href="#Formatter" class="headerlink" title="Formatter"></a>Formatter</h5><p>보다 Web에 특화된 인터페이스<br>String과 Object 변환, Locale에 따른 i18n 기능.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class EventFormatter implements Formatter&lt;Event&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Event parse(String text, Locale locale) throws ParseException &#123;</span><br><span class="line">        return new Event(Integer.parseInt(text));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public Event print(Event object, Locale locale) &#123;</span><br><span class="line">        return object.getId().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>WebMvcConfigurer 에서 설정, FormatterRegistry에 등록하여 사용한다.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class WebConfig implements WebMvcConfigurer &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void addFormatters(FormatterRegistry registry) &#123;</span><br><span class="line">        registry.addFormatter(new EventFormatter());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="ConversionService"><a href="#ConversionService" class="headerlink" title="ConversionService"></a>ConversionService</h5><p>Converter/Formatter는 DataBinder 대신에 ConversionService에서 쓰레드 세이프하게 실제 변환 작업이 수행된다.<br>스프링 MVC, 빈(value) 설정, SpEL에서 사용한다.<br>DefaultFormattingConversionService<br> : ConversionService와 FormatterRegistry를 구현하고 그 외 여러 기본 컨버터와 포매터가 등록되어 있다.  </p>
<p>conversionService를 toString()으로 확인하면 등록된 모든 Converter, Formatter를 확인할 수 있다.  </p>
<p>참고로 스프링 부트에서는 DefaultFormattingConversionService를 상속받는 WebConversionService가 빈으로 등록되고<br>WebMvcConfigurer 설정 없이 Formatter와 Converter 빈을 찾아서 자동으로 등록해준다.  </p>
]]></content>
      <categories>
        <category>Study</category>
        <category>Spring Framework</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>SpEL (스프링 Expression Language)</title>
    <url>/2020/08/15/hexo_spring_project_7/</url>
    <content><![CDATA[<h2 id="SpEL-스프링-Expression-Language"><a href="#SpEL-스프링-Expression-Language" class="headerlink" title="SpEL (스프링 Expression Language)"></a>SpEL (스프링 Expression Language)</h2><h4 id="스프링-EL이란-upto-spring3-0"><a href="#스프링-EL이란-upto-spring3-0" class="headerlink" title="스프링 EL이란? (upto spring3.0)"></a>스프링 EL이란? (upto spring3.0)</h4><ol>
<li>객체 그래프를 조회하고 조작하는 기능 제공</li>
<li>Unified EL과 비슷하지만, 메소드 호출이나 문자열 템플릿 기능을 지원한다.</li>
<li>OGNL, MVEL, JBoss EL 등 여러 EL이 있지만 SpEL은 모든 스프링 프로젝트 전반에 걸쳐 사용하도록 만들어져있다.</li>
</ol>
<h4 id="문법"><a href="#문법" class="headerlink" title="문법"></a>문법</h4><p>#{“표현식”}  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Value(&quot;#&#123;100 + 100&#125;&quot;)</span><br><span class="line">int value;</span><br></pre></td></tr></table></figure>
<p>${“프로퍼티”}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Value(&quot;$&#123;my.value&#125;&quot;)</span><br><span class="line">int value;</span><br></pre></td></tr></table></figure>
<p>참고로 표현식 내부에 프로퍼티를 사용할 수 있지만 반대는 안된다.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Value(&quot;#&#123;$&#123;my.value&#125; eq 100&#125;&quot;)</span><br><span class="line">boolean isValue100;</span><br></pre></td></tr></table></figure>
<p>Sample Bean 참조</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Value(#&#123;sample.data&#125;)</span><br><span class="line">int value;</span><br></pre></td></tr></table></figure>

<p>SpEL의 해석은 SpelExpressionParser에 의해 이루어진다.  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ExpressionParser parser &#x3D; new SpelExpressionParser();</span><br><span class="line">Expression expression &#x3D; parser.parseExpression(&quot;2 + 100&quot;);</span><br><span class="line">Integer value &#x3D; expression.getValue(Integer.class);</span><br></pre></td></tr></table></figure>

<h4 id="SpEL이-사용되는-곳"><a href="#SpEL이-사용되는-곳" class="headerlink" title="SpEL이 사용되는 곳"></a>SpEL이 사용되는 곳</h4><p>@Value<br>@ConditionalOnExpression (EL을 이용하여 선별적으로 Bean 등록)<br>스프링 시큐리티<br>스프링 데이터 @Query<br>Thymeleaf  </p>
]]></content>
      <categories>
        <category>Study</category>
        <category>Spring Framework</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Null-safety</title>
    <url>/2020/08/15/hexo_spring_project_8/</url>
    <content><![CDATA[<h2 id="Null-safety"><a href="#Null-safety" class="headerlink" title="Null-safety"></a>Null-safety</h2><p>Spring 5부터 추가된 Null 관련 어노테이션.<br>org.springframework.lang</p>
<p>컴파일 시점에 최대한 NullPointerException을 방지할 수 있다.  </p>
<p>@NonNull : IntelliJ에서 null이면 미리 경고받을 수 있다.  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@NonNull &#x2F;&#x2F;return이 Null인지 확인</span><br><span class="line">public String greeting(@NonNull String name) &#123; &#x2F;&#x2F;매개변수가 Null인지 확인</span><br><span class="line">    return &quot;Hi! &quot;+name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>@Nullable  </p>
<p>패키지 레벨 설정 (설정된 패키지 이하로 모두 설정)<br>@NonNullApi<br>@NonNullFields   </p>
]]></content>
      <categories>
        <category>Study</category>
        <category>Spring Framework</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring MVC 동작 원리</title>
    <url>/2020/08/19/hexo_spring_project_9/</url>
    <content><![CDATA[<img src="/img/Spring-MVC.png" class="img_class" width="400" height="270" title="spring-mvc">
<h2 id="Spring-MVC-동작-원리"><a href="#Spring-MVC-동작-원리" class="headerlink" title="Spring MVC 동작 원리"></a>Spring MVC 동작 원리</h2><h3 id="Spring-웹-MVC"><a href="#Spring-웹-MVC" class="headerlink" title="Spring 웹 MVC"></a>Spring 웹 MVC</h3><p>서블릿 기반의 웹 애플리케이션에서 MVC 패턴을 사용하기 쉽게끔 도와주는 프레임워크  </p>
<p>M : 모델, 평범한 자바 POJO 객체(도메인 객체 또는 DTO), 전달하거나 전달받을 데이터를 담은 객체<br>V : 뷰, 데이터를 보여주는 역할, HTML, JSP, 타임리프, …<br>C : 컨트롤러, 사용자의 입력을 받아 모델의 데이터를 변경하거나 뷰에 전달하는 역할  </p>
<h4 id="MVC-패턴의-장점"><a href="#MVC-패턴의-장점" class="headerlink" title="MVC 패턴의 장점"></a>MVC 패턴의 장점</h4><ul>
<li>동시 다발적 개발 : 백엔드와 프론트엔드에서 독립적으로 개발할 수 있다.  </li>
<li>높은 결합도 : 관련있는 기능을 하나의 컨트롤러로 묶거나 뷰를 그룹화 할 수 있다.  </li>
<li>낮의 의존도 : 모델, 뷰, 컨트롤러는 서로 독립적이다.  </li>
<li>개발 용이성 : 책임이 구분되어 있어서 코드 수정이 편리하다.  </li>
<li>한 모델에 대한 여러 형태의 뷰를 가질 수 있다.  </li>
</ul>
<h4 id="MVC-패턴의-단점"><a href="#MVC-패턴의-단점" class="headerlink" title="MVC 패턴의 단점"></a>MVC 패턴의 단점</h4><ul>
<li>코드 네비게이션의 복잡함</li>
<li>코드 일관성 유지에 노력이 필요하다. </li>
<li>높은 학습 곡선</li>
</ul>
<h3 id="서블릿-애플리케이션"><a href="#서블릿-애플리케이션" class="headerlink" title="서블릿 애플리케이션"></a>서블릿 애플리케이션</h3><h4 id="서블릿-Servlet"><a href="#서블릿-Servlet" class="headerlink" title="서블릿(Servlet)"></a>서블릿(Servlet)</h4><p>JAVA EE 웹 애플리케이션 개발용 스팩과 API 제공한다.<br>요청 당 쓰레드를 사용한다. (요청 당 프로세스에 비해 빠르다.)<br>JAVA 기반이기 때문에 플랫폼에 대해 독립적이고 이식성이 좋다. 또한 JAVA가 제공하는 보안 기술을 사용할 수 있다.  </p>
<p>서블릿 클래스 생성</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class SimpleServlet extends HttpServlet &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;</span><br><span class="line">        PrintWriter writer &#x3D; resp.getWriter();</span><br><span class="line">        writer.println(&quot;Hello World!!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>기본적으로 서블릿 애플리케이션의 실행 및 종료는 서블릿 컨테이너에 의해 이루어진다. </p>
<p>서블릿 엔진 또는 서블릿 컨테이너의 역할(톰캣, 제티, 언더토, …)<br> : 서블릿 라이프 사이클 관리, 세션 관리, 네트워크 서비스, MIME기반 메시지 인코딩 디코딩, …</p>
<p>서블릿 라이프 사이클 (서블릿 컨테이너가 관리)</p>
<ol>
<li>서블릿 인스턴스(HttpServlet을 상속받은 클래스)의 init() 메소드 호출&amp;초기화, 최초 요청 후부터 이 과정을 생략</li>
<li>클라이언트로부터의 요청 처리, 각 요청마다 별도의 쓰레드로 처리되며 서블릿 인스턴스의 service() 메소드 호출<br>이 과정에서 보통 Http Method에 따라 doGet(), doPost() 등의 메소드를 구현하여 처리를 위임한다.  </li>
<li>서블릿 컨테이너의 판단에 따라 해당 서블릿을 메모리에서 내려야 할 시점에 destroy() 호출  </li>
</ol>
<p>서블릿은 web.xml에 등록된다.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;servlet&gt;</span><br><span class="line">    &lt;servlet-name&gt;simple&lt;&#x2F;servlet-name&gt;</span><br><span class="line">    &lt;servlet-class&gt;kr.co.myapp.web.SimpleServlet&lt;&#x2F;servlet-class&gt;</span><br><span class="line">&lt;&#x2F;servlet&gt;</span><br><span class="line">&lt;servlet-mapping&gt;</span><br><span class="line">    &lt;servlet-name&gt;simple&lt;&#x2F;servlet-name&gt;</span><br><span class="line">    &lt;url-pattern&gt;&#x2F;simple&lt;&#x2F;url-pattern&gt;</span><br><span class="line">&lt;&#x2F;servlet-mapping&gt;</span><br></pre></td></tr></table></figure>


<h4 id="서블릿-리스너와-서블릿-필터"><a href="#서블릿-리스너와-서블릿-필터" class="headerlink" title="서블릿 리스너와 서블릿 필터"></a>서블릿 리스너와 서블릿 필터</h4><ul>
<li>서블릿 리스너<br>: 웹 애플리케이션에서 발생하는 주요 이벤트를 감지하고 각 이벤트에 특별한 작업이 필요한 경우 사용할 수 있다.<ul>
<li>서블릿 컨텍스트 수준의 이벤트<br>: 컨텍스트 라이프 사이클, 애트리뷰트 변경 이벤트</li>
<li>세션 수준의 이벤트<br>: 세션 라이프 사이클, 애트리뷰트 변경 이벤트</li>
</ul>
</li>
</ul>
<p>서블릿 컨텍스트 : 서블릿들이 공용으로 사용할 자원의 저장소  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MyListener implements ServletContextListener &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void contextInitialized(ServletContextEvent sce) &#123;</span><br><span class="line">        System.out.println(&quot;Context Initialized&quot;);</span><br><span class="line">        sce.getServletContext().setAttribute(&quot;name&quot;,&quot;jilee&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void contextDestroyed(ServletContextEvent sce) &#123;</span><br><span class="line">        System.out.println(&quot;Context Destroied&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>서블릿 필터<br>: 들어온 요청을 서블릿으로 보내기 전, 또는 서블릿이 작성한 응답을 클라이언트로 보내기 전에 특별한 작업이 필요한 경우 사용할 수 있다.<br>서블릿 필터는 체인 형태의 구조를 가지고 있다.  </li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MyFilter implements Filter &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void init(FilterConfig filterConfig) throws ServletException &#123;</span><br><span class="line">        System.out.println(&quot;Filter init&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;</span><br><span class="line">        System.out.println(&quot;Filter&quot;);</span><br><span class="line">        &#x2F;&#x2F;doFilter에서는 Chainning을 해줘야한다.</span><br><span class="line">        filterChain.doFilter(servletRequest,servletResponse);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void destroy() &#123;</span><br><span class="line">        System.out.println(&quot;Filter destroy&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>리스너와 필터도 서블릿과 마찬가지로 web.xml에 등록되어야 한다.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;listener&gt;</span><br><span class="line">    &lt;listener-class&gt;kr.co.myapp.web.MyListener&lt;&#x2F;listener-class&gt;</span><br><span class="line">&lt;&#x2F;listener&gt;</span><br><span class="line"></span><br><span class="line">&lt;filter&gt;</span><br><span class="line">    &lt;filter-name&gt;myFilter&lt;&#x2F;filter-name&gt;</span><br><span class="line">    &lt;filter-class&gt;kr.co.myapp.web.MyFilter&lt;&#x2F;filter-class&gt;</span><br><span class="line">&lt;&#x2F;filter&gt;</span><br><span class="line"></span><br><span class="line">&lt;filter-mapping&gt;</span><br><span class="line">    &lt;filter-name&gt;myFilter&lt;&#x2F;filter-name&gt;</span><br><span class="line">    &lt;servlet-name&gt;simple&lt;&#x2F;servlet-name&gt;</span><br><span class="line">&lt;&#x2F;filter-mapping&gt;</span><br></pre></td></tr></table></figure>

<h3 id="서블릿-애플리케이션에서-Spring-연동"><a href="#서블릿-애플리케이션에서-Spring-연동" class="headerlink" title="서블릿 애플리케이션에서 Spring 연동"></a>서블릿 애플리케이션에서 Spring 연동</h3><h4 id="IoC-컨테이너를-활용하는-방법"><a href="#IoC-컨테이너를-활용하는-방법" class="headerlink" title="IoC 컨테이너를 활용하는 방법"></a>IoC 컨테이너를 활용하는 방법</h4><p>Spring 웹 MVC 의존성 추가</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-webmvc&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.2.7.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<p>ContextLoaderListener<br> : Spring이 제공하는 서블릿 리스너, ApplicationContext를 생성하고 서블릿 컨텍스트에 등록해준다.<br> 서블릿 컨텍스트의 라이프 사이클에 맞춰서 Spring이 제공하는 ApplicationContext를 사용할 수 있도록 연동해서 서블릿이 ApplicationContext를 사용할 수 있도록 해준다.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;listener&gt;</span><br><span class="line">    &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;&#x2F;listener-class&gt;</span><br><span class="line">&lt;&#x2F;listener&gt;</span><br></pre></td></tr></table></figure>

<p>ApplicationContext가 있어야 하기 때문에 xml 또는 java를 이용한 Spring 설정 파일이 필요하다.  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;생성할 ApplicationContext 타입 설정</span><br><span class="line">&lt;context-param&gt;</span><br><span class="line">    &lt;param-name&gt;contextClass&lt;&#x2F;param-name&gt;</span><br><span class="line">    &lt;param-value&gt;org.springframework.web.context.support.AnnotationConfigWebApplicationContext&lt;&#x2F;param-value&gt;</span><br><span class="line">&lt;&#x2F;context-param&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;참조할 ApplicationContext java 설정 파일 등록</span><br><span class="line">&lt;context-param&gt;</span><br><span class="line">    &lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt;</span><br><span class="line">    &lt;param-value&gt;kr.co.myapp.web.AppConfig&lt;&#x2F;param-value&gt;</span><br><span class="line">&lt;&#x2F;context-param&gt;</span><br></pre></td></tr></table></figure>


<h4 id="DispatcherServlet을-활용하는-방법"><a href="#DispatcherServlet을-활용하는-방법" class="headerlink" title="DispatcherServlet을 활용하는 방법"></a>DispatcherServlet을 활용하는 방법</h4><p>DispatcherServlet은 스프링이 제공하는 스프링 MVC의 핵심적인 클래스이며 Front Controller 역할을 한다.  </p>
<p>Front Controller : 다른 Controller로 요청을 Dispatch 해주는 역할을 하는 Controller</p>
<p>DispatcherServlet의 특징은 ApplicationContext를 추가로 생성하며 계층구조를 가지게 되는데,<br>이때 기존에 서블릿 컨택스트에 있던 ApplicationContext는 “Root WebApplicationContext”,<br>DispatcherServlet으로 인해 추가로 생성되어 Root WebApplication을 부모로 가지는 ApplicationContext를 “Servlet WebApplicationContext” 라고 한다.  </p>
<p>Root WebApplicationContext : 다른 서블릿들도 공용으로 사용할 수 있는 부분, 웹과 관련된 빈들을 등록하지 않는다.<br>주로 Serivce / Repository가 등록됨.</p>
<p>Servlet WebApplicationContext : 해당 DispatcherServlet에서만 한정적으로 사용할 수 있는 부분, 웹 관련 빈들이 등록된다.<br>주로 Controller / View resolver 가 등록됨 </p>
<p>DispatcherServlet 등록, Servlet WebApplicationContext용 Config 파일이 필요하다.<br>(Root 용으로는 웹관련 빈이 제외하도록하고 DispatcherServlet 용으로는 웹관련 빈이 등록되게 하는 등 작업필요)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;servlet&gt;</span><br><span class="line">    &lt;servlet-name&gt;app&lt;&#x2F;servlet-name&gt;</span><br><span class="line">    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;&#x2F;servlet-class&gt;</span><br><span class="line">    &lt;init-param&gt;</span><br><span class="line">        &lt;param-name&gt;contextClass&lt;&#x2F;param-name&gt;</span><br><span class="line">        &lt;param-value&gt;org.springframework.web.context.support.AnnotationConfigWebApplicationContext&lt;&#x2F;param-value&gt;</span><br><span class="line">        &lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt;</span><br><span class="line">        &lt;param-value&gt;kr.co.myapp.web.WebConfig&lt;&#x2F;param-value&gt;</span><br><span class="line">    &lt;&#x2F;init-param&gt;</span><br><span class="line">&lt;&#x2F;servlet&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; &#x2F;app밑으로의 모든 요청은 DispatcherServlet을 통하도록</span><br><span class="line">&lt;servlet-mapping&gt;</span><br><span class="line">    &lt;servlet-name&gt;app&lt;&#x2F;servlet-name&gt;</span><br><span class="line">    &lt;url-pattern&gt;&#x2F;app&#x2F;*&lt;&#x2F;url-pattern&gt;</span><br><span class="line">&lt;&#x2F;servlet-mapping&gt;</span><br></pre></td></tr></table></figure>

<p>DispatcherServlet을 하나만 사용할 경우는 계층구조를 하지 않아도 된다.<br>(Servlet WebApplicationContext에 모든 빈을 등록하면 된다.)</p>
<p>참고로 스프링 부트에서는 구조가 완전히 다른데,<br>보통 서블릿 컨테이너에 등록되는 웹 애플리케이션에 Spring을 연동하는 반면,<br>스프링 부트는 스프링 부트 자바 애플리케이션이 먼저 뜨고 그 안에 내장되어 있는 톰캣이 뜨게된다.  </p>
<h3 id="DispatcherServlet-동작-원리"><a href="#DispatcherServlet-동작-원리" class="headerlink" title="DispatcherServlet 동작 원리"></a>DispatcherServlet 동작 원리</h3><h4 id="DispatcherServlet-초기화"><a href="#DispatcherServlet-초기화" class="headerlink" title="DispatcherServlet 초기화"></a>DispatcherServlet 초기화</h4><ul>
<li>특별한 타입의 빈들을 찾거나 기본 전력에 해당하는 빈들을 등록한다.</li>
<li>HandlerMapping : 핸들러를 찾아주는 인터페이스</li>
<li>HandlerAdapter : 핸들러를 실행하는 인터페이스</li>
<li>HandlerExceptionResolver : 예외 처리 인터페이스</li>
<li>ViewResolver : 뷰를 찾아주는 인터페이스</li>
<li>…  </li>
</ul>
<h4 id="DispatcherServlet-동작-순서"><a href="#DispatcherServlet-동작-순서" class="headerlink" title="DispatcherServlet 동작 순서"></a>DispatcherServlet 동작 순서</h4><ol>
<li>요청 분석 (Locale, 테마, 멀티파트 등)</li>
<li>HandlerMapping에 위임하여 요청을 처리할 핸들러를 찾는다.<br>(기본적인 HandlerMapping : BeanNameUrlHandlerMapping, RequestMappingHandlerMapping)</li>
<li>찾아진 핸들러를 실행할 수 있는 HandlerAdapter를 찾는다.</li>
<li>찾아낸 HandlerAdapter를 이용해서 핸들러의 응답을 처리한다.<ul>
<li>핸들러의 리턴값을 보고 어떻게 처리할지 판단한다.<ul>
<li>리턴값의 뷰 이름에 해당하는 뷰를 찾아서(ViewResolver) 모델 데이터를 랜더링한다.</li>
<li>@ResponseBody가 있다면 Converter를 사용해서 응답 본문을 만들고(리턴 String을 본문에 넣는 등) ModelAndView는 null이 된다.</li>
</ul>
</li>
</ul>
</li>
<li>만약 예외가 발생했다면 HandlerExceptionResolver에 요청 처리를 위임한다. </li>
<li>최종적으로 응답을 보낸다.</li>
</ol>
<h4 id="커스텀-ViewResolver"><a href="#커스텀-ViewResolver" class="headerlink" title="커스텀 ViewResolver"></a>커스텀 ViewResolver</h4><p>DispatcherServlet이 사용하는 여러가지 멀티파트 전략들이 구성될때,<br>만약 ApplicationContext에 커스텀하게 특정 전략 타입의 빈으로 등록되어 있다면 해당 전략을 사용하고,<br>ApplicationContext에 그런 빈이 없다면 기본적으로 제공되는 전략(defaultStrategies)을 사용하게 된다.  </p>
<p>/WEB-INF 에서 .jsp로 끝나는 뷰를 찾아주는 커스텀 ViewResolver</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public ViewResolver viewResolver() &#123;</span><br><span class="line">    InternalResourceViewResolver viewResolver &#x3D; new InternalResourceViewResolver();</span><br><span class="line">    viewResolver.setPrefix(&quot;&#x2F;WEB-INF&#x2F;&quot;);</span><br><span class="line">    viewResolver.setSuffix(&quot;.jsp&quot;);</span><br><span class="line">    return viewResolver;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>=&gt; 커스텀을 사용하면 기본 ViewResolver는 추가되지 않는다.</p>
<p>참고로 Strategy interface의 구현체들을 찾아내고 빈으로 등록하는 일련의 과정들은 DispatcherServlet이 초기화될 때의 한번만 일어나기 때문에 이 후 요청에서는 생략된다.<br>(서블릿의 라이프 사이클에서 init()이 한번만 수행되는 것)</p>
]]></content>
      <categories>
        <category>Study</category>
        <category>Spring Framework</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Spring MVC</tag>
        <tag>Servlet</tag>
      </tags>
  </entry>
</search>
