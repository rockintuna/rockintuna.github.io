<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>03. 설치 (IntelliJ 사용)</title>
    <url>/2020/08/12/hexo_1_Java_basic_03/</url>
    <content><![CDATA[<h1 id="Java-기초"><a href="#Java-기초" class="headerlink" title="Java 기초"></a>Java 기초</h1><h4 id="03-설치-IntelliJ-사용"><a href="#03-설치-IntelliJ-사용" class="headerlink" title="03. 설치 (IntelliJ 사용)"></a>03. 설치 (IntelliJ 사용)</h4><ul>
<li><p>아래 ORACLE URL을 통해 원하는 버전의 JDK를 설치한다.<br><a href="https://www.oracle.com/java/technologies/javase-downloads.html" target="_blank" rel="noopener">https://www.oracle.com/java/technologies/javase-downloads.html</a></p>
</li>
<li><p>Eclipse 또는 IntelliJ에서 새로운 프로젝트를 생성한다.<br>File &gt; New &gt; Project… &gt; Java 선택 &gt; Project SDK를 설치한 Java로 설정 &gt; Next &gt; Next &gt; Project 이름 및 Location 설정 &gt; Finish</p>
</li>
<li><p>간단한 프로그램 작성</p>
<ul>
<li>src에 ‘hello’ 패키지 생성 (Command+N Mac)</li>
<li>‘hello’ 패키지에 ‘HelloJava’ Class 생성 (Command+N Mac)     </li>
</ul>
</li>
</ul>
<p><em>주의 :</em><br>패키지 이름은 소문자(hello)로 한다.<br>Class 이름은 대문자(HelloJava)로 <em>시작</em>한다.  </p>
<p>main 함수는 class를 시작하는? 함수이다.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package hello;</span><br><span class="line"></span><br><span class="line">public class HelloJava &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;Hello, Java&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>컴파일을 위해서 소스코드를 빌드한다.<br>Build &gt; Build Project (Command+F9 [Mac])    </p>
</li>
<li><p>프로젝트 디렉토리에 있는 class 파일을 확인한다.     </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ls out&#x2F;production&#x2F;First&#x2F;hello&#x2F;</span><br><span class="line">HelloJava.class</span><br></pre></td></tr></table></figure>
</li>
<li><p>Run<br>Run &gt; Run (Control+Option+R [Mac])    </p>
</li>
</ul>
<p>화면 확인<br>Hello, Java     </p>
]]></content>
      <categories>
        <category>Study</category>
        <category>Java Basic</category>
      </categories>
  </entry>
  <entry>
    <title>04. 변수와 자료형</title>
    <url>/2020/08/12/hexo_1_Java_basic_04/</url>
    <content><![CDATA[<h1 id="Java-기초"><a href="#Java-기초" class="headerlink" title="Java 기초"></a>Java 기초</h1><h4 id="04-변수와-자료형"><a href="#04-변수와-자료형" class="headerlink" title="04. 변수와 자료형"></a>04. 변수와 자료형</h4><p>0000 1010 (2진수 8 bit) = 10 (10진수)<br>2진수 4 bit(ex: 0101 = 5)는 최대 15까지 표현 가능하다.</p>
<ul>
<li>컴퓨터에서 음수 표현 (2의 보수)</li>
</ul>
<p>0000 1010에서 맨앞의 0은 부호비트(MSB)이다. (0:양수 1:음수)   </p>
<p>보수 : 더했을 때 MSB가 새로 밀리고 다른 값이 0이되도록 하는 수   </p>
<p>2의 보수 구하는 법 :<br>0000 1010 (10) 의 1의 보수 (모든 bit 바꿈)   </p>
<p>-&gt; 1111 0101 에 0000 0001을 더한다<br>+ 0000 0001<br>= 1111 0110</p>
<p>검증 (2의 보수와 더 했을때 0이되어야 한다.)<br>0000 1010<br>+ 1111 0110<br>= 1 0000 0000 (밀려 MSB를 제외한 모든 비트 = 0)   </p>
]]></content>
      <categories>
        <category>Study</category>
        <category>Java Basic</category>
      </categories>
  </entry>
  <entry>
    <title>05. 변수란 무엇인가</title>
    <url>/2020/08/12/hexo_1_Java_basic_05/</url>
    <content><![CDATA[<h1 id="Java-기초"><a href="#Java-기초" class="headerlink" title="Java 기초"></a>Java 기초</h1><h4 id="05-변수란-무엇인가"><a href="#05-변수란-무엇인가" class="headerlink" title="05. 변수란 무엇인가"></a>05. 변수란 무엇인가</h4><p>변수 : 변하는 수<br>상수 : 변하지 않는 수</p>
<p>변수는 <em>선언</em>이 필요하다.   </p>
<p>선언 방법 :<br>자료형 변수이름;<br>int age; </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package variable;</span><br><span class="line"></span><br><span class="line">public class VariableTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int age, count;</span><br><span class="line">        int age_2 &#x3D; 20;</span><br><span class="line">        age &#x3D; 30;</span><br><span class="line">        System.out.println(age);</span><br><span class="line">        System.out.println(age_2);</span><br><span class="line"></span><br><span class="line">        age &#x3D; 10;</span><br><span class="line">        System.out.println(age);</span><br><span class="line">        count &#x3D; 1;</span><br><span class="line">        System.out.println(count);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>‘=’표시는 같다는 의미가 아니고 대입의 의미이다. (l-value=r-value : r-value를 l-value에 대입)<br>그렇기 때문에 언제든지 변수는 바뀔 수 있다.   </p>
<p>선언은 여러 변수를 한번에 할 수 도 있고 선언과 동시에 초기화(대입)할 수도 있다.  </p>
<p>선언은 해당 변수형의 크기 만큼 메모리를 사용한다.<br>(ex int age; -&gt; 4byte 메모리 점유)   </p>
<p>변수이름은…</p>
<ol>
<li>숫자로 시작할 수 없다.</li>
<li>특수문자는 ‘_’와 ‘$’만 가능하다.</li>
<li>예약어는 쓸 수 없다. (ex : while, for, int, etc…)</li>
<li>쓰임에 맞게 명명해야 가독성이 좋다. (줄여서 약어로 쓰지 말자.)</li>
</ol>
<p>되도록 소문자로 시작하고 단어가 바뀔때 대문자 (camel notation)      </p>
]]></content>
      <categories>
        <category>Study</category>
        <category>Java Basic</category>
      </categories>
  </entry>
  <entry>
    <title>06. 정수 자료형</title>
    <url>/2020/08/12/hexo_1_Java_basic_06/</url>
    <content><![CDATA[<h1 id="Java-기초"><a href="#Java-기초" class="headerlink" title="Java 기초"></a>Java 기초</h1><h4 id="06-정수-자료형"><a href="#06-정수-자료형" class="headerlink" title="06. 정수 자료형"></a>06. 정수 자료형</h4><p>자료형 종류 : </p>
<ol>
<li>기본형 : 자바에서 기본 제공 (정수형, 문자형, 실수형, 논리형)</li>
<li>참조형 : 클래스 형식의 자료형</li>
</ol>
<p>정수형<br>byte &lt; short &lt; int(보통) &lt; long<br>문자형<br>char<br>실수형<br>float &lt; double(보통)<br>논리형<br>boolean     </p>
<ul>
<li>int<br>4byte(32bit)<br>MSB를 제외한 31bit를 사용하여 -2^31 ~ 2^31-1(2147483647)까지 표현 가능     </li>
</ul>
<p>package variable;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class IntegerTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        byte bs1 &#x3D; -128;</span><br><span class="line">        &#x2F;&#x2F;byte bs2 &#x3D; 128;</span><br><span class="line">        System.out.println(bs1);</span><br><span class="line">        &#x2F;&#x2F;System.out.println(bs2);</span><br><span class="line">        &#x2F;&#x2F;int iVal &#x3D; 12345678900;</span><br><span class="line">        &#x2F;&#x2F;long lVal &#x3D; 12345678900;</span><br><span class="line">        long lVal &#x3D; 12345678900L;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>해당 정수형의 한계를 초과하면 error 발생<br>-&gt; 더 큰 정수형 사용   </p>
<p>long type을 사용할 때 4byte 이상의 수를 대입할 경우 숫자를 그냥 쓰면 error 발생<br>-&gt; 리터럴은 기본적으로 4byte이므로 숫자 마지막에 ‘L’을 입력하여(long으로 취급) 8byte로 사용      </p>
]]></content>
      <categories>
        <category>Study</category>
        <category>Java Basic</category>
      </categories>
  </entry>
  <entry>
    <title>07. 문자 자료형</title>
    <url>/2020/08/12/hexo_1_Java_basic_07/</url>
    <content><![CDATA[<h1 id="Java-기초"><a href="#Java-기초" class="headerlink" title="Java 기초"></a>Java 기초</h1><h4 id="07-문자-자료형"><a href="#07-문자-자료형" class="headerlink" title="07. 문자 자료형"></a>07. 문자 자료형</h4><p>인코딩 : 문자 -&gt; 숫자값(코드)<br>‘A’ -&gt; 65<br>디코딩 : 코드 -&gt; 문자<br>65 -&gt; ‘A’   </p>
<p>문자세트 (code-set)</p>
<ol>
<li>아스키(ASCII) : 1byte 영문자, 숫자, 특수문자 표현</li>
<li>유니코드(Unicode) : 한글 등 복잡한 언어 표현<br>‘가’ -&gt; AC00 (2byte)</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package variable;</span><br><span class="line"></span><br><span class="line">public class CharacterTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        char ch &#x3D; &#39;A&#39;;</span><br><span class="line">        System.out.println(ch);</span><br><span class="line">        System.out.println((int)ch);</span><br><span class="line"></span><br><span class="line">        int iCh &#x3D; 66;</span><br><span class="line">        System.out.println((char)iCh);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;char ch2 &#x3D; -66;</span><br><span class="line"></span><br><span class="line">        char hangul &#x3D; &#39;\uAC00&#39;;</span><br><span class="line">        System.out.println(hangul);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;char hangul2 &#x3D; &#39;한글&#39;;</span><br><span class="line">        char hangul2 &#x3D; &#39;한&#39;;</span><br><span class="line">        System.out.println(hangul2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(int)로 코드 확인 가능<br>(char)로 코드를 문자로 확인 가능<br>char type은 음수 불가능<br>문자형 자료에 ‘\u’를 추가하여 Unicode 의 코드 사용<br>char는 2byte인데 ‘한글’은 4byte이므로 불가능</p>
]]></content>
      <categories>
        <category>Study</category>
        <category>Java Basic</category>
      </categories>
  </entry>
  <entry>
    <title>08. 실수와 논리 자료형</title>
    <url>/2020/08/12/hexo_1_Java_basic_08/</url>
    <content><![CDATA[<h1 id="Java-기초"><a href="#Java-기초" class="headerlink" title="Java 기초"></a>Java 기초</h1><h4 id="08-실수와-논리-자료형"><a href="#08-실수와-논리-자료형" class="headerlink" title="08. 실수와 논리 자료형"></a>08. 실수와 논리 자료형</h4><ul>
<li>실수    </li>
</ul>
<p>double이 기본 float 사용시 f,F 식별자 사용<br>정수와 표현 방법이 다르다. (부동 소수점 방식)<br>지수부 + 가수부<br>0을 포현할 수 없으며 약간의 오차가 발생할 수 있다. (부동 소수점 방식의 오류)</p>
<p>1.0 x 10^-1<br>가수   밑수 지수      </p>
<p>float<br>MSB+지수부(8bit)+가수부(23bit)<br>double<br>MSB+지수부(11bit)+가수부(52bit)    </p>
<ul>
<li>논리 자료형    </li>
</ul>
<p>boolean<br>true,false 표현   </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package variable;</span><br><span class="line"></span><br><span class="line">public class DoubleTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        double dNum &#x3D; 3.14;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;float fNum &#x3D; 3.14;</span><br><span class="line">        float fNum &#x3D; 3.14F;</span><br><span class="line"></span><br><span class="line">        System.out.println(dNum);</span><br><span class="line">        System.out.println(fNum);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.14는 8byte (double)이므로 float에 그냥 대입하면 error 발생.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package variable;</span><br><span class="line"></span><br><span class="line">public class DoubleTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        double dNum &#x3D; 1;</span><br><span class="line">        for( int i &#x3D; 0; i &lt; 10000; i++) &#123;</span><br><span class="line">            dNum &#x3D; dNum + 0.1;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(dNum);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>결과는 1001.000000000159으로 약간의 오차가 발생한다.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package variable;</span><br><span class="line"></span><br><span class="line">public class BooleanTest &#123;</span><br><span class="line">    public static void main(String[] args)  &#123;</span><br><span class="line"></span><br><span class="line">        boolean isMarried &#x3D; false;</span><br><span class="line">        System.out.println(isMarried);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>false 또는 true 두가지 값 만 가능.</p>
<ul>
<li>자료형 없이 변수 사용하기 (var)</li>
</ul>
<p>Local variable type inference (java 10 이상)<br>지역변수에 한하여 컴파일러가 대입되는 값을 보고 변수형을 추론.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package variable;</span><br><span class="line"></span><br><span class="line">public class BooleanTest &#123;</span><br><span class="line">    public static void main(String[] args)  &#123;</span><br><span class="line">        var iVar &#x3D; 10;</span><br><span class="line">        var cVar &#x3D; &quot;Char&quot;;</span><br><span class="line"></span><br><span class="line">        System.out.println(iVar);</span><br><span class="line">        System.out.println(cVar);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Study</category>
        <category>Java Basic</category>
      </categories>
  </entry>
  <entry>
    <title>09. 상수와 리터럴, 형변환</title>
    <url>/2020/08/12/hexo_1_Java_basic_09/</url>
    <content><![CDATA[<h1 id="Java-기초"><a href="#Java-기초" class="headerlink" title="Java 기초"></a>Java 기초</h1><h4 id="09-상수와-리터럴-형변환"><a href="#09-상수와-리터럴-형변환" class="headerlink" title="09. 상수와 리터럴, 형변환"></a>09. 상수와 리터럴, 형변환</h4><p>상수 : 변하지 않는 수 (final 키워드)   </p>
<p>리터럴 : 프로그램에서 사용하는 모든 숫자, 값, 논리 값<br>모든 리터럴은 상수 풀(constant pool)에 저장되어 있다.<br>저장될 때 정수는 int, 실수는 double로 저장 된다.   </p>
<p>형 변환    </p>
<ol>
<li><p>묵시적 형 변환<br>작은 수 -&gt; 큰 수,<br>덜 정밀한 수 -&gt; 더 정밀한 수<br>로 대입되는 경우</p>
</li>
<li><p>명시적 형 변환<br>자료 형을 명시하여 변환, 자료 손실 발생 가능.</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package variable;</span><br><span class="line"></span><br><span class="line">public class ImplicitConversion &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        byte bNum &#x3D; 10;</span><br><span class="line">        int iNum &#x3D; bNum; &#x2F;&#x2F;더 큰수로 묵시적 형 변환</span><br><span class="line"></span><br><span class="line">        System.out.println(bNum);</span><br><span class="line">        System.out.println(iNum);</span><br><span class="line"></span><br><span class="line">        int iNum2 &#x3D; 20;</span><br><span class="line">        float fNum &#x3D; iNum2; &#x2F;&#x2F;더 정밀한 수로 형 변환</span><br><span class="line"></span><br><span class="line">        System.out.println(fNum);</span><br><span class="line"></span><br><span class="line">        double dNum;</span><br><span class="line">        dNum &#x3D; fNum + iNum; &#x2F;&#x2F;더 정밀한 수로 형 변환 2회 i-&gt;f-&gt;d</span><br><span class="line">        System.out.println(dNum);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package variable;</span><br><span class="line"></span><br><span class="line">public class ExplicitConversion &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        int i &#x3D; 1000;</span><br><span class="line">        &#x2F;&#x2F;byte bNum &#x3D; i;</span><br><span class="line">        byte bNum &#x3D; (byte)i; &#x2F;&#x2F;명시적 형 변환</span><br><span class="line">        System.out.println(bNum); &#x2F;&#x2F;데이터 유실</span><br><span class="line"></span><br><span class="line">        double dNum &#x3D; 1.2;</span><br><span class="line">        float fNum &#x3D; 0.9F;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;int iNum1 &#x3D; dNum + fNum;</span><br><span class="line">        int iNum1 &#x3D; (int)(dNum + fNum);</span><br><span class="line">        int iNum2 &#x3D; (int)dNum + (int)fNum;</span><br><span class="line">        System.out.println(iNum1); &#x2F;&#x2F;데이터 유실 2.1 -&gt; 2</span><br><span class="line">        System.out.println(iNum2); &#x2F;&#x2F;데이터 유실 1.2+0.9 -&gt; 1+0</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>10진수를 2,8,16진수로 쓰는 법</p>
<ul>
<li>2진수(0B) : 0B1010;</li>
<li>8진수(0) : 012;</li>
<li>16진수(0X) : 0XA;</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package variable;</span><br><span class="line"></span><br><span class="line">public class BinaryTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        int num &#x3D; 10;</span><br><span class="line">        int bNum &#x3D; 0B1010;</span><br><span class="line">        int oNum &#x3D; 012;</span><br><span class="line">        int xNum &#x3D; 0XA;</span><br><span class="line"></span><br><span class="line">        System.out.println(num);</span><br><span class="line">        System.out.println(bNum);</span><br><span class="line">        System.out.println(oNum);</span><br><span class="line">        System.out.println(xNum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Study</category>
        <category>Java Basic</category>
      </categories>
  </entry>
  <entry>
    <title>10. 대입, 부호, 산술, 복합대입, 증감 연산자</title>
    <url>/2020/08/12/hexo_1_Java_basic_10/</url>
    <content><![CDATA[<h1 id="Java-기초"><a href="#Java-기초" class="headerlink" title="Java 기초"></a>Java 기초</h1><h4 id="10-대입-부호-산술-복합대입-증감-연산자"><a href="#10-대입-부호-산술-복합대입-증감-연산자" class="headerlink" title="10. 대입, 부호, 산술, 복합대입, 증감 연산자"></a>10. 대입, 부호, 산술, 복합대입, 증감 연산자</h4><p>항 : 연산에 사용되는 값<br>연산자 : 항을 이용하여 연산하는 기호</p>
<ul>
<li><p>대입 연산자<br>int age = 20;<br>우선순위 가장 낮음.</p>
</li>
<li><p>단항 연산자<br>부호 유지 또는 변경 (+,-)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package operator;</span><br><span class="line"></span><br><span class="line">public class OperatorEx1 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        int num1 &#x3D; -10;</span><br><span class="line">        int num2 &#x3D; 20;</span><br><span class="line"></span><br><span class="line">        System.out.println(+num1);</span><br><span class="line">        System.out.println(+num2);</span><br><span class="line">        System.out.println(-num1);</span><br><span class="line">        System.out.println(-num2);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>+ 부호 유지<br>- 부호 변경<br>실제 변수 값의 부호를 바꾸려면 대입 연산자와 같이 사용.    </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int num1 &#x3D; -10;     </span><br><span class="line">num1 &#x3D; -num1;</span><br></pre></td></tr></table></figure></li>
<li><p>산술 연산자<br>사칙연산, %(나머지)    </p>
</li>
<li><p>복합 대입 연산자<br>대입 연산자 앞의 연산자의 결과를 l-value에 대입</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package operator;</span><br><span class="line"></span><br><span class="line">public class OperatorEx2 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        int num1&#x3D;10,num2&#x3D;10,num3&#x3D;10,num4&#x3D;10,num5 &#x3D; 10;</span><br><span class="line">        num1 +&#x3D; 2; &#x2F;&#x2F;r-value를 더한 뒤 대입</span><br><span class="line">        System.out.println(num1);</span><br><span class="line">        num2 -&#x3D; 2; &#x2F;&#x2F;r-value를 뺀 뒤 대입</span><br><span class="line">        System.out.println(num2);</span><br><span class="line">        num3 *&#x3D; 2; &#x2F;&#x2F;r-value를 곱한 뒤 대입</span><br><span class="line">        System.out.println(num3);</span><br><span class="line">        num4 &#x2F;&#x3D; 2; &#x2F;&#x2F;r-value로 나눈 몫을 대입</span><br><span class="line">        System.out.println(num4);</span><br><span class="line">        num5 %&#x3D; 2; &#x2F;&#x2F;r-value를 나눈 나머지 대입</span><br><span class="line">        System.out.println(num5);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>증가 감소 연산자<br>변수의 값을 1 더하거나 뺄때 사용     </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">val &#x3D; ++num; num 1 증가 후 대입</span><br><span class="line">val &#x3D; num++; 대입 후 num 1 증가</span><br><span class="line">val &#x3D; --num;</span><br><span class="line">val &#x3D; num--;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package operator;</span><br><span class="line"></span><br><span class="line">public class OperatorEx3 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        int score &#x3D; 100;</span><br><span class="line"></span><br><span class="line">        System.out.println(++score); &#x2F;&#x2F;101</span><br><span class="line">        &#x2F;&#x2F;++score 는 score &#x3D; score+1 과 같은 의미이다.</span><br><span class="line">        System.out.println(score++); &#x2F;&#x2F;101</span><br><span class="line">        System.out.println(score); &#x2F;&#x2F;102</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>증감 연산자는 대입을 내포한다.   </p>
]]></content>
      <categories>
        <category>Study</category>
        <category>Java Basic</category>
      </categories>
  </entry>
  <entry>
    <title>11. 관계, 논리, 조건 비트 연산자</title>
    <url>/2020/08/12/hexo_1_Java_basic_11/</url>
    <content><![CDATA[<h1 id="Java-기초"><a href="#Java-기초" class="headerlink" title="Java 기초"></a>Java 기초</h1><h4 id="11-관계-논리-조건-비트-연산자"><a href="#11-관계-논리-조건-비트-연산자" class="headerlink" title="11. 관계, 논리, 조건 비트 연산자"></a>11. 관계, 논리, 조건 비트 연산자</h4><ul>
<li><p>관계자 연산자<br>= 비교연산자<br>결과가 true/false로 반환 됨.<br>‘&gt;’, ‘&lt;’, ‘&gt;=’, ‘&lt;=’, ‘==’, ‘!=’</p>
</li>
<li><p>논리 연산자<br>결과가 true/false로 반환 됨.<br>&amp;&amp; 논리 곱, 두 항 모두 참이어야 true<br>|| 논리 합, 두 항 중 하나만 참이면 true<br>! 부정, 항의 논리 결과 변경 (true -&gt; false, false -&gt; true)    </p>
</li>
</ul>
<p>단락 회로 평가<br>앞 항 결과만으로 논리 연산자 결과가 나온다면 뒷 항은 평가되지 않음.<br>-&gt; 프로그램에서 예상하지 못한 결과가 발생할 수 있으므로 유의</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package operator;</span><br><span class="line"></span><br><span class="line">public class OperatorEx3 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        int num1 &#x3D; 10;</span><br><span class="line">        int i &#x3D; 2;</span><br><span class="line"></span><br><span class="line">        boolean value &#x3D; ((num1+&#x3D;10)&lt;10)&amp;&amp;((i+&#x3D;2)&lt;10);</span><br><span class="line">        System.out.println(value); &#x2F;&#x2F;false</span><br><span class="line">        System.out.println(num1);  &#x2F;&#x2F;20</span><br><span class="line">        System.out.println(i);     &#x2F;&#x2F;2</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>논리 곱에서 왼쪽 항은 연산이 되었으나 오른쪽 항은 연산되지 않았음을 확인할 수 있다.    </p>
<ul>
<li><p>조건 연산자<br>조건식? 결과1: 결과2;  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int num &#x3D; (5&gt;3)&gt; 10: 20;</span><br></pre></td></tr></table></figure>
</li>
<li><p>비트 연산자<br>~ : 비트 반전 (1의 보수)<br>&amp; : 비트 단위 AND, 1&amp;1 만 1<br>| : 비트 단위 OR, 0|0 만 0<br>^ : 비트 단위 XOR   두 비트가 서로 다른 경우 1<br>&lt;&lt; : 왼쪽 shift   a &lt;&lt; 2 a를 2bit 만큼 왼쪽으로 이동, 0으로 채움<br>&gt;&gt; : 오른쪽 shift, 부호비트로 채움<br>&gt;&gt;&gt; : 오른쪽 shift, 0으로 채움<br>왼쪽 : 곱하기, 오른쪽 : 나누기     </p>
</li>
</ul>
<p>어디에 사용하나<br>마스크 : 몇개의 비트 값만 사용할 떄<br>비트켜기 : &amp;00001111 하위 4bit중 1인 비트만 꺼내기<br>비트끄기 : |11110000 하위 4bit중 0인 비트만 0으로 만들기<br>비트토글 : 모든 비트들을 0은 1로, 1은 0으로 바꾸고 싶을 때<br>shift를 통해 곱하기를 빠르게      </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package operator;</span><br><span class="line"></span><br><span class="line">public class OperatorEx4 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        int num1 &#x3D; 0B00001010; &#x2F;&#x2F;10</span><br><span class="line">        int num2 &#x3D; 0B00000101; &#x2F;&#x2F;5</span><br><span class="line"></span><br><span class="line">        System.out.println(num1 &amp; num2); &#x2F;&#x2F;00000000 0</span><br><span class="line">        System.out.println(num1 | num2); &#x2F;&#x2F;00001111 15</span><br><span class="line">        System.out.println(num1 ^ num2); &#x2F;&#x2F;00001111 15</span><br><span class="line">        System.out.println(num2 &lt;&lt; 1); &#x2F;&#x2F;(x2) 00001010 10</span><br><span class="line">        System.out.println(num2 &lt;&lt; 2); &#x2F;&#x2F;(x2^2) 00010100 20</span><br><span class="line">        System.out.println(num2 &lt;&lt; 3); &#x2F;&#x2F;(x2^3) 00010100 40</span><br><span class="line">        System.out.println(num2 &gt;&gt; 2); &#x2F;&#x2F;(&#x2F;2^2) 00000001 1</span><br><span class="line">        System.out.println(num2 &lt;&lt;&#x3D; 3); &#x2F;&#x2F;복합 대입 연산자 40</span><br><span class="line">        System.out.println(num2); &#x2F;&#x2F;40</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Study</category>
        <category>Java Basic</category>
      </categories>
  </entry>
  <entry>
    <title>13. 제어문 if</title>
    <url>/2020/08/12/hexo_1_Java_basic_13/</url>
    <content><![CDATA[<h1 id="Java-기초"><a href="#Java-기초" class="headerlink" title="Java 기초"></a>Java 기초</h1><h4 id="13-제어문-if"><a href="#13-제어문-if" class="headerlink" title="13. 제어문 if"></a>13. 제어문 if</h4><p>if (조건식) {<br>    수행문;<br>}<br>조건식이 참인 경우 수행. 거짓인 경우 조건문 종료.   </p>
<p>if (조건식) {<br>    수행문1;<br>} else {<br>    수행문2;<br>}   </p>
<p>조건식이 참인 경우 수행. 거짓인 경우 else.     </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package ifexample;</span><br><span class="line"></span><br><span class="line">public class IfExample1 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        char gender &#x3D; &#39;M&#39;;</span><br><span class="line"></span><br><span class="line">        if ( gender &#x3D;&#x3D; &#39;F&#39; ) &#123; &#x2F;&#x2F; 블럭의 시작</span><br><span class="line">            System.out.println(&quot;여성입니다.&quot;); &#x2F;&#x2F; 블럭 내부에서는 들여쓰기</span><br><span class="line">        &#125; &#x2F;&#x2F; 블럭 끝</span><br><span class="line">        else &#123;</span><br><span class="line">            System.out.println(&quot;남성입니다.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>조건이 여러개일 때는..   </p>
<p>if (조건식) {<br>    수행문1;<br>} else if (조건식) {<br>    수행문2;<br>} else if (조건식) {<br>    수행문3;<br>} else {<br>    수행문4;<br>}  </p>
<p>나이별 요금 계산</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package ifexample;</span><br><span class="line"></span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class IfExample2 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        Scanner scanner &#x3D; new Scanner(System.in);</span><br><span class="line">        int age &#x3D; scanner.nextInt();</span><br><span class="line">        int charge &#x3D; 0;</span><br><span class="line"></span><br><span class="line">        if ( age &lt; 8 ) &#123;</span><br><span class="line">            charge &#x3D; 1000;</span><br><span class="line">        &#125;</span><br><span class="line">        else if ( age &lt; 14 ) &#123;</span><br><span class="line">            charge &#x3D; 1500;</span><br><span class="line">        &#125;</span><br><span class="line">        else if ( age &lt; 20 ) &#123;</span><br><span class="line">            charge &#x3D; 2000;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            charge &#x3D; 3000;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;나이 : &quot; + age);</span><br><span class="line">        System.out.println(&quot;요금 : &quot; + charge);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>점수별 학점 계산</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package ifexample;</span><br><span class="line"></span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class IfExample3 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        Scanner scanner &#x3D; new Scanner(System.in);</span><br><span class="line">        int score &#x3D; scanner.nextInt();</span><br><span class="line">        char grade;</span><br><span class="line"></span><br><span class="line">        if ( score&gt;&#x3D;90 ) &#123;</span><br><span class="line">            grade &#x3D; &#39;A&#39;;</span><br><span class="line">        &#125;</span><br><span class="line">        else if ( score&gt;&#x3D;80 ) &#123;</span><br><span class="line">            grade &#x3D; &#39;B&#39;;</span><br><span class="line">        &#125;</span><br><span class="line">        else if ( score&gt;&#x3D;70 ) &#123;</span><br><span class="line">            grade &#x3D; &#39;C&#39;;</span><br><span class="line">        &#125;</span><br><span class="line">        else if ( score&gt;&#x3D;60 ) &#123;</span><br><span class="line">            grade &#x3D; &#39;D&#39;;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            grade &#x3D; &#39;F&#39;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;점수 : &quot; + score);</span><br><span class="line">        System.out.println(&quot;학점 : &quot; + grade);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>조건문과 조건 연산자</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package ifexample;</span><br><span class="line"></span><br><span class="line">public class IfExample3 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        int a &#x3D; 10;</span><br><span class="line">        int b &#x3D;20;</span><br><span class="line">        int max;</span><br><span class="line"></span><br><span class="line">        max &#x3D; (a&gt;b)? a:b;</span><br><span class="line"></span><br><span class="line">        System.out.println(max);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 위와 아래는 동일한 결과.</span><br><span class="line"></span><br><span class="line">        if (a&gt;b) &#123;</span><br><span class="line">            max &#x3D; a;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            max &#x3D; b;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(max);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Study</category>
        <category>Java Basic</category>
      </categories>
  </entry>
  <entry>
    <title>15. 제어문 switch ~ case</title>
    <url>/2020/08/12/hexo_1_Java_basic_15/</url>
    <content><![CDATA[<h1 id="Java-기초"><a href="#Java-기초" class="headerlink" title="Java 기초"></a>Java 기초</h1><h4 id="15-제어문-switch-case"><a href="#15-제어문-switch-case" class="headerlink" title="15. 제어문 switch ~ case"></a>15. 제어문 switch ~ case</h4><p>if ~ else if 문의 조건이 정수 또는 문자열일 경우 switch ~ case 로 사용할 수 있다.     </p>
<p>switch(변수){<br>    case 조건1: 수행문1;<br>    case 조건2: 수행문2:<br>    …<br>    default : 수행문n;<br>}       </p>
<p>package ifexample;</p>
<p>import java.util.Scanner;</p>
<p>public class SwitchCaseEx {<br>    public static void main(String[] args) {</p>
<pre><code>    Scanner scanner = new Scanner(System.in);

    int rank = scanner.nextInt();
    char medalColor;

    switch(rank) {
        case 1: medalColor=&apos;G&apos;;
                break; //break가 없으면 다음 case 문이 조건과 상관 없이 수행된다.
        case 2: medalColor=&apos;S&apos;;
                break;
        case 3: medalColor=&apos;B&apos;;
                break;
        default : medalColor=&apos;A&apos;; //default는 break이 필요 없다.
    }
    System.out.println(rank + &quot;등의 메달 색은 &quot; + medalColor + &quot;입니다.&quot;);
}</code></pre><p>}</p>
<p>자바 7부터 조건으로 문자열을 사용할 수 있다.  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package ifexample;</span><br><span class="line"></span><br><span class="line">public class SwitchCaseEx &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        String medalColorT&#x3D;&quot;Gold&quot;;</span><br><span class="line">        int rank;</span><br><span class="line"></span><br><span class="line">        switch(medalColorT) &#123;</span><br><span class="line">            case &quot;Gold&quot;:</span><br><span class="line">                rank &#x3D; 1;</span><br><span class="line">                break; &#x2F;&#x2F;break가 없으면 다음 case 문이 조건과 상관 없이 수행된다.</span><br><span class="line">            case &quot;Silver&quot;:</span><br><span class="line">                rank &#x3D; 2;</span><br><span class="line">                break;</span><br><span class="line">            case &quot;Bronze&quot;:</span><br><span class="line">                rank &#x3D; 3;</span><br><span class="line">                break;</span><br><span class="line">            default :</span><br><span class="line">                rank &#x3D; 0;</span><br><span class="line">                System.out.println(&quot;Error&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(medalColorT + &quot;메달은 &quot; + rank + &quot;등 입니다.&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>서로 다른 조건에 대한 수행문이 같은 경우 case를 병합할 수 있다.     </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package ifexample;</span><br><span class="line"></span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class SwitchCaseEx1 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        Scanner scanner &#x3D; new Scanner(System.in);</span><br><span class="line"></span><br><span class="line">        int month &#x3D; scanner.nextInt();</span><br><span class="line">        int day;</span><br><span class="line"></span><br><span class="line">        switch(month) &#123;</span><br><span class="line">            case 1: case 5: case 7: case 8: case 10: case 12:</span><br><span class="line">                    day&#x3D;31;</span><br><span class="line">                    break;</span><br><span class="line">            case 2: day&#x3D;28;</span><br><span class="line">                    break;</span><br><span class="line">            case 3: case 4: case 6: case 9: case 11:</span><br><span class="line">                    day&#x3D;30;</span><br><span class="line">                    break;</span><br><span class="line">            default :</span><br><span class="line">                    System.out.println(&quot;Error&quot;);</span><br><span class="line">                    day &#x3D; 0;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(month + &quot;월의 날짜 수는 &quot; + day + &quot;일 입니다.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Study</category>
        <category>Java Basic</category>
      </categories>
  </entry>
  <entry>
    <title>16. 제어문 while, do-while</title>
    <url>/2020/08/12/hexo_1_Java_basic_16/</url>
    <content><![CDATA[<h1 id="Java-기초"><a href="#Java-기초" class="headerlink" title="Java 기초"></a>Java 기초</h1><h4 id="16-제어문-while-do-while"><a href="#16-제어문-while-do-while" class="headerlink" title="16. 제어문 while, do-while"></a>16. 제어문 while, do-while</h4><p>동일한 수행문을 조건이 맞는 동안 반복 수행.   </p>
<p>while(조건식) {<br>    수행문1;<br>    …<br>}<br>    수행문2;<br>    …     </p>
<p>while 내 조건문이 참인 경우 수행문1을 반복 수행한다.   </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package loopexample;</span><br><span class="line"></span><br><span class="line">public class WhileExample &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        int num &#x3D; 1;</span><br><span class="line">        int sum &#x3D; 0;</span><br><span class="line"></span><br><span class="line">        while ( num &lt;&#x3D; 10 ) &#123;</span><br><span class="line">            sum +&#x3D; num;</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(sum);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>do {<br>    수행문1;<br>    …<br>} while(조건식);<br>    수행문2;<br>    …</p>
<p>반복문 중 가장 안씀.<br>먼저 수행문1을 수행한 뒤 조건 체크.<br>최소 한번은 수행문이 수행되어야 하는 경우에 사용.    </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package loopexample;</span><br><span class="line"></span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class DoWhileExample1 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        Scanner scanner &#x3D; new Scanner(System.in);</span><br><span class="line"></span><br><span class="line">        int num;</span><br><span class="line">        int sum&#x3D;0;</span><br><span class="line"></span><br><span class="line">        do &#123;</span><br><span class="line">            num &#x3D; scanner.nextInt();</span><br><span class="line">            sum +&#x3D; num;</span><br><span class="line">            System.out.println(sum);</span><br><span class="line">        &#125; while ( num !&#x3D; 0 );</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Study</category>
        <category>Java Basic</category>
      </categories>
  </entry>
  <entry>
    <title>18. 제어문 for문, 중첩반복문</title>
    <url>/2020/08/12/hexo_1_Java_basic_18/</url>
    <content><![CDATA[<h1 id="Java-기초"><a href="#Java-기초" class="headerlink" title="Java 기초"></a>Java 기초</h1><h4 id="18-제어문-for문-중첩반복문"><a href="#18-제어문-for문-중첩반복문" class="headerlink" title="18. 제어문 for문, 중첩반복문"></a>18. 제어문 for문, 중첩반복문</h4><ul>
<li>for문<br>반복문 중 가장 많이 사용됨.<br>일정횟수 반복 구현에 효율적.    </li>
</ul>
<p>for (초기화식; 조건식; 증감식;)<br>{<br>    수행문;<br>    …<br>}   </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package loopexample;</span><br><span class="line"></span><br><span class="line">public class ForExample &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        int num&#x3D;0;</span><br><span class="line">        int total &#x3D; 0;</span><br><span class="line"></span><br><span class="line">        while ( num &lt; 10) &#123;</span><br><span class="line">            total +&#x3D; num;</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(total);</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;위와 아래는 같은 로직이다.        </span><br><span class="line"></span><br><span class="line">        int count;</span><br><span class="line">        int sum&#x3D;0;</span><br><span class="line"></span><br><span class="line">        for(count&#x3D;0; count&lt;10; count++) &#123; &#x2F;&#x2F;횟수의 의미가 있는경우 0부터 시작하는 것에 익숙해지자.</span><br><span class="line">            sum +&#x3D; count;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sum);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>같은 로직이지만 for문이 더 편하고 가독성이 좋다.   </p>
<p>while, do-while은 조건식의 결과 또는 변수가 true,false인 경우 주로 사용.<br>for문은 특정 수의 범위, 횟수와 관련하여 반복되는 경우 사용. 배열과 같이 사용.     </p>
<ul>
<li><p>무한루프<br>while (true) {<br>…<br>}<br>or<br>for(;;) {<br>…<br>}   </p>
</li>
<li><p>중첩 반복문<br>반복문 내부에 또 다른 반복문 사용.<br>외부반복문 / 내부반복문 간의 변 값 변화에 유의.    </p>
</li>
</ul>
<p>중첩반복문을 이용한 구구단</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package loopexample;</span><br><span class="line"></span><br><span class="line">public class ForExample1 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        int num;</span><br><span class="line">        int count;</span><br><span class="line">        int result;</span><br><span class="line"></span><br><span class="line">        for(num&#x3D;2; num&lt;10; num++) &#123;</span><br><span class="line">            for (count &#x3D; 1; count &lt; 10; count++) &#123;</span><br><span class="line">                result &#x3D; num*count;</span><br><span class="line">                System.out.println(num+&quot;x&quot;+count+&quot;&#x3D;&quot;+result);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Study</category>
        <category>Java Basic</category>
      </categories>
  </entry>
  <entry>
    <title>20. break, continue 문</title>
    <url>/2020/08/12/hexo_1_Java_basic_20/</url>
    <content><![CDATA[<h1 id="Java-기초"><a href="#Java-기초" class="headerlink" title="Java 기초"></a>Java 기초</h1><h4 id="20-break-continue-문"><a href="#20-break-continue-문" class="headerlink" title="20. break, continue 문"></a>20. break, continue 문</h4><ul>
<li>break<br>감싸고 있는 블럭을 빠져나오는 기능.<br>주로 반복문, 조건문, switch-case문과 같이 사용됨.<br>반복문에서 특정 조건에서 반복 중지.    </li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package loopexample;</span><br><span class="line"></span><br><span class="line">public class BreakExample &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        int num;</span><br><span class="line">        int sum&#x3D;0;</span><br><span class="line"></span><br><span class="line">        for (num&#x3D;1; ; num++) &#123;</span><br><span class="line">            sum +&#x3D; num;</span><br><span class="line">            if (sum&gt;&#x3D;100) &#123;</span><br><span class="line">                break; &#x2F;&#x2F;sum이 100을 넘어가는 경우 반복 중지</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(sum);</span><br><span class="line">        System.out.println(num);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>continue<br>반복문에서 특정 조건에서 블럭 내부의 다른 수행문을 수행하지 않음.   </li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package loopexample;</span><br><span class="line"></span><br><span class="line">public class ContinueExample &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        int num;</span><br><span class="line"></span><br><span class="line">        for (num&#x3D;1; num&lt;&#x3D;100; num++) &#123;</span><br><span class="line">            if (num%3!&#x3D;0) &#123; &#x2F;&#x2F;3의 배수가 아닌 경우 출력 X</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(num);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>구구단 짝수단만 출력하면서 곱하는수가 단과 같거나 작은 경우만 출력</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package loopexample;</span><br><span class="line"></span><br><span class="line">public class BreakContinueTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        int dan;</span><br><span class="line">        int num;</span><br><span class="line">        int result;</span><br><span class="line"></span><br><span class="line">        for (dan&#x3D;2; dan&lt;10; dan++) &#123;</span><br><span class="line">            if (dan%2&#x3D;&#x3D;1) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            for (num&#x3D;1; num&lt;10; num++) &#123;</span><br><span class="line">                if (num&gt;dan) &#123;</span><br><span class="line">                    break; &#x2F;&#x2F;내부 반복문만 중지된다.</span><br><span class="line">                &#125;</span><br><span class="line">                result&#x3D;dan*num;</span><br><span class="line">                System.out.println(dan+&quot;X&quot;+num+&quot;&#x3D;&quot;+result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Study</category>
        <category>Java Basic</category>
      </categories>
  </entry>
  <entry>
    <title>01. 객체 지향 프로그래밍과 클래스</title>
    <url>/2020/08/12/hexo_OOP_01/</url>
    <content><![CDATA[<h1 id="객체-지향-프로그래밍"><a href="#객체-지향-프로그래밍" class="headerlink" title="객체 지향 프로그래밍"></a>객체 지향 프로그래밍</h1><h4 id="01-객체-지향-프로그래밍과-클래스"><a href="#01-객체-지향-프로그래밍과-클래스" class="headerlink" title="01. 객체 지향 프로그래밍과 클래스"></a>01. 객체 지향 프로그래밍과 클래스</h4><ul>
<li><p>객체 (Object)<br>의사나 행위가 미치는 대상 (사전적)<br>구체적, 추상적 데이터의 단위<br>예) 사람, 자동차, 주문, 생산, 관리…   </p>
</li>
<li><p>객체 지향 프로그래밍<br>객체를 기반으로 하는 프로그래밍<br>객체를 정의하고, 객체의 기능을 구현하며, 객체간의 협력을 구현<br>&lt;&gt; 절차 지향 프로그래밍      </p>
</li>
<li><p>클래스<br>객체를 코드로 구현한 것<br>객체 지향 프로그래밍의 가장 기본적인 요소<br>객체의 청사진     </p>
</li>
<li><p>멤버 변수<br>객체가 가지는 속성을 변수로 표현<br>클래스의 멤버 변수</p>
</li>
<li><p>메서드<br>객체의 기능을 구현  </p>
</li>
</ul>
<p>class 생성하기.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package classpart;</span><br><span class="line"></span><br><span class="line">public class Student &#123;  &#x2F;&#x2F;객체를 코드로 표현 -&gt; class</span><br><span class="line">    &#x2F;&#x2F;public class는 java file내에 하나만 존재하며 java file이름과 동일해야 한다.</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;객체의 속성을 변수로 표현 (멤버 변수, 속성)</span><br><span class="line">    public int studentId; &#x2F;&#x2F;public &#x3D; 접근제어자</span><br><span class="line">    public String studentName; &#x2F;&#x2F;문자열을 사용하기 위해 java에서 제공되는 class (java.lang package)</span><br><span class="line">    public String address;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;기능은 메서드로 구현</span><br><span class="line">    public void showStudentInfo() &#123; &#x2F;&#x2F;void:반환하는 값의 자료형을 나타냄(없음)</span><br><span class="line">                                    &#x2F;&#x2F;메서드 명 다음의 괄호 안에 매개변수가 있을수 도 있다.</span><br><span class="line">        System.out.println(studentName+&quot;,&quot;+address);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>다른 class에서 Student class 사용하기.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package classpart;</span><br><span class="line"></span><br><span class="line">public class StudentTest &#123; &#x2F;&#x2F;객체를 사용하는 건 다른 클래스인 경우가 대부분이다.</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Student studentLee &#x3D; new Student(); &#x2F;&#x2F;인스턴스 생성</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;참조 변수 사용 studentLee</span><br><span class="line">        studentLee.studentName &#x3D; &quot;이순신&quot;;  &#x2F;&#x2F;생성된 인스턴스(객체)의 멤버 변수를 사용할 수 있다.</span><br><span class="line">        studentLee.address &#x3D; &quot;서울&quot;;</span><br><span class="line"></span><br><span class="line">        studentLee.showStudentInfo(); &#x2F;&#x2F;생성된 인스턴스(객체)의 메서드를 사용할 수 있다.</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Study</category>
        <category>JAVA OOP</category>
      </categories>
  </entry>
  <entry>
    <title>03. 함수와 메서드</title>
    <url>/2020/08/12/hexo_OOP_03/</url>
    <content><![CDATA[<h1 id="객체-지향-프로그래밍"><a href="#객체-지향-프로그래밍" class="headerlink" title="객체 지향 프로그래밍"></a>객체 지향 프로그래밍</h1><h4 id="03-함수와-메서드"><a href="#03-함수와-메서드" class="headerlink" title="03. 함수와 메서드"></a>03. 함수와 메서드</h4><ul>
<li>함수(function)<br>하나의 기능을 수행하는 일련의 코드<br>함수는 호출하여 사용하 기능이 수행된 후 값을 반환할 수 있음<br>함수로 구현된 기능은 여러 곳에서 호출되어 사용될 수 있음 (코드의 재사용)<br>가독성, 유지보수에 좋다.</li>
</ul>
<p>함수는 이름, 매개변수, 반환 값, 몸체로 구성된다.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package classpart;</span><br><span class="line"></span><br><span class="line">public class FunctionTest &#123;</span><br><span class="line">    &#x2F;&#x2F;            반환type 이름(매개변수)</span><br><span class="line">    public static int addNum(int num1, int num2) &#123; &#x2F;&#x2F;2개의 매개변수 및 int 반환 값이 필요하다.</span><br><span class="line">        int result;</span><br><span class="line">        result &#x3D; num1+num2;</span><br><span class="line">        return result; &#x2F;&#x2F;반환 값 result</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void sayHello(String greeting) &#123; &#x2F;&#x2F;반환 값이 없는 함수 (void)</span><br><span class="line">        System.out.println(greeting);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static int calcSum() &#123; &#x2F;&#x2F;매개변수가 없고 반환 값만 있는 함수</span><br><span class="line"></span><br><span class="line">        int sum&#x3D;0;</span><br><span class="line">        int i;</span><br><span class="line"></span><br><span class="line">        for (i&#x3D;0;i&lt;&#x3D;100;i++) &#123;</span><br><span class="line">            sum +&#x3D; i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int n1 &#x3D; 10;</span><br><span class="line">        int n2 &#x3D; 20;</span><br><span class="line"></span><br><span class="line">        int total &#x3D; addNum(n1,n2); &#x2F;&#x2F;매개변수를 통해 함수의 반환 값을 int 변수로 받음.</span><br><span class="line">        sayHello(&quot;안녕&quot;); &#x2F;&#x2F;반환 값 없이 매개변수 출력</span><br><span class="line">        int num &#x3D; calcSum(); &#x2F;&#x2F;매개변수 없이 반환 값을 int 변수로 받음.</span><br><span class="line"></span><br><span class="line">        System.out.println(total);</span><br><span class="line">        System.out.println(num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>메서드<br>객체의 기능을 구현하기 위해 클래스 내에서 구현되는 함수<br>메서드를 구현함으로써 객체의 기능이 구현됨<br>메서드 이름은 사용하는 쪽에 맞게 명명<br>ex) getStudentName() (camel notation)<br>지역변수 : 함수 내에서 사용되는 변수   </p>
</li>
<li><p>메모리<br>stack : 함수 호출에 사용되는 memory, 함수의 호출이 끝나면 반환된다.<br>점유된 순서의 반대로 반환된다. (main부터 점유, main을 끝으로 반환.)</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Study</category>
        <category>JAVA OOP</category>
      </categories>
  </entry>
  <entry>
    <title>05. 인스턴스, 힙메모리</title>
    <url>/2020/08/12/hexo_OOP_05/</url>
    <content><![CDATA[<h1 id="객체-지향-프로그래밍"><a href="#객체-지향-프로그래밍" class="headerlink" title="객체 지향 프로그래밍"></a>객체 지향 프로그래밍</h1><h4 id="05-인스턴스-힙메모리"><a href="#05-인스턴스-힙메모리" class="headerlink" title="05. 인스턴스, 힙메모리"></a>05. 인스턴스, 힙메모리</h4><ul>
<li>인스턴스<br>클래스로부터 생성된 객체<br>힙 메모리에 멤버 변수의 크기에 따라 메모리가 생성<br>new 키워드를 이용하여 여러 개의 인스턴스를 생성<br>가비지 콜렉터 스레드에 의해 반환됨(프로그래머가 직접 free하지 않아도 된다.)<br>참조 변수 : 생성된 인스턴스를 가리키는 변수<br>참조 값 : 생성된 인스턴스의 메모리 주소 값</li>
</ul>
<p>멤버변수 사용 : 참조변수.멤버변수<br>메서드 사용 : 참조변수.메서드();    </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package classpart;</span><br><span class="line"></span><br><span class="line">public class StudentTest &#123; &#x2F;&#x2F;객체를 사용하는 건 다른 클래스인 경우가 대부분이다.</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Student studentLee &#x3D; new Student(); &#x2F;&#x2F;인스턴스 생성</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;참조 변수 사용 studentLee</span><br><span class="line">        studentLee.studentName &#x3D; &quot;이순신&quot;;  &#x2F;&#x2F;생성된 인스턴스(객체)의 멤버 변수를 사용할 수 있다.</span><br><span class="line">        studentLee.address &#x3D; &quot;서울&quot;;</span><br><span class="line"></span><br><span class="line">        studentLee.showStudentInfo(); &#x2F;&#x2F;생성된 인스턴스(객체)의 메서드를 사용할 수 있다.</span><br><span class="line"></span><br><span class="line">        Student studentKim &#x3D; new Student(); &#x2F;&#x2F;new 키워드를 통해 인스턴스 생성</span><br><span class="line">                                            &#x2F;&#x2F;생성 될 때 Student class의 멤버 변수 만큼 Heap 메모리 생성</span><br><span class="line">        studentKim.studentName&#x3D;&quot;김유신&quot;;</span><br><span class="line">        studentKim.address&#x3D;&quot;경주&quot;;</span><br><span class="line"></span><br><span class="line">        studentKim.showStudentInfo();</span><br><span class="line"></span><br><span class="line">        System.out.println(studentLee); &#x2F;&#x2F;참조 변수 출력&gt;참조 값 classpart.Student@60f82f98 package.class@heap memory address</span><br><span class="line">        System.out.println(studentKim);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Study</category>
        <category>JAVA OOP</category>
      </categories>
  </entry>
  <entry>
    <title>07. 생성자, 생성자 오버로딩</title>
    <url>/2020/08/12/hexo_OOP_07/</url>
    <content><![CDATA[<h1 id="객체-지향-프로그래밍"><a href="#객체-지향-프로그래밍" class="headerlink" title="객체 지향 프로그래밍"></a>객체 지향 프로그래밍</h1><h4 id="07-생성자-생성자-오버로딩"><a href="#07-생성자-생성자-오버로딩" class="headerlink" title="07. 생성자, 생성자 오버로딩"></a>07. 생성자, 생성자 오버로딩</h4><ul>
<li>생성자<br>객체를 생성할 때 new 키워드와 함께 호출 (객체 생성때만 호출)<br>인스턴스를 초기화 하는 코드가 구현 됨 (주로 멤버 변수 초기화)<br>반환 값이 없음, 상속되지 않음<br>생성자는 클래스 이름과 동일     </li>
</ul>
<p>기본 생성자 (디폴트 생성자)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public Student() &#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>클래스에 생성자를 구현하지 않은 경우 프리 컴파일 단계에서 컴파일러가 넣어줌.<br>매개 변수가 없고 구현부가 없다.<br>만약 클래스에 다른 생성자가 있는 경우 기본 생성자는 제공되지 않는다.     </p>
<p>생성자 구현</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public Student(int id, String name) &#123;</span><br><span class="line">    &#x2F;&#x2F;body &#x3D; 구현부</span><br><span class="line">    studentId &#x3D; id;</span><br><span class="line">    studentName &#x3D; name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>위의 생성자는 인스턴스 생성과 동시에 초기화</p>
<p>사용할 때는 아래와 같이 매개 변수 입력  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package classpart;</span><br><span class="line"></span><br><span class="line">public class StudentTest &#123; &#x2F;&#x2F;객체를 사용하는 건 다른 클래스인 경우가 대부분이다.</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Student studentLee &#x3D; new Student(&quot;이순신&quot;);</span><br><span class="line">        studentLee.address &#x3D; &quot;서울&quot;;</span><br><span class="line"></span><br><span class="line">        studentLee.showStudentInfo(); </span><br><span class="line"></span><br><span class="line">        Student studentKim &#x3D; new Student(101,&quot;김유신&quot;); </span><br><span class="line"></span><br><span class="line">        studentKim.showStudentInfo();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>오버로딩<br>이름이 같지만 다른 매개 변수를 가지는 생성자 또는 메서드를 사용할 수 있다.<br>사용자는 여러 생성자 중 선택하여 사용할 수 있음<br>private 변수도 생성자를 이용하여 초기화 할 수 있음    </li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public Student(String name) &#123;</span><br><span class="line">    studentName &#x3D; name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Student(int id, String name) &#123;</span><br><span class="line">    studentId &#x3D; id;</span><br><span class="line">    studentName &#x3D; name;</span><br><span class="line">    address &#x3D; &quot;주소 없음&quot;;</span><br></pre></td></tr></table></figure>

<ul>
<li>private<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private int name;</span><br></pre></td></tr></table></figure>
위의 멤버 변수는 클래스 외부에서 참조할 수 없다.<br>생성자를 구현하여 초기화 할 수는 있다.  </li>
</ul>
]]></content>
      <categories>
        <category>Study</category>
        <category>JAVA OOP</category>
      </categories>
  </entry>
  <entry>
    <title>08. 참조 자료형</title>
    <url>/2020/08/12/hexo_OOP_08/</url>
    <content><![CDATA[<h1 id="객체-지향-프로그래밍"><a href="#객체-지향-프로그래밍" class="headerlink" title="객체 지향 프로그래밍"></a>객체 지향 프로그래밍</h1><h4 id="08-참조-자료형"><a href="#08-참조-자료형" class="headerlink" title="08. 참조 자료형"></a>08. 참조 자료형</h4><ul>
<li>기본 자료형<br>int, long, float, double, …</li>
<li>참조 자료형<br>String, Date, Student, …  </li>
</ul>
<p>참조 자료형 직접 생성하기</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package reference;</span><br><span class="line"></span><br><span class="line">public class Subject &#123; &#x2F;&#x2F;과목 class 생성</span><br><span class="line"></span><br><span class="line">    String subjectName;</span><br><span class="line">    int score;</span><br><span class="line">    int subjectID;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package reference;</span><br><span class="line"></span><br><span class="line">public class Student &#123;</span><br><span class="line"></span><br><span class="line">    int studentID;</span><br><span class="line">    String studentName;</span><br><span class="line"></span><br><span class="line">    Subject korea; &#x2F;&#x2F;과목 type(참조 자료형)으로 변수 선언</span><br><span class="line">    Subject math;</span><br><span class="line"></span><br><span class="line">    public Student(int id, String name) &#123;</span><br><span class="line">        studentID &#x3D; id;</span><br><span class="line">        studentName &#x3D; name;</span><br><span class="line"></span><br><span class="line">        korea &#x3D; new Subject(); &#x2F;&#x2F;생성 단계가 필요하다</span><br><span class="line">        math &#x3D; new Subject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setKoreaSubject(String name,int score) &#123;</span><br><span class="line">        korea.subjectName &#x3D; name; &#x2F;&#x2F;과목 class의 속성 참조</span><br><span class="line">        korea.score &#x3D; score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setMathSubject(String name,int score) &#123;</span><br><span class="line">        math.subjectName &#x3D; name;</span><br><span class="line">        math.score &#x3D; score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void showStudentScore() &#123;</span><br><span class="line">        int total &#x3D; korea.score + math.score;</span><br><span class="line">        System.out.println(studentName+&quot;의 총점은 &quot;+total+&quot;점 입니다.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>String과는 다르게    </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">korea &#x3D; new Subject();</span><br></pre></td></tr></table></figure>
<p>처럼 생성 단계가 필요한데, 보통 생성자에 넣어둔다.   </p>
<p>실행</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package reference;</span><br><span class="line"></span><br><span class="line">public class StudentTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        Student studentLee &#x3D; new Student(101,&quot;Lee&quot;);</span><br><span class="line"></span><br><span class="line">        studentLee.setKoreaSubject(&quot;국어&quot;,100);</span><br><span class="line">        studentLee.setMathSubject(&quot;수학&quot;,95);</span><br><span class="line"></span><br><span class="line">        Student studentKim &#x3D; new Student(102,&quot;Kim&quot;);</span><br><span class="line"></span><br><span class="line">        studentKim.setKoreaSubject(&quot;국어&quot;,80);</span><br><span class="line">        studentKim.setMathSubject(&quot;수학&quot;,99);</span><br><span class="line"></span><br><span class="line">        studentLee.showStudentScore();</span><br><span class="line">        studentKim.showStudentScore();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Study</category>
        <category>JAVA OOP</category>
      </categories>
  </entry>
  <entry>
    <title>09. 정보 은닉</title>
    <url>/2020/08/12/hexo_OOP_09/</url>
    <content><![CDATA[<h1 id="객체-지향-프로그래밍"><a href="#객체-지향-프로그래밍" class="headerlink" title="객체 지향 프로그래밍"></a>객체 지향 프로그래밍</h1><h4 id="09-정보-은닉"><a href="#09-정보-은닉" class="headerlink" title="09. 정보 은닉"></a>09. 정보 은닉</h4><ul>
<li><p>접근 제어자 : 변수, 메서드, 생성자에 대한 접근 권한 지정<br>public : 완전 공개<br>private : 해당 클래스 내에서만 공개<br>protected : 상위 클래스의 private변수를 하위 클래스에서 public으로 쓰고 싶을 때<br>default : 같은 패키지 내에서만 공개    </p>
<ul>
<li>정보은닉<br>클래스 내부의 정보에 접근하지 못하도록 함<br>(private 접근 제어자를 통한 정보 은닉)<br>private를 외부에서 접근하게 하려면 public 메서드 제공</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package hiding;</span><br><span class="line"></span><br><span class="line">public class MyDate &#123;</span><br><span class="line"></span><br><span class="line">    private int day;</span><br><span class="line">    private int month;</span><br><span class="line">    private int year;</span><br><span class="line"></span><br><span class="line">    private boolean isValid&#x3D;true; &#x2F;&#x2F;멤버 변수 boolean은 선언과 동시에 false로 대입된다.</span><br><span class="line"></span><br><span class="line">    public void setDay(int day) &#123; &#x2F;&#x2F;private 멤버 변수의 외부 입력을 위한 public 메서드 제공</span><br><span class="line">        if (day&lt;0 || day&gt;31) &#123;    &#x2F;&#x2F;잘못된 사용 방지</span><br><span class="line">            isValid &#x3D; false;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            this.day &#x3D; day;       &#x2F;&#x2F;멤버 변수와 매개 변수의 이름이 같은 경우 this.멤버변수</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setMonth(int month) &#123;</span><br><span class="line">        if (month&lt;0 || month&gt;12) &#123;</span><br><span class="line">            isValid &#x3D; false;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            this.month &#x3D; month;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setYear(int year) &#123;</span><br><span class="line">        if (year&lt;0) &#123;</span><br><span class="line">            isValid &#x3D; false;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            this.year &#x3D; year;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getDay() &#123; &#x2F;&#x2F;private 멤버 변수의 외부 참조를 위한 public 메서드 제공</span><br><span class="line">        return day;</span><br><span class="line">    &#125;</span><br><span class="line">    public int getMonth() &#123; </span><br><span class="line">        return month;</span><br><span class="line">    &#125;</span><br><span class="line">    public int getYear() &#123; </span><br><span class="line">        return year;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void showDate() &#123;</span><br><span class="line"></span><br><span class="line">        if (isValid) &#123; &#x2F;&#x2F;잘못된 사용 검</span><br><span class="line">            System.out.println(year+&quot;년 &quot;+month+&quot;월 &quot;+day+&quot;일 &quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;유효하지 않은 날짜 입니다.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>보통 위와 같은 public 메서드의 이름을 set get으로 시작하여 생성하지만,<br>다른 이름으로 생성도 가능하다.</p>
<p>외부 접근</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package hiding;</span><br><span class="line"></span><br><span class="line">public class MyDateTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        MyDate date &#x3D; new MyDate();</span><br><span class="line"></span><br><span class="line">        date.setDay(10);</span><br><span class="line">        date.setMonth(7);</span><br><span class="line">        date.setYear(2019);</span><br><span class="line"></span><br><span class="line">        date.showDate();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Study</category>
        <category>JAVA OOP</category>
      </categories>
  </entry>
  <entry>
    <title>11. this에 대하여</title>
    <url>/2020/08/12/hexo_OOP_11/</url>
    <content><![CDATA[<h1 id="객체-지향-프로그래밍"><a href="#객체-지향-프로그래밍" class="headerlink" title="객체 지향 프로그래밍"></a>객체 지향 프로그래밍</h1><h4 id="11-this에-대하여"><a href="#11-this에-대하여" class="headerlink" title="11. this에 대하여"></a>11. this에 대하여</h4><ul>
<li>this의 역할  </li>
</ul>
<p>자신의 메모리를 가리킴    </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    BirthDay day &#x3D; new BirthDay();</span><br><span class="line">    day.setYear(2000); &#x2F;&#x2F;setYear 메서드에 this가 있을때 생성된 인스턴스(day)의 메모리</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>생성자에서 다른 생성자를 호출 함  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public Person() &#123;</span><br><span class="line">    &#x2F;&#x2F;age &#x3D; 10;     &#x2F;&#x2F;this로 다른 생성자를 호출할때 그위에 다른 statement는 올 수 없다.</span><br><span class="line">    this(&quot;이름 없음&quot;,1);  &#x2F;&#x2F;아래의 생성자 호출하여 변수 초기화</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Person(String name,int age) &#123;</span><br><span class="line">    this.name &#x3D; name;</span><br><span class="line">    this.age &#x3D; age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>인스턴스 자신의 주소를 반환     </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public Person getSelf() &#123; &#x2F;&#x2F;반환 타입은 자기 클래스 자신</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Person personLee &#x3D; new Person(&quot;Lee&quot;,20);</span><br><span class="line">System.out.println(personLee);</span><br><span class="line">&#x2F;&#x2F;위와 아래는 같은 결과 (인스턴스의 메모리 주소)</span><br><span class="line">Person p &#x3D; personLee.getSelf();</span><br><span class="line">System.out.println(p);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Study</category>
        <category>JAVA OOP</category>
      </categories>
  </entry>
  <entry>
    <title>12. 객체 간 협력</title>
    <url>/2020/08/12/hexo_OOP_12/</url>
    <content><![CDATA[<h1 id="객체-지향-프로그래밍"><a href="#객체-지향-프로그래밍" class="headerlink" title="객체 지향 프로그래밍"></a>객체 지향 프로그래밍</h1><h4 id="12-객체-간-협력"><a href="#12-객체-간-협력" class="headerlink" title="12. 객체 간 협력"></a>12. 객체 간 협력</h4><p>객체 지향 프로그램은 객체를 정의 하고 객체 간의 ‘협력’을 구현한 프로그램     </p>
<p>학생, 버스, 지하철 객체 간 협력 프로그램</p>
<ul>
<li><p>학생</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package cooperation;</span><br><span class="line"></span><br><span class="line">public class Student &#123;</span><br><span class="line"></span><br><span class="line">    String studentName;</span><br><span class="line">    int grade;</span><br><span class="line">    int money;</span><br><span class="line"></span><br><span class="line">    public Student(String studentName,int money) &#123;</span><br><span class="line"></span><br><span class="line">        this.studentName &#x3D; studentName;</span><br><span class="line">        this.money &#x3D; money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void takeBus(Bus bus) &#123;  &#x2F;&#x2F;버스 객체와의 협업</span><br><span class="line">        bus.take(1000);</span><br><span class="line">        this.money -&#x3D; 1000;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void takeSubway(Subway subway) &#123;  &#x2F;&#x2F;지하철 객체와의 협업</span><br><span class="line">        subway.take(1200);</span><br><span class="line">        this.money -&#x3D; 1200;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void showInfo() &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(studentName+&quot;님의 남은 돈은 &quot;+money+&quot;원 입니다.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>버스</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package cooperation;</span><br><span class="line"></span><br><span class="line">public class Bus &#123;</span><br><span class="line"></span><br><span class="line">    int busNumber;</span><br><span class="line">    int passengerCount;</span><br><span class="line">    int money;</span><br><span class="line"></span><br><span class="line">    public Bus(int busNumber) &#123;</span><br><span class="line">        this.busNumber &#x3D; busNumber;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void take(int money) &#123; &#x2F;&#x2F;승차 메서드</span><br><span class="line">        this.money +&#x3D; money;</span><br><span class="line">        this.passengerCount++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void showBusInfo() &#123;</span><br><span class="line">        System.out.println(busNumber+&quot;번 버스의 승객은 &quot;+passengerCount+&quot;명 이고, 수입은 &quot;+money+&quot;원 입니다.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>지하철</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package cooperation;</span><br><span class="line"></span><br><span class="line">public class Subway &#123;</span><br><span class="line"></span><br><span class="line">    int lineNumber;</span><br><span class="line">    int passengerCount;</span><br><span class="line">    int money;</span><br><span class="line"></span><br><span class="line">    public Subway(int lineNumber) &#123;</span><br><span class="line">        this.lineNumber &#x3D; lineNumber;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void take(int money) &#123;</span><br><span class="line">        this.money +&#x3D; money;</span><br><span class="line">        this.passengerCount++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void showBusInfo() &#123;</span><br><span class="line">        System.out.println(lineNumber+&quot;번 버스의 승객은 &quot;+passengerCount+&quot;명 이고, 수입은 &quot;+money+&quot;원 입니다.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
]]></content>
      <categories>
        <category>Study</category>
        <category>JAVA OOP</category>
      </categories>
  </entry>
  <entry>
    <title>14. static 변수, 메서드</title>
    <url>/2020/08/12/hexo_OOP_14/</url>
    <content><![CDATA[<h1 id="객체-지향-프로그래밍"><a href="#객체-지향-프로그래밍" class="headerlink" title="객체 지향 프로그래밍"></a>객체 지향 프로그래밍</h1><h4 id="14-static-변수-메서드"><a href="#14-static-변수-메서드" class="headerlink" title="14. static 변수, 메서드"></a>14. static 변수, 메서드</h4><p>여러 인스턴스가 같은 변수 및 메서드를 공유해야할 필요가 있을때   </p>
<ul>
<li><p>static 변수</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private static int serialNum &#x3D; 1000;</span><br></pre></td></tr></table></figure>
<p>처음 프로그램이 로드될 때 데이터 영역에 생성됨<br>클래스 이름으로 참조     </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Student.serialNum &#x3D; 100;</span><br></pre></td></tr></table></figure>
</li>
<li><p>static 메서드<br>static 변수를 위한 기능을 제공하는 메서드<br>인스턴스 변수를 사용할 수 없음   </p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static int getSerialNum() &#123;   &#x2F;&#x2F;static 메서드</span><br><span class="line">    int i &#x3D; 0;   &#x2F;&#x2F; 지역변수 사용가능</span><br><span class="line">    &#x2F;&#x2F;studentName &#x3D; &quot;Lee&quot;; &#x2F;&#x2F;인스턴스 변수 사용할 수 없음</span><br><span class="line">    return serialNum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>클래스 이름으로 참조</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">System.out.println(Student.getSerialNum());</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package staticex;</span><br><span class="line"></span><br><span class="line">public class Student &#123;</span><br><span class="line"></span><br><span class="line">    private static int serialNum &#x3D; 1000; &#x2F;&#x2F;인스턴스 들이 공유함. 그렇기 때문에 외부에서 변경을 피하기 위하여 보통 private로 만</span><br><span class="line">    private int studentId;</span><br><span class="line">    public String studentName;</span><br><span class="line">    public String address;</span><br><span class="line"></span><br><span class="line">    public Student(String name) &#123;</span><br><span class="line">        studentName &#x3D; name;</span><br><span class="line">        serialNum++;   &#x2F;&#x2F;객체 생성시 static 변수 증가하도록</span><br><span class="line">        studentId &#x3D; serialNum;    &#x2F;&#x2F;증가된 serialNum을 학번으로</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getStudentId() &#123;</span><br><span class="line">        return studentId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void showStudentInfo() &#123;</span><br><span class="line">        System.out.println(studentName+&quot;,&quot;+address);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static int getSerialNum() &#123;   &#x2F;&#x2F;static 메서드</span><br><span class="line">        int i &#x3D; 0;   &#x2F;&#x2F; 지역변수 사용가능</span><br><span class="line">        &#x2F;&#x2F;studentName &#x3D; &quot;Lee&quot;; &#x2F;&#x2F;인스턴스 변수 사용할 수 없음</span><br><span class="line">        return serialNum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void setSerialNum(int serialNum) &#123;</span><br><span class="line">        Student.serialNum &#x3D; serialNum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package staticex;</span><br><span class="line"></span><br><span class="line">public class StudentTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        Student studentLee &#x3D; new Student(&quot;Lee&quot;);</span><br><span class="line">        System.out.println(Student.getSerialNum());</span><br><span class="line">        Student studentKim &#x3D; new Student(&quot;Kim&quot;);</span><br><span class="line"></span><br><span class="line">        System.out.println(Student.getSerialNum());</span><br><span class="line"></span><br><span class="line">        System.out.println(studentLee.getStudentId());</span><br><span class="line">        System.out.println(studentKim.getStudentId());</span><br><span class="line"></span><br><span class="line">        System.out.println(Student.getSerialNum());&#x2F;&#x2F;실제 static 변수 또는 메서드 사용은 이것 처럼 참조 변수가 아닌 클래스 이름에서 참조</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Study</category>
        <category>JAVA OOP</category>
      </categories>
  </entry>
  <entry>
    <title>15. static 응용</title>
    <url>/2020/08/12/hexo_OOP_15/</url>
    <content><![CDATA[<h1 id="객체-지향-프로그래밍"><a href="#객체-지향-프로그래밍" class="headerlink" title="객체 지향 프로그래밍"></a>객체 지향 프로그래밍</h1><h4 id="15-static-응용"><a href="#15-static-응용" class="headerlink" title="15. static 응용"></a>15. static 응용</h4><ul>
<li>singleton pattern<br>단 하나만 존재하는 인스턴스 (ex 학교 객체)<br>생성자는 private로 생성<br>클래스 내에서 static으로 유일한 객체 생성<br>외부에서 유일한 객체를 참조할 수 있는 public static get() 메서드 구현    </li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package staticex;</span><br><span class="line"></span><br><span class="line">public class Company &#123;</span><br><span class="line"></span><br><span class="line">    private static Company instance &#x3D; new Company(); &#x2F;&#x2F;내부적으로 인스턴스 생성</span><br><span class="line"></span><br><span class="line">    private Company() &#123; &#x2F;&#x2F;생성자 private로 생성</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Company getInstance() &#123;  &#x2F;&#x2F;외부에서 인스턴스 생성과 무관하게 사용하기 위해 static으로 생성</span><br><span class="line">        if (instance&#x3D;&#x3D;null) &#123;</span><br><span class="line">            instance &#x3D; new Company();</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package staticex;</span><br><span class="line"></span><br><span class="line">import java.util.Calendar;</span><br><span class="line"></span><br><span class="line">public class CompanyTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;Company company &#x3D; new Company(); &#x2F;&#x2F;private 생성자 이므로 인스턴스 생성할 수 없음</span><br><span class="line">        Company company1&#x3D;Company.getInstance();</span><br><span class="line">        Company company2&#x3D;Company.getInstance();</span><br><span class="line"></span><br><span class="line">        System.out.println(company1);</span><br><span class="line">        System.out.println(company2); &#x2F;&#x2F;두 인스턴스의 메모리 주소가 동일하다</span><br><span class="line"></span><br><span class="line">        Calendar calendar &#x3D; Calendar.getInstance(); &#x2F;&#x2F;Calendar 클래스는 싱글톤 패턴으로 구현되어 있다.</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Study</category>
        <category>JAVA OOP</category>
      </categories>
  </entry>
  <entry>
    <title>17. 배열</title>
    <url>/2020/08/12/hexo_OOP_17/</url>
    <content><![CDATA[<h1 id="객체-지향-프로그래밍"><a href="#객체-지향-프로그래밍" class="headerlink" title="객체 지향 프로그래밍"></a>객체 지향 프로그래밍</h1><h4 id="17-배열"><a href="#17-배열" class="headerlink" title="17. 배열"></a>17. 배열</h4><ul>
<li>배열이란<br>동일한 자료형의 순차적 자료 구조<br>ex) 학생 100명에 대한 학번 변수</li>
</ul>
<p>배열 선언</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int[] arr &#x3D; new int[10]; &#x2F;&#x2F;int 10개 &#x3D; 40byte length&#x3D;10, 0~9</span><br><span class="line">int arr[] &#x3D; new int[10];</span><br></pre></td></tr></table></figure>
<p>배열은 fixed length이기 때문에<br>만약 배열의 길이를 늘리고 싶다면,<br>더 긴 배열을 선언한 뒤 값을 복사해야 한다.   </p>
<p>배열은 연속적이어야 한다.  (중간에 비어있으면 안된다.)<br>데이터가 들어가거나 빠질때 추가적인 작업이 필요하다.   </p>
<p>배열을 사용하는 가장 큰 이유 : 인덱스 연산자  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">arr[4] &#x2F;&#x2F;추출이 편하고 속도가 빠름</span><br></pre></td></tr></table></figure>

<p>ArrayList를 쓰면 편하게 배열을 사용할 수 있다.     </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package array;</span><br><span class="line"></span><br><span class="line">public class ArrayTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        int[] arr &#x3D; new int[10]; &#x2F;&#x2F;기본자료형 Array</span><br><span class="line">        &#x2F;&#x2F;int[] arr &#x3D; new int[] &#123;1,2,3&#125;; &#x2F;&#x2F;선언과 동시에 초기화 가능</span><br><span class="line">        &#x2F;&#x2F;int[] arr &#x3D; &#123;1,2,3&#125;; &#x2F;&#x2F;위와 동일</span><br><span class="line">        int total &#x3D; 0;</span><br><span class="line"></span><br><span class="line">        for (int i&#x3D;0;i&lt;arr.length;i++) &#123;</span><br><span class="line">            System.out.println(arr[i]); &#x2F;&#x2F;0으로 10개가 초기화되어 있음</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i&#x3D;0,num&#x3D;1;i&lt;arr.length;i++,num++) &#123; &#x2F;&#x2F;배열 arr의 모든 요소를 1씩 증가하도록 변경</span><br><span class="line">            arr[i]&#x3D;num;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i&#x3D;0;i&lt;arr.length;i++) &#123;</span><br><span class="line">            System.out.println(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i&#x3D;0;i&lt;arr.length;i++) &#123; &#x2F;&#x2F;배열 요소 합 구하기</span><br><span class="line">            total +&#x3D; arr[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(total);</span><br><span class="line"></span><br><span class="line">        double[] dArr &#x3D; new double[5];</span><br><span class="line">        int count &#x3D; 0;</span><br><span class="line">        dArr[0] &#x3D; 1.1; count++;</span><br><span class="line">        dArr[1] &#x3D; 2.1; count++;</span><br><span class="line">        dArr[2] &#x3D; 3.1; count++;</span><br><span class="line"></span><br><span class="line">        double mtotal &#x3D; 1;</span><br><span class="line">        for (int i&#x3D;0;i&lt;count;i++) &#123; &#x2F;&#x2F;count를 통해 직접 초기화 한 값만 곱</span><br><span class="line">            mtotal *&#x3D; dArr[i];</span><br><span class="line">            System.out.println(dArr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(mtotal);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Study</category>
        <category>JAVA OOP</category>
      </categories>
  </entry>
  <entry>
    <title>19. 객체 배열</title>
    <url>/2020/08/12/hexo_OOP_19/</url>
    <content><![CDATA[<h1 id="객체-지향-프로그래밍"><a href="#객체-지향-프로그래밍" class="headerlink" title="객체 지향 프로그래밍"></a>객체 지향 프로그래밍</h1><h4 id="19-객체-배열"><a href="#19-객체-배열" class="headerlink" title="19. 객체 배열"></a>19. 객체 배열</h4><ul>
<li>객체 배열 (참조 자료형 배열)     <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Book[] library &#x3D; new Book[5]; &#x2F;&#x2F;null이 초기화됨</span><br><span class="line">                              &#x2F;&#x2F;실제로는 객체의 주소가 들어가게 된다</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>배열로 만 클래스 생성    </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package array;</span><br><span class="line"></span><br><span class="line">public class Book &#123;</span><br><span class="line"></span><br><span class="line">    private String title;</span><br><span class="line">    private String author;</span><br><span class="line"></span><br><span class="line">    public Book() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Book(String title, String author) &#123;</span><br><span class="line">        this.title &#x3D; title;</span><br><span class="line">        this.author &#x3D; author;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getTitle() &#123;</span><br><span class="line">        return title;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setTitle(String title) &#123;</span><br><span class="line">        this.title &#x3D; title;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getAuthor() &#123;</span><br><span class="line">        return author;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAuthor(String author) &#123;</span><br><span class="line">        this.author &#x3D; author;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void showBookInfo() &#123;</span><br><span class="line">        System.out.println(title+&quot;,&quot;+author);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>객체 배열 생성 및 인스턴스 생성  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package array;</span><br><span class="line"></span><br><span class="line">public class BookArrayTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        Book[] library &#x3D; new Book[5]; &#x2F;&#x2F;객체 배열이 생긴 거지 객체 5개가 생긴건 아님</span><br><span class="line"></span><br><span class="line">        &#x2F;*for (int i&#x3D;0; i&lt;library.length; i++) &#123; &#x2F;&#x2F;인스턴스 생성1</span><br><span class="line">            library[i] &#x3D; new Book();</span><br><span class="line">        &#125;*&#x2F;</span><br><span class="line"></span><br><span class="line">        library[0] &#x3D; new Book(&quot;태백산맥1&quot;,&quot;조정래&quot;); &#x2F;&#x2F;인스턴스 생성2</span><br><span class="line">        library[1] &#x3D; new Book(&quot;태백산맥2&quot;,&quot;조정래&quot;);</span><br><span class="line">        library[2] &#x3D; new Book(&quot;태백산맥3&quot;,&quot;조정래&quot;);</span><br><span class="line">        library[3] &#x3D; new Book(&quot;태백산맥4&quot;,&quot;조정래&quot;);</span><br><span class="line">        library[4] &#x3D; new Book(&quot;태백산맥5&quot;,&quot;조정래&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        for (int i&#x3D;0; i&lt;library.length; i++) &#123;</span><br><span class="line">            System.out.println(library[i]); &#x2F;&#x2F;각 인스턴스의 메모리 주소 출력 32bit x 5</span><br><span class="line">            library[i].showBookInfo();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>기본 자료형 배열 복사</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package array;</span><br><span class="line"></span><br><span class="line">public class ArrayCopy &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        int[] arr1 &#x3D; &#123;10,20,30,40,50&#125;;</span><br><span class="line">        int[] arr2 &#x3D; &#123;1,2,3,4,5&#125;;</span><br><span class="line"></span><br><span class="line">        System.arraycopy(arr1,0,arr2,1,3); &#x2F;&#x2F;배열을 복사할때 사용하는 메서드</span><br><span class="line">                        &#x2F;&#x2F;소스,어디부터,타겟,어디부터,몇개</span><br><span class="line"></span><br><span class="line">        for (int i&#x3D;0; i&lt;arr2.length; i++) &#123;</span><br><span class="line">            System.out.println(arr2[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>객체 배열 복사</p>
</li>
</ul>
<p>얕은 복사   </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package array;</span><br><span class="line"></span><br><span class="line">public class ObjectCopy &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        Book[] library &#x3D; new Book[5];</span><br><span class="line">        Book[] copylibrary &#x3D; new Book[5];</span><br><span class="line"></span><br><span class="line">        library[0] &#x3D; new Book(&quot;태백산맥1&quot;,&quot;조정래&quot;);</span><br><span class="line">        library[1] &#x3D; new Book(&quot;태백산맥2&quot;,&quot;조정래&quot;);</span><br><span class="line">        library[2] &#x3D; new Book(&quot;태백산맥3&quot;,&quot;조정래&quot;);</span><br><span class="line">        library[3] &#x3D; new Book(&quot;태백산맥4&quot;,&quot;조정래&quot;);</span><br><span class="line">        library[4] &#x3D; new Book(&quot;태백산맥5&quot;,&quot;조정래&quot;);</span><br><span class="line"></span><br><span class="line">        System.arraycopy(library,0,copylibrary,0,5); &#x2F;&#x2F;기본자료형과 동일하게 사용하면 얕은 복사 (인스턴스 추가 생성 x)</span><br><span class="line"></span><br><span class="line">        &#x2F;*for (int i&#x3D;0; i&lt;copylibrary.length; i++) &#123;</span><br><span class="line">            copylibrary[i].showBookInfo();</span><br><span class="line">        &#125;*&#x2F;</span><br><span class="line"></span><br><span class="line">        for ( Book book : copylibrary ) &#123; &#x2F;&#x2F;향상된 for문  for ( 변수 선언 : array ) array의 모든 요소를 var에 순차적으로 입력</span><br><span class="line">            book.showBookInfo();</span><br><span class="line">        &#125;</span><br><span class="line">        library[0].setTitle(&quot;나목&quot;);</span><br><span class="line">        library[0].setAuthor(&quot;박완선&quot;);</span><br><span class="line"></span><br><span class="line">        library[0].showBookInfo();</span><br><span class="line">        copylibrary[0].showBookInfo(); &#x2F;&#x2F;동일하게 변경됨 (주소만 복사된 것이므로 동일한 인스턴스이다.) &#x3D;&#x3D; 얕은 복사</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>깊은 복사   </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package array;</span><br><span class="line"></span><br><span class="line">public class ObjectCopy2 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        Book[] library &#x3D; new Book[5];</span><br><span class="line">        Book[] copylibrary &#x3D; new Book[5];</span><br><span class="line"></span><br><span class="line">        library[0] &#x3D; new Book(&quot;태백산맥1&quot;,&quot;조정래&quot;);</span><br><span class="line">        library[1] &#x3D; new Book(&quot;태백산맥2&quot;,&quot;조정래&quot;);</span><br><span class="line">        library[2] &#x3D; new Book(&quot;태백산맥3&quot;,&quot;조정래&quot;);</span><br><span class="line">        library[3] &#x3D; new Book(&quot;태백산맥4&quot;,&quot;조정래&quot;);</span><br><span class="line">        library[4] &#x3D; new Book(&quot;태백산맥5&quot;,&quot;조정래&quot;);</span><br><span class="line"></span><br><span class="line">        copylibrary[0] &#x3D; new Book(); &#x2F;&#x2F;인스턴스 따 생성</span><br><span class="line">        copylibrary[1] &#x3D; new Book();</span><br><span class="line">        copylibrary[2] &#x3D; new Book();</span><br><span class="line">        copylibrary[3] &#x3D; new Book();</span><br><span class="line">        copylibrary[4] &#x3D; new Book();</span><br><span class="line"></span><br><span class="line">        for (int i&#x3D;0; i&lt;library.length; i++) &#123; &#x2F;&#x2F;깊은 복사</span><br><span class="line">            copylibrary[i].setTitle(library[i].getTitle());</span><br><span class="line">            copylibrary[i].setAuthor(library[i].getAuthor());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for ( Book book : copylibrary ) &#123;</span><br><span class="line">            book.showBookInfo();</span><br><span class="line">        &#125;</span><br><span class="line">        library[0].setTitle(&quot;나목&quot;);</span><br><span class="line">        library[0].setAuthor(&quot;박완선&quot;);</span><br><span class="line"></span><br><span class="line">        library[0].showBookInfo();</span><br><span class="line">        copylibrary[0].showBookInfo(); &#x2F;&#x2F;복사본은 변경되지 않음 (서로 다른 인스턴스) &#x3D;&#x3D; 깊은 복사</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Study</category>
        <category>JAVA OOP</category>
      </categories>
  </entry>
  <entry>
    <title>21. 다차원 배열</title>
    <url>/2020/08/12/hexo_OOP_21/</url>
    <content><![CDATA[<h1 id="객체-지향-프로그래밍"><a href="#객체-지향-프로그래밍" class="headerlink" title="객체 지향 프로그래밍"></a>객체 지향 프로그래밍</h1><h4 id="21-다차원-배열"><a href="#21-다차원-배열" class="headerlink" title="21. 다차원 배열"></a>21. 다차원 배열</h4><ul>
<li>다차원 배열<br>2차원 이상의 배열  </li>
</ul>
<p>2차원 배열  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int[][] arr &#x3D; new int [2][3]; &#x2F;&#x2F;6개 요소</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package array;</span><br><span class="line"></span><br><span class="line">public class TwoDimension &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;int[][] arr &#x3D; new int[2][3];</span><br><span class="line">        int[][] arr &#x3D; &#123;&#123;1,2,3&#125;,&#123;4,5,6,7&#125;&#125;;</span><br><span class="line"></span><br><span class="line">        System.out.println(arr.length); &#x2F;&#x2F;2차원 배열에서 length는 행의 개수</span><br><span class="line">        System.out.println(arr[0].length); &#x2F;&#x2F;0번째 행의 길이</span><br><span class="line">        System.out.println(arr[1].length);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;행을 기준으로 열을 돌린다.(2중 for문)</span><br><span class="line"></span><br><span class="line">        for (int i&#x3D;0; i&lt;arr.length; i++) &#123; &#x2F;&#x2F;행 for문</span><br><span class="line">            for (int j&#x3D;0; j&lt;arr[i].length; j++) &#123; &#x2F;&#x2F;열 for문</span><br><span class="line">                System.out.print(arr[i][j]+&quot; &quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Study</category>
        <category>JAVA OOP</category>
      </categories>
  </entry>
  <entry>
    <title>22. ArrayList 사용하기</title>
    <url>/2020/08/12/hexo_OOP_22/</url>
    <content><![CDATA[<h1 id="객체-지향-프로그래밍"><a href="#객체-지향-프로그래밍" class="headerlink" title="객체 지향 프로그래밍"></a>객체 지향 프로그래밍</h1><h4 id="22-ArrayList-사용하기"><a href="#22-ArrayList-사용하기" class="headerlink" title="22. ArrayList 사용하기"></a>22. ArrayList 사용하기</h4><ul>
<li>ArrayList<br>자바에서 제공하는 객체 배열이 구현된 클래스<br>객체 배열을 사용하는데 필요한 여러 메서드들이 구현되어 있음   </li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package array;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line"></span><br><span class="line">public class ArrayListTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;ArrayList list &#x3D; new ArrayList(); &#x2F;&#x2F;요소 자료형 미지정</span><br><span class="line">        ArrayList&lt;String&gt; list &#x3D; new ArrayList&lt;String&gt;(); &#x2F;&#x2F;요소 자료형 지정</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;몇가지 메서드 가능 테스트</span><br><span class="line">        list.add(&quot;aaa&quot;); &#x2F;&#x2F;add 메서드를 통해 요소 추가</span><br><span class="line">        list.add(&quot;bbb&quot;);</span><br><span class="line">        list.add(&quot;ccc&quot;);</span><br><span class="line"></span><br><span class="line">        for (String str : list) &#123; &#x2F;&#x2F;향상된 for문 사용 가능</span><br><span class="line">            System.out.println(str);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i&#x3D;0;i&lt;list.size();i++) &#123; &#x2F;&#x2F;list의 요소 총 개수는 size</span><br><span class="line">            System.out.println(list.get(i)); &#x2F;&#x2F;get 메서드를 통해 요소 참조</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>연습 (학생의 과목 별 점수 확인)     </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package array;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line"></span><br><span class="line">public class Student &#123;</span><br><span class="line"></span><br><span class="line">    int studentID;</span><br><span class="line">    String studentName;</span><br><span class="line">    ArrayList&lt;Subject&gt; subjectlist; &#x2F;&#x2F;ArrayList 변수 선언</span><br><span class="line"></span><br><span class="line">    public Student(int studentID, String studentName) &#123;</span><br><span class="line">        this.studentID &#x3D; studentID;</span><br><span class="line">        this.studentName &#x3D; studentName;</span><br><span class="line"></span><br><span class="line">        subjectlist &#x3D; new ArrayList&lt;Subject&gt;(); &#x2F;&#x2F;참조형 변수이므로 초기화를 생성자에 넣어주자</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void addSubject(String name, int score) &#123;</span><br><span class="line">        Subject subject &#x3D; new Subject(name,score); &#x2F;&#x2F;배열이 비어있으므로 subject 객체 생성</span><br><span class="line">        subjectlist.add(subject);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void showStudentInfo() &#123;</span><br><span class="line"></span><br><span class="line">        int total&#x3D;0;</span><br><span class="line"></span><br><span class="line">        for ( Subject subject : subjectlist ) &#123;</span><br><span class="line">            total +&#x3D; subject.getScore();</span><br><span class="line">            System.out.println(studentName+&quot;의 &quot;+subject.getName()+&quot;과목 성적은 &quot;+subject.getScore()+&quot;점 입니다.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;총점은 &quot;+total+&quot;점 입니다.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package array;</span><br><span class="line"></span><br><span class="line">public class Subject &#123;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line">    private int score;</span><br><span class="line"></span><br><span class="line">    public Subject(String name, int score) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">        this.score &#x3D; score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getScore() &#123;</span><br><span class="line">        return score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setScore(int score) &#123;</span><br><span class="line">        this.score &#x3D; score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package array;</span><br><span class="line"></span><br><span class="line">public class StudentTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        Student Lee &#x3D; new Student(101,&quot;Lee&quot;);</span><br><span class="line">        Student Kim &#x3D; new Student(102,&quot;Kim&quot;);</span><br><span class="line"></span><br><span class="line">        Lee.addSubject(&quot;국어&quot;,100);</span><br><span class="line">        Lee.addSubject(&quot;수학&quot;,90);</span><br><span class="line">        Kim.addSubject(&quot;국어&quot;,100);</span><br><span class="line">        Kim.addSubject(&quot;수학&quot;,90);</span><br><span class="line">        Kim.addSubject(&quot;영어&quot;,80);</span><br><span class="line"></span><br><span class="line">        Lee.showStudentInfo();</span><br><span class="line">        Kim.showStudentInfo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Study</category>
        <category>JAVA OOP</category>
      </categories>
  </entry>
  <entry>
    <title>25. 상속이란</title>
    <url>/2020/08/12/hexo_OOP_25/</url>
    <content><![CDATA[<h1 id="객체-지향-프로그래밍"><a href="#객체-지향-프로그래밍" class="headerlink" title="객체 지향 프로그래밍"></a>객체 지향 프로그래밍</h1><h4 id="25-상속이란"><a href="#25-상속이란" class="headerlink" title="25. 상속이란"></a>25. 상속이란</h4><p>클래스에서 상속의 의미 :<br>새로운 클래스를 정의할 때 이미 구현된 클래스를 상속받아서<br>속성이나 기능이 확장되는 클래스를 구현 함.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class B extends A &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>상속하는 클래스 : 상위 클래스<br>상속받는 클래스 : 하위 클래스   </p>
<p>자바에서는 다중 상속이 불가능하다.     </p>
<p>상속을 사용하는 경우 :<br>상위클래스는 더 일반적인 개념과 기능을 가짐<br>하위클래스는 더 구체적인 개념과 기능을 가짐    </p>
<p>상위 클래스</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package inheritance;</span><br><span class="line"></span><br><span class="line">public class Customer &#123;</span><br><span class="line"></span><br><span class="line">    protected int customerID; &#x2F;&#x2F; 하위 클래스들이 참조할수 있도록 private가 아닌 protected 사용</span><br><span class="line">    protected String customerName;</span><br><span class="line">    protected String customerGrade;</span><br><span class="line">    int bonusPoint;</span><br><span class="line">    double bonusRatio;</span><br><span class="line"></span><br><span class="line">    public Customer() &#123;</span><br><span class="line">        customerGrade&#x3D;&quot;SILVER&quot;;</span><br><span class="line">        bonusRatio&#x3D;0.01;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int calcPrice(int price) &#123;</span><br><span class="line">        bonusPoint +&#x3D; price*bonusRatio;</span><br><span class="line">        return price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String showCustomerInfo() &#123;</span><br><span class="line">        return customerName+&quot;님의 등금은 &quot;+customerGrade+&quot;이며, 적립된 포인트는 &quot;+bonusPoint+&quot;점 입니다.&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getCustomerID() &#123;</span><br><span class="line">        return customerID;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setCustomerID(int customerID) &#123;</span><br><span class="line">        this.customerID &#x3D; customerID;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getCustomerName() &#123;</span><br><span class="line">        return customerName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setCustomerName(String customerName) &#123;</span><br><span class="line">        this.customerName &#x3D; customerName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getCustomerGrade() &#123;</span><br><span class="line">        return customerGrade;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setCustomerGrade(String customerGrade) &#123;</span><br><span class="line">        this.customerGrade &#x3D; customerGrade;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>하위 클래스</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package inheritance;</span><br><span class="line"></span><br><span class="line">public class VIPCustomer extends Customer&#123; &#x2F;&#x2F;상위 클래스(Customer) 지정</span><br><span class="line"></span><br><span class="line">    double salesRatio;</span><br><span class="line">    private int agentID;</span><br><span class="line"></span><br><span class="line">    public VIPCustomer() &#123;</span><br><span class="line">        customerGrade &#x3D; &quot;VIP&quot;; &#x2F;&#x2F;만약 상위 클래스에서 private인 경우 사용할 수 없음</span><br><span class="line">        bonusRatio &#x3D; 0.05;</span><br><span class="line">        salesRatio &#x3D; 0.1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>사용</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package inheritance;</span><br><span class="line"></span><br><span class="line">public class CustomerTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        Customer Lee &#x3D; new Customer();</span><br><span class="line">        Customer Kim &#x3D; new VIPCustomer();</span><br><span class="line"></span><br><span class="line">        Lee.setCustomerID(10010);</span><br><span class="line">        Lee.setCustomerName(&quot;이순신&quot;);</span><br><span class="line">        Lee.bonusPoint &#x3D; 1000;</span><br><span class="line"></span><br><span class="line">        Kim.setCustomerID(10020);    &#x2F;&#x2F;하위 클래스에서 상위 클래스의 기능 사용</span><br><span class="line">        Kim.setCustomerName(&quot;김유신&quot;);</span><br><span class="line">        Kim.bonusPoint &#x3D; 10000;</span><br><span class="line"></span><br><span class="line">        System.out.println(Lee.showCustomerInfo());</span><br><span class="line">        System.out.println(Kim.showCustomerInfo());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Study</category>
        <category>JAVA OOP</category>
      </categories>
  </entry>
  <entry>
    <title>27. 상속에서 클래스 생성 과정과 형변환</title>
    <url>/2020/08/12/hexo_OOP_27/</url>
    <content><![CDATA[<h1 id="객체-지향-프로그래밍"><a href="#객체-지향-프로그래밍" class="headerlink" title="객체 지향 프로그래밍"></a>객체 지향 프로그래밍</h1><h4 id="27-상속에서-클래스-생성-과정과-형변환"><a href="#27-상속에서-클래스-생성-과정과-형변환" class="headerlink" title="27. 상속에서 클래스 생성 과정과 형변환"></a>27. 상속에서 클래스 생성 과정과 형변환</h4><p>하위 클래스 생성시 항상 상위 클래스가 먼저 생성되어야 한다.     </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package inheritance;</span><br><span class="line"></span><br><span class="line">public class VIPCustomer extends Customer&#123; &#x2F;&#x2F;상위 클래스(Customer) 지정</span><br><span class="line"></span><br><span class="line">    double salesRatio;</span><br><span class="line">    private int agentID;</span><br><span class="line"></span><br><span class="line">    public VIPCustomer() &#123;</span><br><span class="line">        &#x2F;&#x2F;super(); &#x2F;&#x2F;아무런 상위 클래스 생성자 호출 명령이 없으면 pre-compile 단계에서 이 함수가 들어감</span><br><span class="line">                   &#x2F;&#x2F;super : 상위 클래스의 메모리 위치 함수, super() : 상위 클래스의 기본 생성자 호출</span><br><span class="line">        &#x2F;&#x2F;super(0, null); &#x2F;&#x2F;만약 상위 클래스의 기본 생성자가 없으면, 명시적으로 상위 클래스의 생성자를 호출해야 한다.</span><br><span class="line">        customerGrade &#x3D; &quot;VIP&quot;; &#x2F;&#x2F;만약 상위 클래스에서 private인 경우 사용할 수 없음</span><br><span class="line">        bonusRatio &#x3D; 0.05;</span><br><span class="line">        salesRatio &#x3D; 0.1;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;VIPCustomer() 생성자 호출&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;*public VIPCustomer(int customerID, String customerName) &#123;</span><br><span class="line">    &#x2F;&#x2F;만약 상위 클래스의 기본 생성자가 없으면, 명시적으로 상위 클래스의 생성자를 호출해야 한다. 방법2</span><br><span class="line">        super(customerID, customerName);</span><br><span class="line">        customerGrade &#x3D; &quot;VIP&quot;;</span><br><span class="line">        bonusRatio &#x3D; 0.05;</span><br><span class="line">        salesRatio &#x3D; 0.1;</span><br><span class="line">    &#125;*&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>상위 클래스로의 묵시적 형변환 (업캐스팅)<br>상속관계에서 모든 하위 클래스는 상위 클래스로 묵시적 형변환이 된다.<br>(하위 클래스는 상위 클래스의 타입을 내포하고 있다.)<br>그 역은 성립하지 않는다.  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Customer Lee &#x3D; new VIPCustomer();</span><br><span class="line">&#x2F;&#x2F;or</span><br><span class="line">VIPCustomer Lee &#x3D; new VIPCustomer();</span><br></pre></td></tr></table></figure>
둘다 VIPCustomer 인스턴스를 생성하는 코드이지만..<br>위의 코드(업캐스팅 사용한)는 type이 Customer이므로,<br>Customer의 변수/메서드만 접근할 수 있다.<br>다만 VIPCustomer관련 멤버변수 메모리는 힙 영역에 생성되긴 한다.    </li>
</ul>
]]></content>
      <categories>
        <category>Study</category>
        <category>JAVA OOP</category>
      </categories>
  </entry>
  <entry>
    <title>28. 메서드 오버라이딩</title>
    <url>/2020/08/12/hexo_OOP_28/</url>
    <content><![CDATA[<h1 id="객체-지향-프로그래밍"><a href="#객체-지향-프로그래밍" class="headerlink" title="객체 지향 프로그래밍"></a>객체 지향 프로그래밍</h1><h4 id="28-메서드-오버라이딩"><a href="#28-메서드-오버라이딩" class="headerlink" title="28. 메서드 오버라이딩"></a>28. 메서드 오버라이딩</h4><ul>
<li>오버라이딩<br>상위 클래스에 정의된 메서드의 구현 내용이 하위 클래스에서 구현할 내용과 맞지 않는 경우 하위 클래스에서 동일한 이름의 메서드를 재정의할 수 있다.  </li>
</ul>
<p>상위 클래스 Customer</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int calcPrice(int price) &#123;</span><br><span class="line">    bonusPoint +&#x3D; price*bonusRatio;</span><br><span class="line">    return price;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>하위 클래스 VIPCustomer (VIP 할인 추가를 위한 메서드 재정의)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override &#x2F;&#x2F;애노테이션.. 컴파일러에게 특정한 정보를 제공해주는 역할     </span><br><span class="line">          &#x2F;&#x2F;@Override는 오버라이딩 정보 제공  </span><br><span class="line">public int calcPrice(int price) &#123; &#x2F;&#x2F;오버라이딩 소스 메서드와 선언부가 동일해야 한다</span><br><span class="line">    bonusPoint +&#x3D; price*bonusRatio;</span><br><span class="line">    return price - (int)(price*salesRatio);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>만약 객체 상속의 묵시적 형변환(업캐스팅)이 있는 경우에는..</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Customer Lee &#x3D; new VIPCustomer();</span><br><span class="line">Lee.calcPrice(1000);</span><br></pre></td></tr></table></figure>
<p>위의 calcPrice 메서드는 인스턴스의 메서드를 사용한다.<br>즉, VIPCustomer 클래스에서 재정의된 calcPrice 메서드를 사용한다.(가상함수)  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package inheritance;</span><br><span class="line"></span><br><span class="line">public class OverridingTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        VIPCustomer Lee &#x3D; new VIPCustomer();</span><br><span class="line">        Lee.setCustomerID(10010);</span><br><span class="line">        Lee.setCustomerName(&quot;이순신&quot;);</span><br><span class="line">        Lee.bonusPoint &#x3D; 20000;</span><br><span class="line"></span><br><span class="line">        Customer Kim &#x3D; new VIPCustomer(); &#x2F;&#x2F;업캐스팅 </span><br><span class="line">        Kim.setCustomerID(10020);</span><br><span class="line">        Kim.setCustomerName(&quot;김유신&quot;);</span><br><span class="line">        Kim.bonusPoint &#x3D; 10000;</span><br><span class="line"></span><br><span class="line">        System.out.println(Lee.showCustomerInfo());</span><br><span class="line">        System.out.println(Kim.showCustomerInfo());</span><br><span class="line">        System.out.println(Lee.calcPrice(1000)); &#x2F;&#x2F;1000-1000*0.1 &#x3D; 900</span><br><span class="line">        System.out.println(Kim.calcPrice(1000)); &#x2F;&#x2F;1000-1000*0.1 &#x3D; 900 가상 메서드 사용</span><br><span class="line">        &#x2F;&#x2F;동일하게 인스턴스의 메서드를 사용한다.</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Study</category>
        <category>JAVA OOP</category>
      </categories>
  </entry>
  <entry>
    <title>28. 다형성</title>
    <url>/2020/08/12/hexo_OOP_29/</url>
    <content><![CDATA[<h1 id="객체-지향-프로그래밍"><a href="#객체-지향-프로그래밍" class="headerlink" title="객체 지향 프로그래밍"></a>객체 지향 프로그래밍</h1><h4 id="28-다형성"><a href="#28-다형성" class="headerlink" title="28. 다형성"></a>28. 다형성</h4><ul>
<li>다형성 이란<br>하나의 코드가 여러 자료형으로 구현되어 실행되는 것<br>같은 코드에서 여러 실행 결과가 나옴    </li>
</ul>
<p>정보은닉, 상속과 더불어 객체지향 프로그래밍의 가장 큰 특징 중 하나이다.<br>OOP의 유연성, 재활용성, 유지보수성에 기본이 되는 특징이다.     </p>
<ul>
<li>다형성의 장점<br>유사한 클래스가 추가되는 경우의 유지보수에 용이하고<br>각 자료형 마다 다른 메서드를 호출하지 않으므로 코드에서 많은 if문이 사라진다.   </li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package polymorphism;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line"></span><br><span class="line">class Animal &#123;</span><br><span class="line"></span><br><span class="line">    public void move() &#123;</span><br><span class="line">        System.out.println(&quot;동물이 움직입니다.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Human extends Animal &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void move() &#123;</span><br><span class="line">        System.out.println(&quot;사람이 두 발로 걷습니다.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Tiger extends Animal &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void move() &#123;</span><br><span class="line">        System.out.println(&quot;호랑이가 네 발로 뜁니다.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Eagle extends Animal &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void move() &#123;</span><br><span class="line">        System.out.println(&quot;독수리가 하늘을 날아갑니다.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class AnimalTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        Animal hAnimal &#x3D; new Human();</span><br><span class="line">        Animal tAnimal &#x3D; new Tiger();</span><br><span class="line">        Animal eAnimal &#x3D; new Eagle();</span><br><span class="line"></span><br><span class="line">        &#x2F;*AnimalTest test &#x3D; new AnimalTest();</span><br><span class="line">        test.moveAnimal(hAnimal);</span><br><span class="line">        test.moveAnimal(tAnimal);</span><br><span class="line">        test.moveAnimal(eAnimal);*&#x2F;</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;Animal&gt; animalList &#x3D; new ArrayList&lt;Animal&gt;();</span><br><span class="line">        animalList.add(hAnimal);</span><br><span class="line">        animalList.add(tAnimal);</span><br><span class="line">        animalList.add(eAnimal);</span><br><span class="line"></span><br><span class="line">        for(Animal animal : animalList) &#123;</span><br><span class="line">            animal.move(); &#x2F;&#x2F;다형성 </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void moveAnimal(Animal animal) &#123;</span><br><span class="line">        animal.move(); &#x2F;&#x2F;하나의 코드에서 여러 자료형을 구현하여 여러 결과가 나옴. (다형성)</span><br><span class="line">                       &#x2F;&#x2F;매개변수는 Animal이지만 실제 호된 move는 Human, Tiger, Eagle의 메서드. (업캐스팅,오버라이딩)</span><br><span class="line">                       &#x2F;&#x2F;여러 클래스가 Animal이라는 타입 하나로 수행될 수 있음.</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Study</category>
        <category>JAVA OOP</category>
      </categories>
  </entry>
  <entry>
    <title>31. 다운캐스팅과 instanceof</title>
    <url>/2020/08/12/hexo_OOP_31/</url>
    <content><![CDATA[<h1 id="객체-지향-프로그래밍"><a href="#객체-지향-프로그래밍" class="headerlink" title="객체 지향 프로그래밍"></a>객체 지향 프로그래밍</h1><h4 id="31-다운캐스팅과-instanceof"><a href="#31-다운캐스팅과-instanceof" class="headerlink" title="31. 다운캐스팅과 instanceof"></a>31. 다운캐스팅과 instanceof</h4><ul>
<li>다운캐스팅<br>묵시적으로 업캐스팅된 인스턴스가 원래의 자료형(하위 클래스)으로 변환되어야 할 때 사용.<br>다운캐스팅은 명시적으로 이루어진다.    </li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Customer vc &#x3D; new VIPCustomer(); &#x2F;&#x2F;업캐스팅 - 묵시적</span><br><span class="line">VIPCustomer vCustomer &#x3D; (VIPCustomer)vc; &#x2F;&#x2F;다운캐스팅 - 명시적</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package polymorphism;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line"></span><br><span class="line">class Animal &#123;</span><br><span class="line"></span><br><span class="line">    public void move() &#123;</span><br><span class="line">        System.out.println(&quot;동물이 움직입니다.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Human extends Animal &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void move() &#123;</span><br><span class="line">        System.out.println(&quot;사람이 두 발로 걷습니다.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void readBooks() &#123;</span><br><span class="line">        System.out.println(&quot;사람이 책을 읽습니다.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Tiger extends Animal &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void move() &#123;</span><br><span class="line">        System.out.println(&quot;호랑이가 네 발로 뜁니다.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void hunting() &#123;</span><br><span class="line">        System.out.println(&quot;호랑이가 사냥을 합니다.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Eagle extends Animal &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void move() &#123;</span><br><span class="line">        System.out.println(&quot;독수리가 하늘을 날아갑니다.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void flying() &#123;</span><br><span class="line">        System.out.println(&quot;독수리가 날개를 쭉 펴고 멀리 날아갑니다.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class AnimalTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        Animal hAnimal &#x3D; new Human();</span><br><span class="line">        Animal tAnimal &#x3D; new Tiger();</span><br><span class="line">        Animal eAnimal &#x3D; new Eagle();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;Eagle eagle &#x3D; (Eagle)hAnimal; &#x2F;&#x2F;Error발생, Human 인스턴스를 Eagle로 형변환하려고함</span><br><span class="line">                                        &#x2F;&#x2F;다운캐스팅은 새로운 선언type과 캐스팅type만 비교하므로 경고가 없기때문에 이런 문제가 발생할 수 있음.</span><br><span class="line">        &#x2F;*if (hAnimal instanceof Eagle) &#123;    &#x2F;&#x2F;inatanceof는 인스턴스의 타입을 확인하여 true,false 반환</span><br><span class="line">            Eagle eagle &#x3D; (Eagle)hAnimal;  &#x2F;&#x2F;실행되지 않기 때문에 Error 없음.</span><br><span class="line">            eagle.flying();</span><br><span class="line">        &#125; else if (hAnimal instanceof Human) &#123;</span><br><span class="line">            Human human1 &#x3D; (Human)hAnimal;</span><br><span class="line">            human1.readBooks();</span><br><span class="line">        &#125;*&#x2F;</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;Animal&gt; animalList &#x3D; new ArrayList&lt;Animal&gt;();</span><br><span class="line">        animalList.add(hAnimal);</span><br><span class="line">        animalList.add(tAnimal);</span><br><span class="line">        animalList.add(eAnimal);</span><br><span class="line"></span><br><span class="line">        AnimalTest test &#x3D; new AnimalTest();</span><br><span class="line">        test.testDownCasting(animalList);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void testDownCasting(ArrayList&lt;Animal&gt; list) &#123;</span><br><span class="line">        for(int i&#x3D;0; i&lt;list.size(); i++) &#123;  &#x2F;&#x2F;Animal 인스턴스들의 type을 확인한 후 다운캐스팅하는 for문 </span><br><span class="line">           Animal animal &#x3D; list.get(i);</span><br><span class="line"></span><br><span class="line">           if (animal instanceof Human) &#123;</span><br><span class="line">               Human human &#x3D; (Human)animal;</span><br><span class="line">               human.readBooks();</span><br><span class="line">           &#125; else if (animal instanceof Tiger) &#123;</span><br><span class="line">               Tiger tiger &#x3D; (Tiger)animal;</span><br><span class="line">               tiger.hunting();</span><br><span class="line">           &#125; else if (animal instanceof Eagle) &#123;</span><br><span class="line">               Eagle eagle &#x3D; (Eagle)animal;</span><br><span class="line">               eagle.flying();</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               System.out.println(&quot;Error&quot;);</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void moveAnimal(Animal animal) &#123;</span><br><span class="line">        animal.move();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>보통 오버라이딩으로는 도저히 구현되지 않는 경우에 다운캐스팅 사용    </p>
]]></content>
      <categories>
        <category>Study</category>
        <category>JAVA OOP</category>
      </categories>
  </entry>
  <entry>
    <title>33. 추상 클래스란?</title>
    <url>/2020/08/12/hexo_OOP_33/</url>
    <content><![CDATA[<h1 id="객체-지향-프로그래밍"><a href="#객체-지향-프로그래밍" class="headerlink" title="객체 지향 프로그래밍"></a>객체 지향 프로그래밍</h1><h4 id="33-추상-클래스란"><a href="#33-추상-클래스란" class="headerlink" title="33. 추상 클래스란?"></a>33. 추상 클래스란?</h4><ul>
<li>추상 클래스<br>추상 메서드를 포함한 클래스<br>추상 메서드 : 구현코드 없이 선언부만 있는 메서드<br>abstract 예약어 사용<br>new(인스턴스화) 할 수 없음   </li>
</ul>
<p>추상 클래스는 상속의 상위 클래스로 사용된다.<br>추상 클래스의 추상 메서드는 하위 클래스가 구현해야 한다. </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package abstractex;</span><br><span class="line"></span><br><span class="line">public abstract class Computer &#123; &#x2F;&#x2F;추상 메서드가 있으면 클래스는 항상 추상 클래스이다.</span><br><span class="line"></span><br><span class="line">    public abstract void display(); &#x2F;&#x2F;이 메서드는 구현하지 않겠다는 의미드 (추상 메서드)</span><br><span class="line">    public abstract void typing();  &#x2F;&#x2F;추상 메서드들은 하위 클래스에서 구현된다.</span><br><span class="line"></span><br><span class="line">    public void turnOn() &#123;</span><br><span class="line">        System.out.println(&quot;전원을 켭니다.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void turnOff() &#123;</span><br><span class="line">        System.out.println(&quot;전원을 끕니다.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package abstractex;</span><br><span class="line"></span><br><span class="line">public class Desktop extends Computer &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void display() &#123; &#x2F;&#x2F;상위 클래스의 모든 추상 메서드들을 구현해주지 않으면 에러가 발생한다.</span><br><span class="line">                            &#x2F;&#x2F;만약 구현하지 않거나 부분만 구현해야 할 경우 abstract 클래스가 되어야 한다.</span><br><span class="line">        System.out.println(&quot;Desktop display&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void typing() &#123;</span><br><span class="line">        System.out.println(&quot;Desktop typing&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package abstractex;</span><br><span class="line"></span><br><span class="line">public abstract class Notebook extends Computer&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void typing() &#123;</span><br><span class="line">        System.out.println(&quot;Notebook typing&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package abstractex;</span><br><span class="line"></span><br><span class="line">public class MyNoteBook extends Notebook &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void display() &#123;</span><br><span class="line">        System.out.println(&quot;MyNoteBook display&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package abstractex;</span><br><span class="line"></span><br><span class="line">public class ComputerTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;Computer computer &#x3D; new Computer(); &#x2F;&#x2F;추상 클래스이기 때문에 인스턴스화 불가능</span><br><span class="line">        Computer desktop &#x3D; new Desktop();</span><br><span class="line">        desktop.display();</span><br><span class="line">        desktop.turnOn();</span><br><span class="line"></span><br><span class="line">        Computer mynotebook &#x3D; new MyNoteBook(); &#x2F;&#x2F;NoteBook type이나 MyNoteBook type도 가능</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Study</category>
        <category>JAVA OOP</category>
      </categories>
  </entry>
  <entry>
    <title>34. 추상 클래스 응용, 템플릿 메서드</title>
    <url>/2020/08/12/hexo_OOP_34/</url>
    <content><![CDATA[<h1 id="객체-지향-프로그래밍"><a href="#객체-지향-프로그래밍" class="headerlink" title="객체 지향 프로그래밍"></a>객체 지향 프로그래밍</h1><h4 id="34-추상-클래스-응용-템플릿-메서드"><a href="#34-추상-클래스-응용-템플릿-메서드" class="headerlink" title="34. 추상 클래스 응용: 템플릿 메서드"></a>34. 추상 클래스 응용: 템플릿 메서드</h4><p>템플릿 : 틀이나 견본<br>템플릿 메서드 : 추상 메서드나 구현된 메서드를 활용하여 전체의 흐름을 정의 해 놓은 메서드<br>            final로 선언하여 재정의할 수 없게함<br>템플릿 메서드 패턴 : 디자인 패턴의 일종<br>프레임 워크에서 많이 사용되는 설계 패턴<br>추상 클래스로 선언된 상의 클래스에서 추상 메서드를 이용하여 전체 구현의 흐름을 정의하고<br>구체적인 각 메서드 구현은 하위 클래스에 위임함<br>하위 클래스가 어떤 구현을 하든 템플릿 메서드에 정의된 시나리오 대로 수행됨   </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package template;</span><br><span class="line"></span><br><span class="line">public abstract class Car &#123;</span><br><span class="line"></span><br><span class="line">    public abstract void drive();</span><br><span class="line">    public abstract void stop();</span><br><span class="line"></span><br><span class="line">    public void startCar() &#123;</span><br><span class="line">        System.out.println(&quot;시동을 켭니다.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void turnOff() &#123;</span><br><span class="line">        System.out.println(&quot;시동을 끕니다.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void washCar() &#123;&#125;; &#x2F;&#x2F;훅메서드, 하위 클래스에서 재정의 용으로 생성</span><br><span class="line"></span><br><span class="line">    final public void run() &#123; &#x2F;&#x2F;템플릿 메서드, 재정의 할 수 없도록 final 키워드 사용</span><br><span class="line">                              &#x2F;&#x2F;시나리오가 정의되어있다.</span><br><span class="line">        startCar();</span><br><span class="line">        drive();</span><br><span class="line">        stop();</span><br><span class="line">        turnOff();</span><br><span class="line">        washCar();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package template;</span><br><span class="line"></span><br><span class="line">public class AICar extends Car &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void drive() &#123;</span><br><span class="line">        System.out.println(&quot;자율 주행합니다.&quot;);</span><br><span class="line">        System.out.println(&quot;자동차가 스스로 방향을 바꿉니다.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void stop() &#123;</span><br><span class="line">        System.out.println(&quot;스스로 멈춥니다.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void washCar() &#123; &#x2F;&#x2F;훅메서드 재정의</span><br><span class="line">        System.out.println(&quot;자동 세차 합니다.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package template;</span><br><span class="line"></span><br><span class="line">public class ManualCar extends Car &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void drive() &#123;</span><br><span class="line">        System.out.println(&quot;사람이 운전합니다.&quot;);</span><br><span class="line">        System.out.println(&quot;사람이 핸들을 조작합니다.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void stop() &#123;</span><br><span class="line">        System.out.println(&quot;브레이크를 밟아서 정지합니다.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package template;</span><br><span class="line"></span><br><span class="line">public class CarTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        Car aicar &#x3D; new AICar();</span><br><span class="line">        aicar.run();</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);</span><br><span class="line"></span><br><span class="line">        Car manualcar &#x3D; new ManualCar();</span><br><span class="line">        manualcar.run();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>final 예약어<br>final 변수 : 변경될 수 없는 상수<br>final 메서드 : 하위 클래스에서 재정의 할 수 없음<br>final 클래스 : 더 이상 상속될 수 없음  </li>
</ul>
]]></content>
      <categories>
        <category>Study</category>
        <category>JAVA OOP</category>
      </categories>
  </entry>
  <entry>
    <title>37. 인터페이스</title>
    <url>/2020/08/12/hexo_OOP_37/</url>
    <content><![CDATA[<h1 id="객체-지향-프로그래밍"><a href="#객체-지향-프로그래밍" class="headerlink" title="객체 지향 프로그래밍"></a>객체 지향 프로그래밍</h1><h4 id="37-인터페이스"><a href="#37-인터페이스" class="headerlink" title="37. 인터페이스"></a>37. 인터페이스</h4><ul>
<li><p>인터페이스의 요소<br>추상 메서드 : 인터페이스는 모두 추상 메서드로만 구현되어 있다.<br>상수 : new가 될 수 없기때문에 모든 변수는 상수이다.<br>디폴트 메서드 : 하위 클래스들의 중복 구현 방지.<br>정적 메서드<br>private 메서드     </p>
</li>
<li><p>인터페이스의 선언과 구현</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface Calc &#123;</span><br><span class="line"></span><br><span class="line">int iNum &#x3D; 3; &#x2F;&#x2F;컴파일 과정에서 상수로 변환 </span><br><span class="line"></span><br><span class="line">int add(int num1,int num2); &#x2F;&#x2F;컴파일 과정에서 추상 메서드로 변환 </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package interfaceex;</span><br><span class="line"></span><br><span class="line">public class CalcTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        Calc calc &#x3D; new CompleteCalc();</span><br><span class="line">        int n1 &#x3D;10;</span><br><span class="line">        int n2 &#x3D; 2;</span><br><span class="line"></span><br><span class="line">        System.out.println(calc.add(n1,n2));</span><br><span class="line">        System.out.println(calc.substract(n1,n2));</span><br><span class="line">        System.out.println(calc.times(n1,n2));</span><br><span class="line">        System.out.println(calc.divide(n1,n2));</span><br><span class="line"></span><br><span class="line">        CompleteCalc ccalc &#x3D; (CompleteCalc)calc;</span><br><span class="line">        ccalc.showInfo();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package interfaceex;</span><br><span class="line"></span><br><span class="line">public abstract class Calculator implements Calc&#123; &#x2F;&#x2F;인터페이스는 implements</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int add(int num1, int num2) &#123;</span><br><span class="line">        return num1+num2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int substract(int num1, int num2) &#123;</span><br><span class="line">        return num1-num2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package interfaceex;</span><br><span class="line"></span><br><span class="line">public class CompleteCalc extends Calculator&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public int times(int num1, int num2) &#123;</span><br><span class="line">        return num1*num2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int divide(int num1, int num2) &#123;</span><br><span class="line">        if (num2&#x3D;&#x3D;0) &#123;</span><br><span class="line">            return Error;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return num1 &#x2F; num2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void showInfo() &#123;</span><br><span class="line">        System.out.println(&quot;모두 구현하였습니다.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Study</category>
        <category>JAVA OOP</category>
      </categories>
  </entry>
  <entry>
    <title>38. 인터페이스를 활용한 다형성 구현</title>
    <url>/2020/08/12/hexo_OOP_38/</url>
    <content><![CDATA[<h1 id="객체-지향-프로그래밍"><a href="#객체-지향-프로그래밍" class="headerlink" title="객체 지향 프로그래밍"></a>객체 지향 프로그래밍</h1><h4 id="38-인터페이스를-활용한-다형성-구현"><a href="#38-인터페이스를-활용한-다형성-구현" class="headerlink" title="38. 인터페이스를 활용한 다형성 구현"></a>38. 인터페이스를 활용한 다형성 구현</h4><p>인터페이스의 역할 :<br>클라이언트에 어떤 메서드를 제공하는지 알려주는 명세<br>한 객체가 어떤 인터페이스 타입이라는 것은 그 인터페이스의 메서드를 구현했다는 의미<br>클라이언트 프로그램은 실제 구현내용을 몰라도 인터페이스의 정의만 알면 그 객체를 사용할 수 있다.  </p>
<p>ex) JDBC Lib의 Connect 인터페이스에 대한 실제 구현은 DB사에서하며 개발자는 구현내용을 몰라도 됨.  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package scheduler;</span><br><span class="line"></span><br><span class="line">public interface Scheduler &#123;</span><br><span class="line">    public void getNextCall();</span><br><span class="line">    public void sendCallToAgent();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package scheduler;</span><br><span class="line"></span><br><span class="line">public class RoundRobin implements Scheduler&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void getNextCall() &#123;</span><br><span class="line">        System.out.println(&quot;상담 전화를 순서대로 대기열에서 가져옵니다.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void sendCallToAgent() &#123;</span><br><span class="line">        System.out.println(&quot;다음 순서의 상담원에게 배분합니다.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package scheduler;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">public class SchedulerTest &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;전화 상담원 할당 방식을 선택하세요&quot;);</span><br><span class="line">        System.out.println(&quot;R : 한명씩 차례대로&quot;);</span><br><span class="line">        System.out.println(&quot;L : 대기가 적은 상담원 우선&quot;);</span><br><span class="line">        System.out.println(&quot;P : 우선순위 높은고객 우선 숙련도 높은 상담원&quot;);</span><br><span class="line"></span><br><span class="line">        int ch &#x3D; System.in.read();</span><br><span class="line">        Scheduler scheduler &#x3D; null;</span><br><span class="line">        if (ch &#x3D;&#x3D; &#39;R&#39; || ch &#x3D;&#x3D; &#39;r&#39;) &#123;</span><br><span class="line">            scheduler &#x3D; new RoundRobin();</span><br><span class="line">        &#125; else if (ch &#x3D;&#x3D; &#39;L&#39; || ch &#x3D;&#x3D; &#39;l&#39;) &#123;</span><br><span class="line">            scheduler &#x3D; new LeastJob();</span><br><span class="line">        &#125; else if (ch &#x3D;&#x3D; &#39;P&#39; || ch &#x3D;&#x3D; &#39;p&#39;) &#123;</span><br><span class="line">            scheduler &#x3D; new PriorityAllocation();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;Error&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        scheduler.getNextCall();</span><br><span class="line">        scheduler.sendCallToAgent();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Strategy Pattern<br>인터페이스를 이용하면 다양한 정책이나 알고리즘을 프로그램의 큰 수정 없이 적용, 확장할 수 있다.  </li>
</ul>
]]></content>
      <categories>
        <category>Study</category>
        <category>JAVA OOP</category>
      </categories>
  </entry>
  <entry>
    <title>40. 인터페이스의 요소들</title>
    <url>/2020/08/12/hexo_OOP_40/</url>
    <content><![CDATA[<h1 id="객체-지향-프로그래밍"><a href="#객체-지향-프로그래밍" class="headerlink" title="객체 지향 프로그래밍"></a>객체 지향 프로그래밍</h1><h4 id="40-인터페이스의-요소들"><a href="#40-인터페이스의-요소들" class="headerlink" title="40. 인터페이스의 요소들"></a>40. 인터페이스의 요소들</h4><p>상수 : 선언된 모든 변수는 상수로 처리 됨<br>메서드 : 모든 메서드는 추상 메서드<br>java8<br>디폴트 메서드 : 기본 구현을 가지는 메서드, 클래스에서 재정의 가능<br>정적 메서드 : 인스턴스 생성과 상관없이 인터페이스 타입으로 호출하는 메서드<br>java9<br>private 메서드 : 인터페이스 내에서 사용하기 위한 메서드, 클래스에서 재정의 불가능  </p>
<p>추상 클래스와 다른점은 하나의 클래스에서 여러 인터페이스를 구현할 수 있다.<br>이떄, 디폴트 메서드의 이름이 중복된다면, 재정의 해야한다.   </p>
<p>인터페이스 간에 상속할 수도 있다.(type inheritance) 이때 implements 대신 extends를 사용한다.     </p>
<p>요소들     </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">default void description() &#123; &#x2F;&#x2F;디폴트 메서드</span><br><span class="line">    System.out.println(&quot;정수 계산기를 구현합니다.&quot;);</span><br><span class="line">    myMethod();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int total(int[] arr) &#123; &#x2F;&#x2F;정적 메서드, 인스턴스를 생성하지 않고도 쓸 수 있다.</span><br><span class="line">    int total&#x3D;0;</span><br><span class="line"></span><br><span class="line">    for(int i:arr) &#123;</span><br><span class="line">        total +&#x3D; i;</span><br><span class="line">    &#125;</span><br><span class="line">    myStaticMethod();</span><br><span class="line">    return total;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void myMethod() &#123; &#x2F;&#x2F;일반 private 메서드</span><br><span class="line">    System.out.println(&quot;private method&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void myStaticMethod() &#123; &#x2F;&#x2F;정적 private 메서드</span><br><span class="line">    System.out.println(&quot;private static method&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>동시에 여러 인터페이스 상속, 인터페이스 간의 상속    </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package interfaceex;</span><br><span class="line"></span><br><span class="line">public interface X &#123;</span><br><span class="line">    void x();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package interfaceex;</span><br><span class="line"></span><br><span class="line">public interface Y &#123;</span><br><span class="line">    void y();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package interfaceex;</span><br><span class="line"></span><br><span class="line">public interface MyInterface extends X,Y&#123;</span><br><span class="line">    void myMythod();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package interfaceex;</span><br><span class="line"></span><br><span class="line">public class MyClass implements MyInterface&#123;</span><br><span class="line">    &#x2F;&#x2F; MyClass는 MyInterface 타입이기도 하지만, X 타입이기도 하고 Y 타입이기도 하다.</span><br><span class="line">    @Override</span><br><span class="line">    public void myMythod() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void x() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void y() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>인터페이스 상속과 동시에 클래스 상속    </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package bookshelf;</span><br><span class="line"></span><br><span class="line">public interface Queue &#123;</span><br><span class="line"></span><br><span class="line">    void enQueue(String title);</span><br><span class="line">    String deQueue();</span><br><span class="line"></span><br><span class="line">    int getSize();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package bookshelf;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line"></span><br><span class="line">public class Shelf &#123;</span><br><span class="line"></span><br><span class="line">    protected ArrayList&lt;String&gt; shelf;</span><br><span class="line"></span><br><span class="line">    public Shelf() &#123;</span><br><span class="line">        shelf &#x3D; new ArrayList&lt;String&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public ArrayList&lt;String&gt; getShelf() &#123;</span><br><span class="line">        return shelf;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getCount() &#123;</span><br><span class="line">        return shelf.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package bookshelf;</span><br><span class="line"></span><br><span class="line">public class BookShelf extends Shelf implements Queue&#123; &#x2F;&#x2F;extends 먼저</span><br><span class="line">    @Override</span><br><span class="line">    public void enQueue(String title) &#123;</span><br><span class="line">        shelf.add(title);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String deQueue() &#123;</span><br><span class="line">        return shelf.remove(0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int getSize() &#123;</span><br><span class="line">        return getCount();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package bookshelf;</span><br><span class="line"></span><br><span class="line">public class BookShelfTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        Queue bookQueue &#x3D; new BookShelf(); &#x2F;&#x2F;기능적인것을 우선한다면 보통 인터페이스 타입으로 선언</span><br><span class="line">        bookQueue.enQueue(&quot;태백산맥1&quot;);</span><br><span class="line">        bookQueue.enQueue(&quot;태백산맥2&quot;);</span><br><span class="line">        bookQueue.enQueue(&quot;태백산맥3&quot;);</span><br><span class="line"></span><br><span class="line">        System.out.println(bookQueue.deQueue());</span><br><span class="line">        System.out.println(bookQueue.deQueue());</span><br><span class="line">        System.out.println(bookQueue.deQueue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Study</category>
        <category>JAVA OOP</category>
      </categories>
  </entry>
  <entry>
    <title>43. Object 클래스</title>
    <url>/2020/08/12/hexo_OOP_43/</url>
    <content><![CDATA[<h1 id="객체-지향-프로그래밍"><a href="#객체-지향-프로그래밍" class="headerlink" title="객체 지향 프로그래밍"></a>객체 지향 프로그래밍</h1><h4 id="43-Object-클래스"><a href="#43-Object-클래스" class="headerlink" title="43. Object 클래스"></a>43. Object 클래스</h4><ul>
<li>Object 클래스<br>모든 클래스의 최상위 클래스 (java.lang.Object)<br>(java.lang 패키지 위치 : /Library/Java/JavaVirtualMachines/jdk-11.0.7.jdk/Contents/Home/lib/src.zip<br>, java.lang 패키지는 컴파일러가 자동으로 import 해준다.)<br>모든 클래스는 Object 클래스에서 상속 받음<br>모든 클래스는 Object 클래스의 메서드를 사용할 수 있음<br>모든 클래스는 Object 클래스의 일부 메서드를 재정의하여 사용할 수 있음<br>(final로 정의된 메서드들은 재정의 할 수 없음)   </li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package object;</span><br><span class="line"></span><br><span class="line">class Book&#123;</span><br><span class="line">    String title;</span><br><span class="line">    String author;</span><br><span class="line"></span><br><span class="line">    public Book(String title,String author) &#123;</span><br><span class="line">        this.title &#x3D; title;</span><br><span class="line">        this.author &#x3D; author;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;title&#x3D;&#39;&quot; + title + &#39;\&#39;&#39; + &quot;, author&#x3D;&#39;&quot; + author + &#39;\&#39;&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ToStringTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Book book &#x3D; new Book(&quot;토지&quot;,&quot;박경리&quot;);</span><br><span class="line"></span><br><span class="line">        System.out.println(book); &#x2F;&#x2F;Object의 toString 메서드는 메모리 주소를 리턴한다</span><br><span class="line"></span><br><span class="line">        String str &#x3D; new String(&quot;토지&quot;); &#x2F;&#x2F;String 클래스는 Object로부터 toString 메서드가 재정의되어 있음</span><br><span class="line">        System.out.println(str); &#x2F;&#x2F;실제로는 str.toString()</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>toString() 메서드<br>원형 : </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">getClass().getName()+&#39;@&#39;+Integer.toHexString(hashCode());</span><br></pre></td></tr></table></figure>
<p>객체의 정보를 String으로 바꾸어 사용할 때 유용함<br>자바 클래스 중에는 이미 정의된 클래스가 많다<br>(String,Integer,Calendar,etc…)<br>그 외에 많은 클래서에서 재정의하여 사용한다    </p>
</li>
<li><p>equals() 메서드<br>두 객체의 동일함을 논리적으로 재정의 할 수 있음<br>물리적 동일함 : 같은 메모리 주소<br>논리적 동일함 : 같은 학번의 학생, 같은 주문 번호의 주문<br>논리적으로 동일함을 구현하기 위해 사용   </p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Student studentLee &#x3D; new Student(100,&quot;이상원&quot;);</span><br><span class="line">Student studentSang &#x3D; new Student(100,&quot;이상원&quot;);</span><br></pre></td></tr></table></figure>

<p>studentLee와 studentSang은 물리적으로 동일한 객체가 아니지만 논리적으로는 동일한 객체라고 할 수 있다.<br>논리적 동일함을 구현하기 위하여…    </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class EqualsTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        String str1 &#x3D; new String(&quot;abc&quot;);</span><br><span class="line">        String str2 &#x3D; new String(&quot;abc&quot;);</span><br><span class="line"></span><br><span class="line">        System.out.println(str1&#x3D;&#x3D;str2); &#x2F;&#x2F;false, 메모리 주소가 같은지 확인</span><br><span class="line">        System.out.println(str1.equals(str2)); &#x2F;&#x2F;String에 재정의된 equals()는 두 문자열이 같은지 확인</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>hashCode() 메서드<br>반환 값 : 인스턴스가 저장된 가상머신의 주소를 10진수로 반환<br>두 개의 서로 다른 메모리에 위치한 인스턴스가 동일하다는 것은?<br>논리적으로 동일 : equals()의 반환값이 true<br>&amp;&amp;<br>동일한 hashCode 값을 가짐 : hashCode()의 반환 값이 동일   </li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package object;</span><br><span class="line"></span><br><span class="line">class Student &#123;</span><br><span class="line">    int studentNum;</span><br><span class="line">    String studentName;</span><br><span class="line"></span><br><span class="line">    public Student(int studentNum, String studentName) &#123;</span><br><span class="line">        this.studentNum &#x3D; studentNum;</span><br><span class="line">        this.studentName &#x3D; studentName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean equals(Object object) &#123;</span><br><span class="line">        if (object instanceof Student) &#123;</span><br><span class="line">            Student student &#x3D; (Student)object;</span><br><span class="line">            if (this.studentNum&#x3D;&#x3D;student.studentNum) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int hashCode() &#123;</span><br><span class="line">        return studentNum; &#x2F;&#x2F;equals()에서 사용한 멤버변수를 활</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class EqualsTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        Student Lee &#x3D; new Student(100,&quot;이순신&quot;);</span><br><span class="line">        Student Lee2 &#x3D; Lee;</span><br><span class="line">        Student Shin &#x3D; new Student(100,&quot;이순신&quot;);</span><br><span class="line"></span><br><span class="line">        System.out.println(Lee&#x3D;&#x3D;Lee2); &#x2F;&#x2F;true</span><br><span class="line">        System.out.println(Lee&#x3D;&#x3D;Shin); &#x2F;&#x2F;false</span><br><span class="line">        System.out.println(Lee.equals(Shin)); &#x2F;&#x2F;true</span><br><span class="line"></span><br><span class="line">        System.out.println(Lee.hashCode());  &#x2F;&#x2F;100</span><br><span class="line">        System.out.println(Shin.hashCode()); &#x2F;&#x2F;100</span><br><span class="line"></span><br><span class="line">        Integer i1 &#x3D; new Integer(100);</span><br><span class="line">        Integer i2 &#x3D; new Integer(100);</span><br><span class="line"></span><br><span class="line">        System.out.println(i1.equals(i2)); &#x2F;&#x2F;true, Integer에서 equals()와 hashCode()가 재정의 되어있음</span><br><span class="line">        System.out.println(i1.hashCode());</span><br><span class="line">        System.out.println(i2.hashCode());</span><br><span class="line"></span><br><span class="line">        System.out.println(System.identityHashCode(i1)); &#x2F;&#x2F;실제 메모리 주소 값을 확인하려면</span><br><span class="line">        System.out.println(System.identityHashCode(i2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>clone() 메서드<br>객체의 복사본을 만듦<br>기본 틀으로 부터 같은 속성 값을 가진 객체의 복사본을 생성할 수 있음     </li>
</ul>
<p>객체지향 프로그래밍의 정보은닉에 위배될 가능성이 있으므로 복제할 객체는 cloneable 인터페이스를 명시해야 함     </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package object;</span><br><span class="line"></span><br><span class="line">class Book implements Cloneable&#123; &#x2F;&#x2F;마크인터페이스 Cloneable : 이 클래스는 복제 가능하다는 것을 명시</span><br><span class="line">    String title;</span><br><span class="line">    String author;</span><br><span class="line"></span><br><span class="line">    public Book(String title,String author) &#123;</span><br><span class="line">        this.title &#x3D; title;</span><br><span class="line">        this.author &#x3D; author;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;title&#x3D;&#39;&quot; + title + &#39;\&#39;&#39; + &quot;, author&#x3D;&#39;&quot; + author + &#39;\&#39;&#39;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected Object clone() throws CloneNotSupportedException &#123;</span><br><span class="line">        return super.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ToStringTest &#123;</span><br><span class="line">    public static void main(String[] args) throws CloneNotSupportedException &#123;</span><br><span class="line">        Book book &#x3D; new Book(&quot;토지&quot;,&quot;박경리&quot;);</span><br><span class="line">        System.out.println(book);</span><br><span class="line">        Book book2 &#x3D; (Book)book.clone(); &#x2F;&#x2F;Object로 반환되기 때문에 다운캐스팅</span><br><span class="line">        System.out.println(book2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>finalize() 메서드<br>직접 호출하는 메서드는 아니다.<br>인스턴스가 힙메모리에서 해제될 때 가비지 콜렉터에서 호출되는 메서드<br>주로 리소스 해제 또는 소켓 닫기 등에 사용    </li>
</ul>
]]></content>
      <categories>
        <category>Study</category>
        <category>JAVA OOP</category>
      </categories>
  </entry>
  <entry>
    <title>46. Class 클래스</title>
    <url>/2020/08/12/hexo_OOP_46/</url>
    <content><![CDATA[<h1 id="객체-지향-프로그래밍"><a href="#객체-지향-프로그래밍" class="headerlink" title="객체 지향 프로그래밍"></a>객체 지향 프로그래밍</h1><h4 id="46-Class-클래스"><a href="#46-Class-클래스" class="headerlink" title="46. Class 클래스"></a>46. Class 클래스</h4><ul>
<li>Class 클래스<br>자바의 모든 클래스와 인터페이스는 컴파일 후 class 파일로 생성됨<br>class 파일에는 객체의 정보(멤버변수, 메서드, 생성자 등)가 포함되어 있음<br>Class 클래스는 컴파일된 class 파일에서 객체의 정보를 가져올 수 있음<br>동적 로딩에 많이 사용    </li>
</ul>
<p>Class 클래스 가져오기  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String s &#x3D; new String();</span><br><span class="line">Class c &#x3D; s.getClass();</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Class c &#x3D; String.Class;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Class c &#x3D; Class.forName(&quot;java.lang.String&quot;); &#x2F;&#x2F;동적 로딩 : 컴파일 타임이 아닌 런타임에서 로딩</span><br></pre></td></tr></table></figure>

<ul>
<li>reflection 프로그래밍<br>Class 클래스로부터 객체의 정보를 가져와 프로그래밍하는 방식<br>로컬에 객체가 없고 자료형을 알 수 없는 경우 유용한 프로그래밍<br>java.lang.reflect 패키지에 있는 클래스 활용    </li>
</ul>
<p>String 클래스 정보 확인</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package classex;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.Constructor;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line">public class StringClassTest &#123;</span><br><span class="line">    public static void main(String[] args) throws ClassNotFoundException &#123;</span><br><span class="line"></span><br><span class="line">        Class c1 &#x3D; String.class;</span><br><span class="line"></span><br><span class="line">        String str &#x3D; new String();</span><br><span class="line">        Class c2 &#x3D; str.getClass();</span><br><span class="line"></span><br><span class="line">        Class c3 &#x3D; Class.forName(&quot;java.lang.String&quot;);</span><br><span class="line"></span><br><span class="line">        Constructor[] cons &#x3D; c3.getConstructors();</span><br><span class="line">        for (Constructor con : cons) &#123; &#x2F;&#x2F;String 클래스의 모든 생성자 출력</span><br><span class="line">            System.out.println(con);</span><br><span class="line">        &#125; &#x2F;&#x2F;보통 로컬에 이 클래스가 없을 때 사용</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        Method[] methods &#x3D; c3.getMethods();</span><br><span class="line">        for (Method method : methods) &#123; &#x2F;&#x2F;String 클래스의 모든 메서드 선언부 출력</span><br><span class="line">            System.out.println(method);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Class 클래스를 이용한 사용자 클래스 인스턴스 생성</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package classex;</span><br><span class="line"></span><br><span class="line">public class Person &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line"></span><br><span class="line">    public Person() &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    public Person(String name) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Person(String name, int age) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">        this.age &#x3D; age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAge(int age) &#123;</span><br><span class="line">        this.age &#x3D; age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package classex;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.Constructor;</span><br><span class="line">import java.lang.reflect.InvocationTargetException;</span><br><span class="line"></span><br><span class="line">public class ClassTest &#123;</span><br><span class="line">    public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException &#123;</span><br><span class="line"></span><br><span class="line">        Person person &#x3D; new Person(&quot;james&quot;);</span><br><span class="line">        System.out.println(person);</span><br><span class="line"></span><br><span class="line">        Class c1 &#x3D; Class.forName(&quot;classex.Person&quot;); &#x2F;&#x2F;동적 로딩</span><br><span class="line">        Person person1 &#x3D; (Person)c1.newInstance(); &#x2F;&#x2F;기본생성자 사용하여 인스턴스 생성, 리턴타입이 Object이므로 다운캐스팅</span><br><span class="line">        System.out.println(person1);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;기본생성자가 아닌 다른 생성자를 사용하여 인스턴스를 생성하려는 경우..</span><br><span class="line">        Class[] parameterTypes &#x3D; &#123;String.class&#125;; &#x2F;&#x2F;String을 사용하는 생성자를 사용할 것</span><br><span class="line">        Constructor cons &#x3D; c1.getConstructor(parameterTypes); &#x2F;&#x2F;생성자 매개변수 타입을 요소로 가지는 Class 타입 배열 필요</span><br><span class="line"></span><br><span class="line">        System.out.println(cons.toString()); &#x2F;&#x2F;선택된 생성자 출력</span><br><span class="line"></span><br><span class="line">        Object[] initargs &#x3D; &#123;&quot;김유신&quot;&#125;; &#x2F;&#x2F;생성자의 매개변수로 사용될 값들을 요소로 가지는 배열(여러개일 수 있으므로 배열 사용)</span><br><span class="line">        Person personKim &#x3D; (Person) cons.newInstance(initargs); &#x2F;&#x2F;매개변수 값을 요소로 가지는 Object 타입 배열 필요</span><br><span class="line">        System.out.println(personKim);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>forName() 메서드와 동적 로딩<br>Class 클래스 static 메서드<br>동적 로딩 : 컴파일시 데이터 타입이 모두 biding되어 자료형이 로딩되는 것이 아닌,<br>실행 중에 데이터 타입을 알고 biding 되는 방식<br>실행 시에 로딩되므로 경우에 따라 다른 클래스가 사용될 수 있어 유용함<br>컴파일 타임에 체크할 수 없으므로 해당 문자열에 대한 클래스가 없는 경우 예외 발생  </li>
</ul>
]]></content>
      <categories>
        <category>Study</category>
        <category>JAVA OOP</category>
      </categories>
  </entry>
  <entry>
    <title>48. String, Wrapper 클래스</title>
    <url>/2020/08/12/hexo_OOP_48/</url>
    <content><![CDATA[<h1 id="객체-지향-프로그래밍"><a href="#객체-지향-프로그래밍" class="headerlink" title="객체 지향 프로그래밍"></a>객체 지향 프로그래밍</h1><h4 id="48-String-Wrapper-클래스"><a href="#48-String-Wrapper-클래스" class="headerlink" title="48. String, Wrapper 클래스"></a>48. String, Wrapper 클래스</h4><ul>
<li>String    </li>
</ul>
<p>String 클래스 선언하기</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String str1 &#x3D; new String(&quot;abc&quot;); &#x2F;&#x2F;인스턴스로 생성</span><br><span class="line">String str2 &#x3D; &quot;abc&quot;              &#x2F;&#x2F;상수풀에 있는 문자</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package string;</span><br><span class="line"></span><br><span class="line">public class StringTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        String str1 &#x3D; new String(&quot;abc&quot;); &#x2F;&#x2F;힙메모리 영역</span><br><span class="line">        String str2 &#x3D; &quot;abc&quot;;                     &#x2F;&#x2F;상수 풀</span><br><span class="line">        String str3 &#x3D; &quot;abc&quot;;</span><br><span class="line"></span><br><span class="line">        System.out.println(str1 &#x3D;&#x3D; str2); &#x2F;&#x2F;false, 메모리 위치가 다르기 때문</span><br><span class="line">        System.out.println(str2 &#x3D;&#x3D; str3); &#x2F;&#x2F;true, 둘다 상수풀이기 때문</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>한번 선언되거나 생성된 문자열은 변경할 수 없다.<br>가변적으로 문자열을 사용하려면 StringBuilder 또는 StringBuffer를 사용한다.<br>StringBuilder는 단일 쓰레드 프로그래밍에서,<br>StringBuffer는 멀티 쓰레드 프로그래밍에서 사용된다.  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package string;</span><br><span class="line"></span><br><span class="line">public class StringTest2 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        String java &#x3D; new String(&quot;java&quot;);</span><br><span class="line">        String android &#x3D; new String(&quot;android&quot;);</span><br><span class="line"></span><br><span class="line">        System.out.println(System.identityHashCode(java));</span><br><span class="line">        java &#x3D; java.concat(android);</span><br><span class="line"></span><br><span class="line">        System.out.println(java);</span><br><span class="line">        System.out.println(System.identityHashCode(java)); &#x2F;&#x2F;메모리 주소가 변경됨,즉 새로운 메모리 영역 사용됨</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package string;</span><br><span class="line"></span><br><span class="line">public class StringBuilderTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        String java &#x3D; new String(&quot;java&quot;);</span><br><span class="line">        String android &#x3D; new String(&quot;android&quot;);</span><br><span class="line"></span><br><span class="line">        StringBuilder buffer &#x3D; new StringBuilder(java);</span><br><span class="line">        System.out.println(System.identityHashCode(buffer));</span><br><span class="line">        buffer.append(&quot;android&quot;);</span><br><span class="line">        System.out.println(System.identityHashCode(buffer)); &#x2F;&#x2F;변경되어도 메모리 주소는 변하지 않음</span><br><span class="line"></span><br><span class="line">        java &#x3D; buffer.toString(); &#x2F;&#x2F;String 타입으로 형변환 </span><br><span class="line">        System.out.println(java);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Wrapper 클래스<br>기본 자료형에 대한 클래스<br>Boolean, Integer, 등등    </li>
</ul>
]]></content>
      <categories>
        <category>Study</category>
        <category>JAVA OOP</category>
      </categories>
  </entry>
  <entry>
    <title>49. 제네릭 프로그래밍</title>
    <url>/2020/08/12/hexo_OOP_49/</url>
    <content><![CDATA[<h1 id="객체-지향-프로그래밍"><a href="#객체-지향-프로그래밍" class="headerlink" title="객체 지향 프로그래밍"></a>객체 지향 프로그래밍</h1><h4 id="49-제네릭-프로그래밍"><a href="#49-제네릭-프로그래밍" class="headerlink" title="49. 제네릭 프로그래밍"></a>49. 제네릭 프로그래밍</h4><ul>
<li>제네릭 프로그래밍이란<br>변수의 선언이나 메서드의 매개변수를 하나의 참조 자료형이 아닌 여러 자료형으로 변환될 수 있도록 프로그래밍 하는 방식<br>실제 사용되는 참조 자료형으로의 변환은 컴파일러가 검증하므로 안정적인 프로그래밍 방식이다.  </li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package generic;</span><br><span class="line"></span><br><span class="line">public class GenericPrinter&lt;T extends Meterial&gt; &#123; &#x2F;&#x2F; T : 자료형 매개변</span><br><span class="line">                                                  &#x2F;&#x2F; 클래스가 생성될때 T에 타입을 대입</span><br><span class="line">                                                  &#x2F;&#x2F;Meterial을 상속받은 타입만 들어갈 수 있게 제한</span><br><span class="line"></span><br><span class="line">    private T meterial; &#x2F;&#x2F;재료는 플라스틱,파우더 등 여러가지일 수 있으므로</span><br><span class="line"></span><br><span class="line">    public T getMeterial() &#123; &#x2F;&#x2F;제네릭 타입을 사용하는 메서드 : 제네릭 메서드</span><br><span class="line">        return meterial;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setMeterial(T meterial) &#123;</span><br><span class="line">        this.meterial &#x3D; meterial;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return meterial.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void printing() &#123;</span><br><span class="line">        meterial.doPrinting(); &#x2F;&#x2F;T가 Meterial 클래스로 제한되면서, Meterial 클래스에 정의된 메서드를 공유할 수 있다.</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package generic;</span><br><span class="line"></span><br><span class="line">public abstract class Meterial &#123;</span><br><span class="line"></span><br><span class="line">    public abstract void doPrinting();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package generic;</span><br><span class="line"></span><br><span class="line">public class Plastic extends Meterial&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;재료는 플라스틱입니다.&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void doPrinting() &#123;</span><br><span class="line">        System.out.println(&quot;플라스틱 프린팅합니다.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package generic;</span><br><span class="line"></span><br><span class="line">public class Powder extends Meterial&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;재료는 파우더입니다&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void doPrinting() &#123;</span><br><span class="line">        System.out.println(&quot;파우더 프린팅합니다.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package generic;</span><br><span class="line"></span><br><span class="line">public class GenericPrinterTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        GenericPrinter&lt;Powder&gt; powderPrinter &#x3D; new GenericPrinter&lt;&gt;();</span><br><span class="line">        Powder powder &#x3D; new Powder();</span><br><span class="line">        powderPrinter.setMeterial(powder);</span><br><span class="line">        System.out.println(powderPrinter.toString());</span><br><span class="line"></span><br><span class="line">        GenericPrinter&lt;Plastic&gt; plasticPrinter &#x3D; new GenericPrinter&lt;&gt;();</span><br><span class="line">        Plastic plastic &#x3D; new Plastic();</span><br><span class="line">        plasticPrinter.setMeterial(plastic);</span><br><span class="line">        System.out.println(plasticPrinter.toString());</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;GenericPrinter&lt;Water&gt; waterPrinter; &#x2F;&#x2F;Water는 Meterial 클래스를 상속받지 않았으므로 에러 발생</span><br><span class="line"></span><br><span class="line">        plasticPrinter.printing();</span><br><span class="line">        powderPrinter.printing();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>일반 클래스에서도 제네릭 메서드를 사용할 수 있다.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public &lt;T,V&gt; double makeRectangle(Point&lt;T,V&gt; p1, Point&lt;T,V&gt; p2) &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>제네릭 메서드의 자료형 매개변수&lt;T,V&gt;는 메서드 내에서만 유효하다.(지역변수와 같은 개념)  </p>
]]></content>
      <categories>
        <category>Study</category>
        <category>JAVA OOP</category>
      </categories>
  </entry>
  <entry>
    <title>50. 컬렉션 프레임워크</title>
    <url>/2020/08/12/hexo_OOP_50/</url>
    <content><![CDATA[<h1 id="객체-지향-프로그래밍"><a href="#객체-지향-프로그래밍" class="headerlink" title="객체 지향 프로그래밍"></a>객체 지향 프로그래밍</h1><h4 id="50-컬렉션-프레임워크"><a href="#50-컬렉션-프레임워크" class="headerlink" title="50. 컬렉션 프레임워크"></a>50. 컬렉션 프레임워크</h4><ul>
<li>컬렉션 프레임워크란?<br>프로그램 구현에 필요한 자료구조와 알고리즘을 구현해 놓은 라이브러리<br>java.util 패키지에 구현되어 있음<br>개발에 소요되는 시간을 절약하고 최적화된 라이브러리를 사용할 수 있음<br>Collection 인터페이스와 Map 인터페이스로 구성됨    </li>
</ul>
<p>Collection : 하나의 객체 관리를 위해 선언된 인터페이스<br>+–List : 순서가 있는 자료관리, 중복 허용<br>+–Set : 순서가 정해져있지 않음, 중복을 허용하지 않음  </p>
<p>Map : 쌍으로 이루어진 객체 관리를 위해 선언된 인터페이스<br>Map을 사용하는 객체는 key-value 쌍으로 되어있으며 이중 Key는 중복될 수 없다. </p>
<ul>
<li>List 인터페이스<br>Collection의 하위 인터페이스<br>객체를 순서에따라 저장하고 관리하는데 필요한 메서드가 선언된 인터페이스<br>배열의 기능을 구현하기 위한 메서드가 선언됨<br>ArrayList, Vector, LinkedList</li>
</ul>
<p>ArrayList와 Vector<br>객체 배열 클래스<br>일반적으로 ArrayList를 더 많이 사용<br>Vector는 멀티 쓰레드 프로그램에서 동기화를 제공<br>capacity와 size는 다른 의미   </p>
<p>ArrayList와 LinkedList<br>둘다 자료의 순차적 구조를 구현한 클래스<br>ArrayList는 물리적 순서와 논리적 순서가 동일하다. (검색용)<br>LinkedList는 물리적으로는 순차적이지 않을 수 있다. (변경용)     </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package collection;</span><br><span class="line"></span><br><span class="line">import java.util.LinkedList;</span><br><span class="line"></span><br><span class="line">public class LinkedListTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        LinkedList&lt;String&gt; myList &#x3D; new LinkedList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        myList.add(&quot;A&quot;);</span><br><span class="line">        myList.add(&quot;B&quot;);</span><br><span class="line">        myList.add(&quot;C&quot;);</span><br><span class="line"></span><br><span class="line">        System.out.println(myList);</span><br><span class="line">        myList.add(1,&quot;D&quot;);</span><br><span class="line"></span><br><span class="line">        System.out.println(myList);</span><br><span class="line"></span><br><span class="line">        for(int i&#x3D;0;i&lt;myList.size();i++) &#123;</span><br><span class="line">            String s &#x3D; myList.get(i);  &#x2F;&#x2F;set 인터페이스에는 get메서드가 없다.</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>Stack<br>LIFO<br>이미 구현된 클래스가 제공되고 있음<br>ArrayList, LinkedList로 구현할 수 있음<br>관련 용어 : pop, push, top    </p>
</li>
<li><p>Queue<br>FIFO<br>ArrayList, LinkedList로 구현할 수 있음<br>관련용어 : front, rear, enqueue, dequeue    </p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package collection;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line"></span><br><span class="line">class MyStack &#123;</span><br><span class="line">    private ArrayList&lt;String&gt; arrayStack &#x3D; new ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">    public void push(String data) &#123;</span><br><span class="line">        arrayStack.add(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String pop() &#123;</span><br><span class="line">        int len &#x3D; arrayStack.size();</span><br><span class="line">        if (len &#x3D;&#x3D; 0 ) &#123;</span><br><span class="line">            System.out.println(&quot;Stack이 비어있습니다.&quot;);</span><br><span class="line">            return null;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return arrayStack.remove(len-1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class StackTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        MyStack myStack &#x3D; new MyStack();</span><br><span class="line">        myStack.push(&quot;A&quot;);</span><br><span class="line">        myStack.push(&quot;B&quot;);</span><br><span class="line">        myStack.push(&quot;C&quot;);</span><br><span class="line"></span><br><span class="line">        System.out.println(myStack.pop());</span><br><span class="line">        System.out.println(myStack.pop());</span><br><span class="line">        System.out.println(myStack.pop());</span><br><span class="line">        System.out.println(myStack.pop());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Set 인터페이스<br>Collection 하위의 인터페이스<br>중복을 허용하지 않는다.<br>순서가 없다.<br>get(i) 메서드를 제공하지 않는다.(대신 Iterator 순회)<br>아이디, 주민번호, 사번 등 유일한 값이나 객체를 관리할 때 사용<br>HashSet, TreeSet</li>
</ul>
<p>Iterator로 순회하기<br>Collection의 개체를 순회하는 인터페이스  </p>
<p>iterator() 메서드 호출</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Iterator ir &#x3D; new memberArrayList.iterator();</span><br></pre></td></tr></table></figure>
<p>Iterator에 선언된 메서드<br>hashNext() : 이후에 요소가 더 있는지 체크<br>next : 다음 요소 반환     </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package collection.set;</span><br><span class="line"></span><br><span class="line">import java.util.HashSet;</span><br><span class="line">import java.util.Iterator;</span><br><span class="line"></span><br><span class="line">public class HashSetTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        HashSet&lt;String&gt; set &#x3D; new HashSet&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        set.add(&quot;이순신&quot;);</span><br><span class="line">        set.add(&quot;김유신&quot;);</span><br><span class="line">        set.add(&quot;강감찬&quot;);</span><br><span class="line">        set.add(&quot;이순신&quot;);</span><br><span class="line"></span><br><span class="line">        System.out.println(set); &#x2F;&#x2F;순서가 없음, 중복도 없음</span><br><span class="line"></span><br><span class="line">        Iterator&lt;String&gt; ir &#x3D; set.iterator(); &#x2F;&#x2F;모든 Collection 객체에서 사용가능</span><br><span class="line"></span><br><span class="line">        while(ir.hasNext()) &#123;</span><br><span class="line">            String str &#x3D; ir.next(); &#x2F;&#x2F;순회 선언시 String으로 선언하였기 때문에 반환값은 String이 된다.</span><br><span class="line">            System.out.println(str);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>HashSet</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package collection.set;</span><br><span class="line"></span><br><span class="line">import java.util.HashSet;</span><br><span class="line">import java.util.Iterator;</span><br><span class="line"></span><br><span class="line">public class MemberHashSet &#123;</span><br><span class="line"></span><br><span class="line">    private HashSet&lt;Member&gt; hashSet;</span><br><span class="line"></span><br><span class="line">    public MemberHashSet() &#123;</span><br><span class="line">        hashSet &#x3D; new HashSet&lt;Member&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void addMember(Member member) &#123;</span><br><span class="line">        hashSet.add(member);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean removeMember(int memberId) &#123;</span><br><span class="line"></span><br><span class="line">        Iterator&lt;Member&gt; ir &#x3D; hashSet.iterator();</span><br><span class="line">        while(ir.hasNext()) &#123;</span><br><span class="line">            Member member &#x3D; ir.next();</span><br><span class="line">            if (member.getMemberId() &#x3D;&#x3D; memberId) &#123;</span><br><span class="line">                hashSet.remove(member);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(memberId+&quot;번호가 존재하지 않습니다.&quot;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void showAllMember() &#123;</span><br><span class="line">        for(Member member : hashSet) &#123;</span><br><span class="line">            System.out.println(member);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package collection.set;</span><br><span class="line"></span><br><span class="line">public class MemberHashSetTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        MemberHashSet manager &#x3D; new MemberHashSet();</span><br><span class="line"></span><br><span class="line">        Member memberLee &#x3D; new Member(100,&quot;Lee&quot;);</span><br><span class="line">        Member memberKim &#x3D; new Member(101,&quot;Kim&quot;);</span><br><span class="line">        Member memberPark &#x3D; new Member(102,&quot;Park&quot;);</span><br><span class="line">        Member memberPark2 &#x3D; new Member(102,&quot;Park&quot;);</span><br><span class="line"></span><br><span class="line">        manager.addMember(memberLee);</span><br><span class="line">        manager.addMember(memberKim);</span><br><span class="line">        manager.addMember(memberPark);</span><br><span class="line">        manager.addMember(memberPark2); &#x2F;&#x2F;중복된 데이터이기 때문에 저장되지 않는데,</span><br><span class="line">                                        &#x2F;&#x2F;이는 Member 클래스에서 equals(), hashCode()를 </span><br><span class="line">                                        &#x2F;&#x2F;ID가 같은경우 논리적으로 동일하도록 재정의했기 때문이다.</span><br><span class="line"></span><br><span class="line">        manager.showAllMember();</span><br><span class="line"></span><br><span class="line">        manager.removeMember(100);</span><br><span class="line">        manager.showAllMember();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Member 클래스 중</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public boolean equals(Object obj) &#123;</span><br><span class="line">    if (obj instanceof Member) &#123;</span><br><span class="line">        Member member &#x3D; (Member)obj;</span><br><span class="line">        if (memberId &#x3D;&#x3D; member.memberId) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125; return false;</span><br><span class="line">    &#125; return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public int hashCode() &#123;</span><br><span class="line">    return memberId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>TreeSet<br>객체의 정렬에 사용되는 클래스    </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package collection.set.treeset;</span><br><span class="line"></span><br><span class="line">import java.util.TreeSet;</span><br><span class="line"></span><br><span class="line">public class TreeSetTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        TreeSet&lt;String&gt; treeSet &#x3D; new TreeSet&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        treeSet.add(&quot;홍길동&quot;);</span><br><span class="line">        treeSet.add(&quot;강감찬&quot;);</span><br><span class="line">        treeSet.add(&quot;이순신&quot;);</span><br><span class="line"></span><br><span class="line">        for (String str : treeSet) &#123;</span><br><span class="line">            System.out.println(str); &#x2F;&#x2F;정렬이 되어있음, String 클래스에 Comparable 인터페이스가 구현되어 있음</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>중복을 허용하지 않으면서 오름차순 또는 내림차순으로 객체를 정렬<br>내부적으로 이진 검색 트리로 구현되어 있음<br>트리에 자료가 저장될 때 자료를 비교하게 되는데<br>이때의 객체비교를 위하여 Comparable이나 Comparator 인터페이스를 구현해야 한다.</p>
<p>Member 클래스 중<br>숫자로 비교하는 경우..</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Member implements Comparable&lt;Member&gt;&#123;</span><br><span class="line">...</span><br><span class="line">    @Override</span><br><span class="line">    public int compareTo(Member member) &#123; &#x2F;&#x2F;this와 매개변수를 비교</span><br><span class="line">        return (this.memberId - member.memberId); &#x2F;&#x2F;양수를 반환하게 되면 오름차순 정렬</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>문자열로 비교하는 경우..</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public int compareTo(Member member) &#123; &#x2F;&#x2F;this와 매개변수를 비교</span><br><span class="line">    return this.memberName.compareTo(member.getMemberName()); &#x2F;&#x2F;String은 compareTo가 이미 구현되어 있음   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Comparator 인터페이스를 사용하는 경우…</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public int compare(Member o1, Member o2) &#123; &#x2F;&#x2F;o1이 this, o2가 매개변</span><br><span class="line">    return (o1.memberId-o2.memberId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;TreeSet 생성자에 Comparator가 구현되어 있는 객체를 매개변수로 전달해야 한다.   </span><br><span class="line">public MemberTreeSet() &#123;</span><br><span class="line">    treeSet &#x3D; new TreeSet&lt;Member&gt;(new Member());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>이미 Comparable이 구현되어있는 경우 Comparator를 통해 다른 정렬방식을 정의할 수 있다.  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package collection.set.treeset;</span><br><span class="line"></span><br><span class="line">import java.util.Comparator;</span><br><span class="line">import java.util.TreeSet;</span><br><span class="line"></span><br><span class="line">class MyCompare implements Comparator&lt;String&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public int compare(String o1, String o2) &#123;</span><br><span class="line">        return o1.compareTo(o2)*(-1); &#x2F;&#x2F;문자열 역순정렬</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class TreeSetTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        TreeSet&lt;String&gt; treeSet &#x3D; new TreeSet&lt;String&gt;(new MyCompare()); &#x2F;&#x2F;String 클래스에서 구현된 정렬 방식을 무시하고</span><br><span class="line">                                                                        &#x2F;&#x2F;내가 구현한 정렬 방식을 사용할 수 있다.</span><br><span class="line"></span><br><span class="line">        treeSet.add(&quot;홍길동&quot;);</span><br><span class="line">        treeSet.add(&quot;강감찬&quot;);</span><br><span class="line">        treeSet.add(&quot;이순신&quot;);</span><br><span class="line"></span><br><span class="line">        for (String str : treeSet) &#123;</span><br><span class="line">            System.out.println(str); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Study</category>
        <category>JAVA OOP</category>
      </categories>
  </entry>
  <entry>
    <title>55. Map 인터페이스</title>
    <url>/2020/08/12/hexo_OOP_55/</url>
    <content><![CDATA[<h1 id="객체-지향-프로그래밍"><a href="#객체-지향-프로그래밍" class="headerlink" title="객체 지향 프로그래밍"></a>객체 지향 프로그래밍</h1><h4 id="55-Map-인터페이스"><a href="#55-Map-인터페이스" class="headerlink" title="55. Map 인터페이스"></a>55. Map 인터페이스</h4><ul>
<li>Map 인터페이스<br>쌍으로 이루어진 객체 관리를 위해 선언된 인터페이스<br>검색을 위한 자료구조<br>Map을 사용하는 객체는 key-value 쌍으로 되어있으며 Key는 중복될 수 없다.<br>Key를 이용하여 값을 저장하거나 검색, 삭제할 때 사용하면 편리하다.<br>내부적으로 hash 방식으로 구현되어 있다.    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">index &#x3D; hash(key) &#x2F;&#x2F;index는 저장 위치</span><br></pre></td></tr></table></figure>
key가 되는 객체는 객체의 유일성 여부를 알기 위해 equals(), hashCode() 메서드를 재정의한다.  </li>
</ul>
<p>HashMap 클래스<br>Map 인터페이스를 구현한 클래스 중에서 가장 일반적으로 쓰인다.<br>pair 자료를 쉽고 빠르게 관리할 수 있다.<br>HashTable 클래스는 Vector 처럼 동기화를 제공한다.     </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package collection.hashmap;</span><br><span class="line"></span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Iterator;</span><br><span class="line"></span><br><span class="line">public class MemberHashMap &#123;</span><br><span class="line"></span><br><span class="line">    private HashMap&lt;Integer,Member&gt; hashMap;</span><br><span class="line"></span><br><span class="line">    public MemberHashMap() &#123;</span><br><span class="line">        hashMap &#x3D; new HashMap&lt;Integer, Member&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void addMember(Member member) &#123;</span><br><span class="line">        hashMap.put(member.getMemberId(),member); &#x2F;&#x2F;add가 아닌 put임에 유의, key-value pair가 들어간다.</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean removeMember(int memberId) &#123; &#x2F;&#x2F;key 값을 통해 제거</span><br><span class="line">        if (hashMap.containsKey(memberId)) &#123; &#x2F;&#x2F;containsKey : 해당 key값의 요소가 있는지 체크</span><br><span class="line">            hashMap.remove(memberId); &#x2F;&#x2F;key값으로 제거</span><br><span class="line">            return true;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;회원 번호가 없습니다.&quot;);</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void showAllMember() &#123;</span><br><span class="line">        &#x2F;&#x2F;hashMap.keySet().iterator(); &#x2F;&#x2F;keySey() : 모든 key 객체를 set으로 반환</span><br><span class="line">        &#x2F;&#x2F;hashMap.values().iterator(); &#x2F;&#x2F;values() : 모든 value 객체를 Collection으로 반환</span><br><span class="line"></span><br><span class="line">        Iterator&lt;Integer&gt; ir &#x3D; hashMap.keySet().iterator();</span><br><span class="line">        while (ir.hasNext()) &#123;</span><br><span class="line">            int key &#x3D; ir.next();</span><br><span class="line">            Member member &#x3D; hashMap.get(key); &#x2F;&#x2F;get(key) 해당 key의 value 반환</span><br><span class="line">            System.out.println(member);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package collection.hashmap;</span><br><span class="line"></span><br><span class="line">public class MemberHashMapTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        MemberHashMap manager &#x3D; new MemberHashMap();</span><br><span class="line"></span><br><span class="line">        Member memberLee &#x3D; new Member(100,&quot;Lee&quot;);</span><br><span class="line">        Member memberKim &#x3D; new Member(101,&quot;Kim&quot;);</span><br><span class="line">        Member memberPark &#x3D; new Member(102,&quot;Park&quot;);</span><br><span class="line">        Member memberPark2 &#x3D; new Member(102,&quot;Park&quot;);</span><br><span class="line"></span><br><span class="line">        manager.addMember(memberLee);</span><br><span class="line">        manager.addMember(memberKim);</span><br><span class="line">        manager.addMember(memberPark);</span><br><span class="line">        manager.addMember(memberPark2); &#x2F;&#x2F;key type인 Integer에 이미 equals()와 hashCode()가 재정의 되어있다.</span><br><span class="line">                                        &#x2F;&#x2F;그렇기 때문에 따로 재정의해주지 않아도 안들어간다.</span><br><span class="line"></span><br><span class="line">        manager.showAllMember();</span><br><span class="line"></span><br><span class="line">        manager.removeMember(101);</span><br><span class="line">        manager.showAllMember();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>TreeMap 클래스<br>key 객체를 정렬하여 key-value를 pair로 관리하는 클래스<br>정렬을 위하여 key에 사용되는 클래스에 Comparable 또는 Comparator 인터페이스를 구현   </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package collection.treemap;</span><br><span class="line"></span><br><span class="line">import java.util.Iterator;</span><br><span class="line">import java.util.TreeMap;</span><br><span class="line"></span><br><span class="line">public class MemberTreeMap &#123;</span><br><span class="line"></span><br><span class="line">    TreeMap&lt;Integer,Member&gt; treeMap;</span><br><span class="line"></span><br><span class="line">    public MemberTreeMap() &#123;</span><br><span class="line">        treeMap &#x3D; new TreeMap&lt;Integer, Member&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void addMember(Member member) &#123;</span><br><span class="line">        treeMap.put(member.getMemberId(),member);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean removeMember(int memberId) &#123;</span><br><span class="line">        if (treeMap.containsKey(memberId)) &#123;</span><br><span class="line">            treeMap.remove(memberId);</span><br><span class="line">            return true;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;회원 번호가 없습니다.&quot;);</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void showAllMember() &#123;</span><br><span class="line">        Iterator&lt;Integer&gt; ir &#x3D; treeMap.keySet().iterator();</span><br><span class="line">        while (ir.hasNext()) &#123;</span><br><span class="line">            int key &#x3D; ir.next();</span><br><span class="line">            Member member &#x3D; treeMap.get(key);</span><br><span class="line">            System.out.println(member);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package collection.treemap;</span><br><span class="line"></span><br><span class="line">public class MemberTreeMapTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        MemberTreeMap manager &#x3D; new MemberTreeMap();</span><br><span class="line"></span><br><span class="line">        Member memberLee &#x3D; new Member(200,&quot;Lee&quot;);</span><br><span class="line">        Member memberKim &#x3D; new Member(400,&quot;Kim&quot;);</span><br><span class="line">        Member memberPark &#x3D; new Member(100,&quot;Park&quot;);</span><br><span class="line"></span><br><span class="line">        manager.addMember(memberLee);</span><br><span class="line">        manager.addMember(memberKim);</span><br><span class="line">        manager.addMember(memberPark);</span><br><span class="line"></span><br><span class="line">        manager.showAllMember(); &#x2F;&#x2F;Integer 클래스에서 Comparable가 구현되어 있으므로</span><br><span class="line">                                 &#x2F;&#x2F;따로 구현하지 않더라도 정렬되어있다.</span><br><span class="line"></span><br><span class="line">        manager.removeMember(200);</span><br><span class="line">        manager.showAllMember();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Study</category>
        <category>JAVA OOP</category>
      </categories>
  </entry>
  <entry>
    <title>56. 내부 클래스</title>
    <url>/2020/08/12/hexo_OOP_56/</url>
    <content><![CDATA[<h1 id="객체-지향-프로그래밍"><a href="#객체-지향-프로그래밍" class="headerlink" title="객체 지향 프로그래밍"></a>객체 지향 프로그래밍</h1><h4 id="56-내부-클래스"><a href="#56-내부-클래스" class="headerlink" title="56. 내부 클래스"></a>56. 내부 클래스</h4><ul>
<li>내부 클래스란<br>클래스 내부에 구현된 클래스 (중첩된 클래스)<br>클래스 내부에서 사용하기 위해 선언하고 구현하는 클래스<br>주로 외부 클래스 생성자에서 내부 클래스를 생성   </li>
</ul>
<p>인스턴스 내부 클래스, 정적 내부 클래스   </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package innerclass;</span><br><span class="line"></span><br><span class="line">class Outer &#123;</span><br><span class="line"></span><br><span class="line">    int outNum &#x3D; 100;</span><br><span class="line">    static int sNum &#x3D;200;</span><br><span class="line"></span><br><span class="line">    Runnable getRunnable(int i) &#123; &#x2F;&#x2F;Runnable 한 type의 객체를 반환하는 메서드</span><br><span class="line"></span><br><span class="line">        int num &#x3D; 100; &#x2F;&#x2F;지역변수 i, num</span><br><span class="line">        class MyRunnable implements Runnable &#123; &#x2F;&#x2F;지역 내부 클래스, 메서드 내에 구현되어 있음</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                &#x2F;&#x2F;num +&#x3D; 10; 메서드의 지역변수 변경할 수 없음.</span><br><span class="line">                &#x2F;&#x2F; i &#x3D; 200;  지역 내부 클래스를 포함하는 메서드의 지역변수는 내부적으로 final이 된다..</span><br><span class="line"></span><br><span class="line">                System.out.println(num);</span><br><span class="line">                System.out.println(i);</span><br><span class="line">                System.out.println(outNum);</span><br><span class="line">                System.out.println(sNum);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return new MyRunnable();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class LocalInnerClassTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Outer outer &#x3D; new Outer();</span><br><span class="line">        Runnable runnable &#x3D; outer.getRunnable(30);</span><br><span class="line"></span><br><span class="line">        runnable.run(); &#x2F;&#x2F;getRunnable 메서드는 이미 종료되어 지역변수는 없어져있다.</span><br><span class="line">                        &#x2F;&#x2F;지역 내부 클래스의 메서드(run)은 언제든지 호출될 수 있다.</span><br><span class="line">                        &#x2F;&#x2F;그렇기 때문에 지역 내부 클래스를 포함하는 메서드의 지역변수는 상수(final)가 된다.</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>지역 내부 클래스   </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package innerclass;</span><br><span class="line"></span><br><span class="line">class Outer &#123;</span><br><span class="line"></span><br><span class="line">    int outNum &#x3D; 100;</span><br><span class="line">    static int sNum &#x3D;200;</span><br><span class="line"></span><br><span class="line">    Runnable getRunnable(int i) &#123; &#x2F;&#x2F;Runnable 한 type의 객체를 반환하는 메서드</span><br><span class="line"></span><br><span class="line">        int num &#x3D; 100; &#x2F;&#x2F;지역변수 i, num</span><br><span class="line">        class MyRunnable implements Runnable &#123; &#x2F;&#x2F;지역 내부 클래스, 메서드 내에 구현되어 있음</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                &#x2F;&#x2F;num +&#x3D; 10; 메서드의 지역변수 변경할 수 없음.</span><br><span class="line">                &#x2F;&#x2F; i &#x3D; 200;  지역 내부 클래스를 포함하는 메서드의 지역변수는 내부적으로 final이 된다..</span><br><span class="line"></span><br><span class="line">                System.out.println(num);</span><br><span class="line">                System.out.println(i);</span><br><span class="line">                System.out.println(outNum);</span><br><span class="line">                System.out.println(sNum);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return new MyRunnable();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class LocalInnerClassTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Outer outer &#x3D; new Outer();</span><br><span class="line">        Runnable runnable &#x3D; outer.getRunnable(30);</span><br><span class="line"></span><br><span class="line">        runnable.run(); &#x2F;&#x2F;getRunnable 메서드는 이미 종료되어 지역변수는 없어져있다.</span><br><span class="line">                        &#x2F;&#x2F;지역 내부 클래스의 메서드(run)은 언제든지 호출될 수 있다.</span><br><span class="line">                        &#x2F;&#x2F;그렇기 때문에 지역 내부 클래스를 포함하는 메서드의 지역변수는 상수(final)가 된다.</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>익명 내부 클래스(가장 많이 사용)   </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package innerclass;</span><br><span class="line"></span><br><span class="line">class Outer2 &#123;</span><br><span class="line"></span><br><span class="line">    int outNum &#x3D; 100;</span><br><span class="line">    static int sNum &#x3D;200;</span><br><span class="line"></span><br><span class="line">    Runnable getRunnable(int i) &#123; &#x2F;&#x2F;Runnable 한 type의 객체를 반환하는 메서드</span><br><span class="line"></span><br><span class="line">        int num &#x3D; 100; &#x2F;&#x2F;지역변수 i, num</span><br><span class="line">        return new Runnable() &#123; &#x2F;&#x2F;익명 내부 클래스, 메서드 내부</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                &#x2F;&#x2F;num +&#x3D; 10; 메서드의 지역변수 변경할 수 없음.</span><br><span class="line">                &#x2F;&#x2F; i &#x3D; 200;  지역 내부 클래스를 포함하는 메서드의 지역변수는 내부적으로 final이 된다..</span><br><span class="line"></span><br><span class="line">                System.out.println(num);</span><br><span class="line">                System.out.println(i);</span><br><span class="line">                System.out.println(outNum);</span><br><span class="line">                System.out.println(sNum);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;; &#x2F;&#x2F;익명 내부 클래스 구현 끝 세미콜론</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Runnable runner &#x3D; new Runnable() &#123;  &#x2F;&#x2F;익명 내부 클래스2, 메서드 외부</span><br><span class="line">                                        &#x2F;&#x2F;하나의 인터페이스나 추상클래스에 대해서 상속 또는 구현하는 별개의 클래스를 생성하지 않아도 </span><br><span class="line">                                        &#x2F;&#x2F;바로 이름 없이 생성할 수 있다.</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            System.out.println(&quot;test&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class AnonymousInnerClassTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Outer2 outer &#x3D; new Outer2();</span><br><span class="line">        Runnable runnable &#x3D; outer.getRunnable(30);</span><br><span class="line"></span><br><span class="line">        runnable.run(); </span><br><span class="line">        outer.runner.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Study</category>
        <category>JAVA OOP</category>
      </categories>
  </entry>
  <entry>
    <title>58. 람다식</title>
    <url>/2020/08/12/hexo_OOP_58/</url>
    <content><![CDATA[<h1 id="객체-지향-프로그래밍"><a href="#객체-지향-프로그래밍" class="headerlink" title="객체 지향 프로그래밍"></a>객체 지향 프로그래밍</h1><h4 id="58-람다식"><a href="#58-람다식" class="headerlink" title="58. 람다식"></a>58. 람다식</h4><ul>
<li><p>람다식이란? (java 8 or newer)<br>자바에서 함수형 프로그래밍을 구현하는 방식<br>클래스를 생성하지 않고 함수의 호출만으로 기능 수행 (내부적으로 익명 객체 사용)<br>함수형 인터페이스 선언    </p>
</li>
<li><p>함수형 프로그래밍이란?<br>순수 함수를 구현하고 호출<br>매개변수만 사용하기 때문에 외부에 사이드 이펙트를 주지 않고 병렬 처리 가능<br>안정적인 확장성있는 프로그래밍 방식    </p>
</li>
</ul>
<p>문법</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">InterFace itfc &#x3D; str -&gt; &#123;System.out.println(str);&#125;;</span><br><span class="line">InterFace2 itfc2 &#x3D; (x,y) -&gt; x+y &#x2F;&#x2F;구현부가 return 문 하나라면 return, 중괄호 생략 가능</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package lambda;</span><br><span class="line"></span><br><span class="line">public class TestStringConcat &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        StringConImpl impl &#x3D; new StringConImpl(); &#x2F;&#x2F;객체지향에서는 인터페이스를 구현한 클래스를 사용</span><br><span class="line">        impl.makeString(&quot;hello&quot;,&quot;world&quot;);</span><br><span class="line"></span><br><span class="line">        StringConcat concat &#x3D; (s,v) -&gt; System.out.println(s+&quot; &quot;+v); &#x2F;&#x2F;함수형 프로그래밍, 람다식 사용</span><br><span class="line">        concat.makeString(&quot;hello&quot;,&quot;world&quot;); &#x2F;&#x2F;클래스 구현이 필요없고, 메서드 구현을 따로 만들 필요도 없음.</span><br><span class="line">                                            &#x2F;&#x2F;실제로는 아래처럼 익명 내부클래스로 동작한다.</span><br><span class="line"></span><br><span class="line">        StringConcat concat2 &#x3D; new StringConcat() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void makeString(String str1, String str2) &#123;</span><br><span class="line">                System.out.println(str1+&quot; &quot;+str2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        concat2.makeString(&quot;hello&quot;,&quot;world&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>람다식은 프로그램내에서 변수처럼 사용할 수 있다.     </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package lambda;</span><br><span class="line"></span><br><span class="line">interface PrintString&#123;</span><br><span class="line">    void showString(String str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class TestLambda &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        PrintString lambdaStr &#x3D; str -&gt; System.out.println(str); &#x2F;&#x2F;함수의 구현부가 변수로 대입</span><br><span class="line">        lambdaStr.showString(&quot;Test1&quot;);</span><br><span class="line"></span><br><span class="line">        showMyString(lambdaStr); &#x2F;&#x2F;매개변수로 활용</span><br><span class="line">        PrintString lambdaStr2 &#x3D; returnString(); &#x2F;&#x2F;반환된 구현부를 변수에 대입</span><br><span class="line">        lambdaStr2.showString(&quot;Test3&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void showMyString(PrintString p) &#123;</span><br><span class="line">        p.showString(&quot;Test2&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static PrintString returnString() &#123;</span><br><span class="line">        return str-&gt;System.out.println(str+&quot;!!!&quot;); &#x2F;&#x2F;함수의 구현부를 반환</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Study</category>
        <category>JAVA OOP</category>
      </categories>
  </entry>
  <entry>
    <title>60. 스트림</title>
    <url>/2020/08/12/hexo_OOP_60/</url>
    <content><![CDATA[<h1 id="객체-지향-프로그래밍"><a href="#객체-지향-프로그래밍" class="headerlink" title="객체 지향 프로그래밍"></a>객체 지향 프로그래밍</h1><h4 id="60-스트림"><a href="#60-스트림" class="headerlink" title="60. 스트림"></a>60. 스트림</h4><p>자료의 대상과 관계없이 동일한 연산을 수행할 수 있는 기능(자료의 추상화)<br>배열, 컬렉션에 동일한 연산이 수행되어 일관성 있는 처리 가능<br>한번 생성하고 사용한 스트림은 재사용할 수 없음<br>스트림 연산은 기존 자료를 변경하지 않음<br>중간 연산과 최종 연산으로 구분 됨<br>최종 연산이 수행되어야 모든 연산이 적용되는 지연 연산  </p>
<ul>
<li><p>중간 연산<br>filter(), map()<br>조건에 맞는 요소를 추출하거나 요소를 변환 함<br>문자열의 길이가 5이상인 요소만 출력하기  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sList.stream().filter(s-&gt;s.length()&gt;&#x3D;5).forEach(s-&gt;System.out.println(s));</span><br></pre></td></tr></table></figure>
<p>고객 클래스에서 고객 이름만 가져오기    </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">customerList.stream().map(c-&gt;c.getName()).forEach(s-&gt;System.out.println(s));</span><br></pre></td></tr></table></figure>
</li>
<li><p>최종 연산<br>스트림의 자료를 소모하면서 연산을 수행<br>최종 연산 후에 스트림은 더이상 다른 연산을 적용할 수 없음<br>forEach() : 요소를 하나씩 꺼내 옴<br>count() : 요소의 개수<br>sum() : 요소의 합<br>등 여러 가지 최종 연산이 있음   </p>
</li>
</ul>
<p>배열 스트림</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package stream;</span><br><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">public class IntArrayTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        int[] arr &#x3D; &#123;1,2,3,4,5&#125;;</span><br><span class="line"></span><br><span class="line">        int sum &#x3D; Arrays.stream(arr).sum();</span><br><span class="line">        int count &#x3D; (int)Arrays.stream(arr).count(); &#x2F;&#x2F;썼으니 재생성, long이므로 형변환</span><br><span class="line"></span><br><span class="line">        System.out.println(sum);</span><br><span class="line">        System.out.println(count);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>콜렉션 스트림</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package stream;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line">public class ArrayListStreamTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; sList &#x3D; new ArrayList&lt;String&gt;();</span><br><span class="line">        sList.add(&quot;Tomas&quot;);</span><br><span class="line">        sList.add(&quot;Edward&quot;);</span><br><span class="line">        sList.add(&quot;Jack&quot;);</span><br><span class="line"></span><br><span class="line">        Stream&lt;String&gt; stream &#x3D; sList.stream(); &#x2F;&#x2F;stream 객체 생성</span><br><span class="line">        stream.forEach(s -&gt; System.out.print(s + &quot; &quot;));</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        sList.stream().sorted().forEach(s -&gt; System.out.print(s + &quot; &quot;)); &#x2F;&#x2F;sorted 중간 연산 추가</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        sList.stream().map(s -&gt; s.length()).forEach(n -&gt; System.out.print(n + &quot; &quot;)); &#x2F;&#x2F;map(변환) 중간 연산 추가</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>reduce() 연산<br>정의된 연산이 아닌 프로그래머가 직접 지정하는 연산을 적용<br>최종 연산으로 스트림의 요소를 소모하며 연산 수행     </li>
</ul>
<p>배열의 모든 요소의 합을 구하는 reduce() 연산   </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Arrays.stream(arr).reduce(0,(a,b)-&gt;a+b));</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package stream;</span><br><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.function.BinaryOperator;</span><br><span class="line"></span><br><span class="line">class CompareString implements BinaryOperator&lt;String&gt; &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String apply(String s1, String s2) &#123;</span><br><span class="line">        if(s1.getBytes().length &gt;&#x3D; s2.getBytes().length) &#123;</span><br><span class="line">            return s1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return s2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class ReduceTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        String[] greetings &#x3D; &#123;&quot;안녕하세요&quot;,&quot;hello&quot;,&quot;Good Morning&quot;,&quot;반갑습니다&quot;&#125;;</span><br><span class="line"></span><br><span class="line">        System.out.println(Arrays.stream(greetings).reduce(&quot;&quot;,(s1,s2) -&gt; &#123;</span><br><span class="line">            if(s1.getBytes().length &gt;&#x3D; s2.getBytes().length) &#123;</span><br><span class="line">                return s1;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return s2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;));</span><br><span class="line">        &#x2F;&#x2F;람다식 대신 BinaryOperator가 구현된 클래스를 사용</span><br><span class="line">        System.out.println(Arrays.stream(greetings).reduce(new CompareString()).get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Study</category>
        <category>JAVA OOP</category>
      </categories>
  </entry>
  <entry>
    <title>63. 예외와 예외 처리</title>
    <url>/2020/08/12/hexo_OOP_63/</url>
    <content><![CDATA[<h1 id="객체-지향-프로그래밍"><a href="#객체-지향-프로그래밍" class="headerlink" title="객체 지향 프로그래밍"></a>객체 지향 프로그래밍</h1><h4 id="63-예외와-예외-처리"><a href="#63-예외와-예외-처리" class="headerlink" title="63. 예외와 예외 처리"></a>63. 예외와 예외 처리</h4><p>컴파일 오류 : 프로그램 코드 작성 중 발생하는 문법적 오류<br>실행 오류 : 실행중인 프로그램이 의도치 않은 동작을 하거나(bug) 프로그램이 중단되는 오류(runtime error)<br>자바는 예외 처리를 통하여 프로그램의 비정상 종료를 막고 log를 남길 수 있음    </p>
<p>시스템 오류(error) : 가상 머신에서 발생, 프로그래머가 처리할 수 없음<br>동적 메모리를 다 사용한 경우, stack over flow 등<br>예외(Exception) : 프로그램에서 제어할 수 있는 오류<br>읽으려는 파일이 없는 경우, 네트웍이나 소켓 연결 오류 등<br>자바 프로그램에서는 예외에 대한 처리를 수행 함</p>
<p>Exception 클레스 : 모든 예외 클래스의 최상위 클래스<br>IOException, RuntimeException 등     </p>
<p>try~catch 문으로 예외처리하기<br>try {<br>예외가 발생할 수 있는 동작<br>} catch(처리할 예외 타입 e) {<br>try블록 안에서 예외가 발생했을 때 수행되는 부분<br>}  </p>
<p>try {<br>예외가 발생할 수 있는 동작<br>} catch(처리할 예외 타입 e) {<br>try블록 안에서 예외가 발생했을 때 수행되는 부분<br>} finally {<br>예외 발생 여부와 상관 없이 항상 수행되는 부분<br>리소스를 정리하는 코드를 주로 쓴다<br>}  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package exception;</span><br><span class="line"></span><br><span class="line">public class ArrayExceptionTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        int[] arr &#x3D; new int[5];</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            for (int i &#x3D; 0; i &lt;&#x3D; 5; i++) &#123;</span><br><span class="line">                System.out.println(arr[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;catch(ArrayIndexOutOfBoundsException e) &#123; &#x2F;&#x2F;IDE가 잡아주지 않으므로 직접 써야함</span><br><span class="line">            System.out.println(e);</span><br><span class="line">            System.out.println(&quot;예외 처리&quot;);</span><br><span class="line">        &#125; &#x2F;&#x2F;예외만 처리되고 프로그램은 계속 수행됨</span><br><span class="line">        System.out.println(&quot;프로그램 종료&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>finally<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package exception;</span><br><span class="line"></span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileNotFoundException;</span><br><span class="line"></span><br><span class="line">public class ExceptionTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        FileInputStream fis &#x3D; null;</span><br><span class="line">        System.out.println(new File(&quot;&quot;).getAbsolutePath()); &#x2F;&#x2F;working directory 확인</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            fis &#x3D; new FileInputStream(&quot;IdeaProjects&#x2F;Chapter13&#x2F;a.txt&quot;);</span><br><span class="line">        &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">            &#x2F;&#x2F;return;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                fis.close(); &#x2F;&#x2F;stream을 close하는 작업을 진행해야되므로</span><br><span class="line">                System.out.println(&quot;finally&quot;);</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                System.out.println(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;end&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>try<del>with</del>resources 문 (java 7)<br>리소스를 자동으로 해제하도록 제공해주는 구문<br>해당 리소스가 AutoCloseable(인터페이스)을 구현한 경우 close()를 명시적으로 호출하지 않아도<br>try{}블록에서 오픈된 리소스는 정상적인 경우나 예외가 발생한 경우 모두 자동으로 close()가 호출 됨    </p>
<p>FileInputStream의 경우 AutoCloseable이 구현되어 있음  </p>
<p>AutoCloseable를 구현한 클래스 생성</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package exception;</span><br><span class="line"></span><br><span class="line">public class AutoCloseObject implements AutoCloseable&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void close() throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;close()가 호출되었습니다.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>해당 클래스 예외 처리</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package exception;</span><br><span class="line"></span><br><span class="line">public class AutoCloseTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        try(AutoCloseObject obj &#x3D; new AutoCloseObject()) &#123;</span><br><span class="line">            throw new Exception(); &#x2F;&#x2F;exception 강제 발생</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125; &#x2F;&#x2F;close() 를 명시적으로 호출하지 않지만 내부적으로는 호출 됨</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>향상된 try-with-resources 문 (java 9)   </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package exception;</span><br><span class="line"></span><br><span class="line">public class AutoCloseTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        AutoCloseObject obj &#x3D; new AutoCloseObject();</span><br><span class="line">        </span><br><span class="line">        try(obj) &#123; &#x2F;&#x2F;선언할 필요 없이 미리 생성된 객체 사용가능 </span><br><span class="line">            throw new Exception();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Study</category>
        <category>JAVA OOP</category>
      </categories>
  </entry>
  <entry>
    <title>65. 다양한 예외 처리</title>
    <url>/2020/08/12/hexo_OOP_65/</url>
    <content><![CDATA[<h1 id="객체-지향-프로그래밍"><a href="#객체-지향-프로그래밍" class="headerlink" title="객체 지향 프로그래밍"></a>객체 지향 프로그래밍</h1><h4 id="65-다양한-예외-처리"><a href="#65-다양한-예외-처리" class="headerlink" title="65. 다양한 예외 처리"></a>65. 다양한 예외 처리</h4><ul>
<li>예외 처리 미루기<br>throws를 이용하여 예외처리 미루기<br>try{} 블록으로 예외처리 하지 않고, 메서드 선언부에 throws를 추가<br>예외가 발생한 메서드에서 예외처리를 하지 않고 메서드를 호출한 곳에서 예외처리함<br>main()에서 throws를 사용하면 가상 머신에서 처리 됨  </li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package exception;</span><br><span class="line"></span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileNotFoundException;</span><br><span class="line"></span><br><span class="line">public class ThrowsException &#123;</span><br><span class="line"></span><br><span class="line">    public Class loadClass(String fileName, String className) throws FileNotFoundException, ClassNotFoundException &#123; &#x2F;&#x2F;throws로 미루기</span><br><span class="line"></span><br><span class="line">        FileInputStream fis &#x3D; new FileInputStream(fileName);</span><br><span class="line">        Class c &#x3D; Class.forName(className);</span><br><span class="line">        return c;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        ThrowsException test &#x3D; new ThrowsException();</span><br><span class="line">        try &#123;</span><br><span class="line">            test.loadClass(&quot;IdeaProjects&#x2F;Chapter13&#x2F;a.txt&quot;,&quot;java.lang.String&quot;); &#x2F;&#x2F;loadClass에 대한 try~catch문 필요</span><br><span class="line">        &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;end&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>다중 예외 처리<br>하나의 try{} 블록에서 여러 예외가 발생하는 경우<br>하나의 catch{} 블록에서 예외 처리 하거나<br>여러 catch{} 블록으로 나누어 처리할 수 있음<br>이때, 최상위 예외 클래스인 Exception 클래스는 가장 마지막 블록에 위치해야 함  </li>
</ul>
<p>하나의 catch{} 블록에서 처리     </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package exception;</span><br><span class="line"></span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileNotFoundException;</span><br><span class="line"></span><br><span class="line">public class ThrowsException &#123;</span><br><span class="line"></span><br><span class="line">    public Class loadClass(String fileName, String className) throws FileNotFoundException, ClassNotFoundException &#123; &#x2F;&#x2F;throws로 미루기</span><br><span class="line"></span><br><span class="line">        FileInputStream fis &#x3D; new FileInputStream(fileName);</span><br><span class="line">        Class c &#x3D; Class.forName(className);</span><br><span class="line">        return c;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        ThrowsException test &#x3D; new ThrowsException();</span><br><span class="line">        try &#123;</span><br><span class="line">            test.loadClass(&quot;IdeaProjects&#x2F;Chapter13&#x2F;a.txt&quot;,&quot;java.lang.string&quot;);</span><br><span class="line">        &#125; catch (FileNotFoundException | ClassNotFoundException e) &#123; &#x2F;&#x2F;두개의 예외를 같이 처리</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;end&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>여러 catch{}블록에서 처리 및 디폴트 Exception   </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package exception;</span><br><span class="line"></span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileNotFoundException;</span><br><span class="line"></span><br><span class="line">public class ThrowsException &#123;</span><br><span class="line"></span><br><span class="line">    public Class loadClass(String fileName, String className) throws FileNotFoundException, ClassNotFoundException &#123; &#x2F;&#x2F;throws로 미루기</span><br><span class="line"></span><br><span class="line">        FileInputStream fis &#x3D; new FileInputStream(fileName);</span><br><span class="line">        Class c &#x3D; Class.forName(className);</span><br><span class="line">        return c;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        ThrowsException test &#x3D; new ThrowsException();</span><br><span class="line">        try &#123;</span><br><span class="line">            test.loadClass(&quot;IdeaProjects&#x2F;Chapter13&#x2F;a.txt&quot;,&quot;java.lang.String&quot;);</span><br><span class="line">        &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125; catch (Exception e) &#123; &#x2F;&#x2F;그 외 다른 예외 처리(디폴트 익셉션), 항상 마지막 catch&#123;&#125; 블록에서..</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;end&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>사용자 정의 예외<br>JDK에서 제공하는 예외 클래스 외에 사용자의 필요에 의해 예외 클래스를 정의하여 사용<br>기존 JDK클래스에서 상속받아 예외 클래스 생성  </li>
</ul>
<p>사용자 정의 예외 연습<br>(id가 null 이거나 8자이하 20자 이상인 경우 예외 처리)    </p>
<p>예외 클래스 생성</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class IDFormatException extends Exception &#123;</span><br><span class="line">    public IDFormatException(String message) &#123; &#x2F;&#x2F;생성자의 매개변수로 예외 상황 메세지 받음    </span><br><span class="line">    super(massage);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>사용자 정의 예외 사용 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package exception;</span><br><span class="line"></span><br><span class="line">public class IDFormatTest &#123;</span><br><span class="line"></span><br><span class="line">    private String userID;</span><br><span class="line"></span><br><span class="line">    public String getUserID() &#123;</span><br><span class="line">        return userID;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setUserID(String userID) throws IDFormatException &#123; &#x2F;&#x2F;예외처리 미루기 </span><br><span class="line">        if (userID &#x3D;&#x3D; null) &#123;</span><br><span class="line">            throw new IDFormatException(&quot;아이디는 null일 수 없습니다.&quot;); &#x2F;&#x2F;throws는 미루기 throw는 발생</span><br><span class="line">        &#125; else if (userID.length() &lt;8 || userID.length() &gt; 20) &#123;</span><br><span class="line">            throw new IDFormatException(&quot;아이디는 8자 이상 20자 이하로 쓰세요.&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            this.userID &#x3D; userID;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        IDFormatTest idTest &#x3D; new IDFormatTest();</span><br><span class="line"></span><br><span class="line">        String myID &#x3D; &quot;tuna&quot;;</span><br><span class="line"></span><br><span class="line">        try &#123; &#x2F;&#x2F;사용하는 곳에서 예외 처리  </span><br><span class="line">            idTest.setUserID(myID);</span><br><span class="line">        &#125; catch (IDFormatException e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        myID &#x3D; null;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            idTest.setUserID(myID);</span><br><span class="line">        &#125; catch (IDFormatException e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Study</category>
        <category>JAVA OOP</category>
      </categories>
  </entry>
  <entry>
    <title>66. 자바 입출력 스트림</title>
    <url>/2020/08/12/hexo_OOP_66/</url>
    <content><![CDATA[<h1 id="객체-지향-프로그래밍"><a href="#객체-지향-프로그래밍" class="headerlink" title="객체 지향 프로그래밍"></a>객체 지향 프로그래밍</h1><h4 id="66-자바-입출력-스트림"><a href="#66-자바-입출력-스트림" class="headerlink" title="66. 자바 입출력 스트림"></a>66. 자바 입출력 스트림</h4><ul>
<li>입출력 스트림 이란<br>네트웍에서 자료의 흐름이 물과 같다는 의미에서 유래<br>다양한 입출력 장치에 독립적으로 일관성 있는 입출력 방식 제공<br>입출력이 구현되는 곳에서는 모두 I/O 스트림을 사용<br>:키보드, 파일, 디스크, 메모리 등  </li>
</ul>
<p>구분<br>I/O 대상 기준 : 입력 스트림, 출력 스트림<br>자료의 종류 : 바이트 스트림, 문자 스트림<br>스트림의 기능 : 기반 스트림, 보조 스트림    </p>
<ul>
<li><p>입력 or 출력 스트림<br>입력 스트림 : 대상으로 부터 자료를 읽어 들이는 스트림<br>ex) FileInputStream(바이트), FileReader(문자), BufferedInputStream(보조), BufferedReader, etc<br>출력 스트림 : 대상으로 자료를 출력하는 스트림<br>ex) FileOutputStream, FileWriter, BufferedOutputStream, BufferedWriter, etc   </p>
</li>
<li><p>바이트 or 문자 단위 스트림<br>바이트 단위 스트림 : 바이트 단위로 자료를 읽고 씀 (동영상, 음악 등)<br>ex) ~Stream<br>문자 단위 스트림 : 문자는 2byte이상씩 처리해야 함<br>ex) ~Reader, ~Writer</p>
</li>
<li><p>기반 or 보조 스트림<br>기반 스트림 : 대상에 직접 자료를 읽고 쓰는 기능의 스트림<br>ex) File~<br>보조 스트림 : 직접 읽고 쓰는 기능은 없고 추가적인 기능을 제공해 주는 스트림<br>기반 스트림이나 또 다른 보조 스트림을 생성자의 매개변수로 포함한다<br>ex) Buffered~, InputStreamReader, OutputStreamWriter</p>
</li>
<li><p>표준 입출력<br>System 클래스의 표준 입출력 멤버</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public Class System &#123;   </span><br><span class="line">    public static PrintStream out; &#x2F;&#x2F;표준 출력 스트림</span><br><span class="line">    public static InputStream in;  &#x2F;&#x2F;표준 입력 스트림</span><br><span class="line">    public static PrintStream err; &#x2F;&#x2F;표준 에러 스트림</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>System.in 사용하여 입력 받기<br>한 바이트 씩 읽어 들임<br>한글과 같은 여러 바이트로 된 문자를 읽기 위해서는<br>InPutStreamReader와 같은 보조 스트림을 사용해야 함    </p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package stream.inputstream;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStreamReader;</span><br><span class="line"></span><br><span class="line">public class SystemInTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;입력&quot;);</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            int i;</span><br><span class="line">            while ((i &#x3D; System.in.read()) !&#x3D; &#39;\n&#39;) &#123;</span><br><span class="line">                System.out.print((char)i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;입력 후 &#39;끝&#39; 이라고 쓰세요.&quot;);</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            int i;</span><br><span class="line">            InputStreamReader isr &#x3D; new InputStreamReader(System.in); &#x2F;&#x2F;byte -&gt; 문자, 다른 스트림을 생성자의 매개변수로 받음</span><br><span class="line">            while ((i &#x3D; isr.read()) !&#x3D; &#39;끝&#39;) &#123; &#x2F;&#x2F;&#39;끝&#39;은 2byte 이기 때문에 보조 스트림 필요</span><br><span class="line">                System.out.print((char)i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Scanner 클래스<br>java.util 패키지에 있는 입력 클래스<br>문자뿐 아니라 정수, 실수 등 다양한 자료형을 읽을 수 있음<br>생성자가 다양하여 여러 소스로부터 자료를 읽을 수 있음  </li>
</ul>
<p>Scanner(File source) : 파일을 매개변수로 받아 Scanner 생성<br>Scanner(InputStream source) : 바이트 스트림을 매개변수로 받아 Scanner 생성<br>Scanner(String source) : String을 매개변수로 받아 Scanner 생성    </p>
<ul>
<li>Console 클래스<br>System.in 을 사용하지 않고 콘솔에서(cmd,terminal) 표준 입출력이 가능<br>readLine() : 문자열을 읽습니다.<br>readPassword() : 사용자에게 문자열을 보여주지 않고 읽습니다<br>reader() : Reader 클래스를 반환<br>writer() : PrintWriter 클래스를 반환  </li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package stream.inputstream;</span><br><span class="line"></span><br><span class="line">import java.io.Console;</span><br><span class="line"></span><br><span class="line">public class ConsoleTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        Console console &#x3D; System.console();</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;이름&quot;);</span><br><span class="line">        String name &#x3D; console.readLine();</span><br><span class="line">        System.out.println(&quot;비밀 번호&quot;);</span><br><span class="line">        char[] password &#x3D; console.readPassword();</span><br><span class="line"></span><br><span class="line">        System.out.println(name);</span><br><span class="line">        System.out.println(password);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Study</category>
        <category>JAVA OOP</category>
      </categories>
  </entry>
  <entry>
    <title>68. 바이트 단위, 문자 단위 입출력 스트림</title>
    <url>/2020/08/12/hexo_OOP_68/</url>
    <content><![CDATA[<h1 id="객체-지향-프로그래밍"><a href="#객체-지향-프로그래밍" class="headerlink" title="객체 지향 프로그래밍"></a>객체 지향 프로그래밍</h1><h4 id="68-바이트-단위-문자-단위-입출력-스트림"><a href="#68-바이트-단위-문자-단위-입출력-스트림" class="headerlink" title="68. 바이트 단위, 문자 단위 입출력 스트림"></a>68. 바이트 단위, 문자 단위 입출력 스트림</h4><ul>
<li>바이트 단위 스트림<br>InputStream : 바이트 단위 입력 스트림 최상위 클래스<br>OutputStrem : 바이트 단위 출력 스트림 최상위 클래스     </li>
</ul>
<p>추상 메서드를 포함한 추상클래스로 하위 클래스가 구현하여 사용<br>주요 하위 클래스<br>FileInputStream, ByteArrayInputStream, FilterInputStream, etc<br>FileOutputStream, ByteArrayOutputStream, FilterOutputStream, etc</p>
<ul>
<li>FileInputStream, FileOutputStream 사용하기<br>파일에 한 바이트 씩 자료를 읽고 쓰는데 사용<br>입력 스트림은 파일이 없을 때 예외 발생<br>출력 스트림은 파일이 없는 경우 새로 파일을 생성하여 출력   </li>
</ul>
<p>FileInputStream</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package stream.inputstream;</span><br><span class="line"></span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">public class FileInputTest1 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        FileInputStream fis &#x3D; null;</span><br><span class="line">        try &#123;</span><br><span class="line">            fis &#x3D; new FileInputStream(&quot;IdeaProjects&#x2F;Chapter14&#x2F;input.txt&quot;);</span><br><span class="line">            int i;</span><br><span class="line">            while ( (i &#x3D; fis.read()) !&#x3D; -1 ) &#123; &#x2F;&#x2F;-1이 return 될 경우 끝이므로</span><br><span class="line">                System.out.print((char)i);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                fis.close();</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;end&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>FileInputStream &amp; try-with-resources</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package stream.inputstream;</span><br><span class="line"></span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">public class FileInputTest2 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        try (FileInputStream fis &#x3D; new FileInputStream(&quot;IdeaProjects&#x2F;Chapter14&#x2F;input.txt&quot;))&#123; &#x2F;&#x2F;AutoCloseable</span><br><span class="line">            int i;</span><br><span class="line">            while ( (i &#x3D; fis.read()) !&#x3D; -1 ) &#123;</span><br><span class="line">                System.out.print((char)i);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;end&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>FileInputStream &amp; byte[]로 읽기</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package stream.inputstream;</span><br><span class="line"></span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">public class FileInputTest3 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        try (FileInputStream fis &#x3D; new FileInputStream(&quot;IdeaProjects&#x2F;Chapter14&#x2F;input2.txt&quot;))&#123; &#x2F;&#x2F;AutoCloseable</span><br><span class="line">            int i;</span><br><span class="line">            byte[] bs &#x3D; new byte[10];</span><br><span class="line">            while ( (i &#x3D; fis.read(bs)) !&#x3D; -1 ) &#123; &#x2F;&#x2F;i:읽은 개수</span><br><span class="line">                for (int k&#x3D;0; k&lt;i; k++) &#123;</span><br><span class="line">                    System.out.print((char)bs[k]);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>FileOutputStream</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package stream.outputstream;</span><br><span class="line"></span><br><span class="line">import java.io.FileOutputStream;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">public class FileOutputTest1 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        try(FileOutputStream fos &#x3D; new FileOutputStream(&quot;output.txt&quot;,true)) &#123; &#x2F;&#x2F;append : 이어쓰기</span><br><span class="line">            fos.write(65); &#x2F;&#x2F;ABC 숫자를 넣었지만 문자로 출력</span><br><span class="line">            fos.write(66);</span><br><span class="line">            fos.write(67);</span><br><span class="line"></span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>FileOutputStream &amp; FileInputStream </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package stream.outputstream;</span><br><span class="line"></span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileOutputStream;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">public class FileOutputTest2 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        byte[] bs &#x3D; new byte[26];</span><br><span class="line">        byte data &#x3D; 65;</span><br><span class="line">        for (int i &#x3D; 0; i&lt;bs.length; i++) &#123;</span><br><span class="line">            bs[i] &#x3D; data;</span><br><span class="line">            data++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        try(FileOutputStream fos &#x3D; new FileOutputStream(&quot;alpha.txt&quot;,true);</span><br><span class="line">            FileInputStream fis &#x3D; new FileInputStream(&quot;alpha.txt&quot;)) &#123;</span><br><span class="line"></span><br><span class="line">            fos.write(bs);</span><br><span class="line">            int ch;</span><br><span class="line">            while ((ch &#x3D; fis.read()) !&#x3D; -1) &#123;</span><br><span class="line">                System.out.print((char)ch);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>문자 단위 스트림<br>Reader : 문자 단위로 읽는 최상위 스트림<br>Writer : 문자 단위로 쓰는 최상위 스트림<br>추상 메서드를 포함한 추상클래스로 하위 클래스가 구현하여 사용<br>주요 하위 클래스<br>FileReader, InputStreamReader, BufferedReader, etc<br>FileWriter, OutputStreamWriter, BufferedWriter, etc     </p>
</li>
<li><p>FileReader와 FileWriter<br>파일에 문자를 읽고 쓸때 가장 많이 사용하는 클래스<br>문자의 인코딩 방식을 지정할 수 있음    </p>
</li>
</ul>
<p>바이트 단위 스트림과의 비교</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package stream.reader;</span><br><span class="line"></span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileReader;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStreamReader;</span><br><span class="line"></span><br><span class="line">public class FileReaderTest &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line"></span><br><span class="line">        FileInputStream fis &#x3D; new FileInputStream(&quot;IdeaProjects&#x2F;Chapter14&#x2F;reader.txt&quot;); &#x2F;&#x2F;byte단위 스트림</span><br><span class="line">        int i;</span><br><span class="line">        while ((i &#x3D; fis.read()) !&#x3D; -1) &#123;</span><br><span class="line">            System.out.print((char)i); &#x2F;&#x2F;byte단위이기 때문에 한글 깨짐</span><br><span class="line">        &#125;</span><br><span class="line">        fis.close();</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line">        fis &#x3D; new FileInputStream(&quot;IdeaProjects&#x2F;Chapter14&#x2F;reader.txt&quot;);</span><br><span class="line">        InputStreamReader isr &#x3D; new InputStreamReader(fis); &#x2F;&#x2F;보조 스트림 사용 (byte -&gt; 문자)</span><br><span class="line">        int k;</span><br><span class="line">        while ((k &#x3D; isr.read()) !&#x3D; -1) &#123;</span><br><span class="line">            System.out.print((char)k);</span><br><span class="line">        &#125;</span><br><span class="line">        isr.close();</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        FileReader fr &#x3D; new FileReader(&quot;IdeaProjects&#x2F;Chapter14&#x2F;reader.txt&quot;); &#x2F;&#x2F;문자 단위 스트림</span><br><span class="line">        int j;</span><br><span class="line">        while ((j &#x3D; fr.read()) !&#x3D; -1) &#123;</span><br><span class="line">            System.out.print((char)j);</span><br><span class="line">        &#125;</span><br><span class="line">        fr.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>FileWriter &amp; FileReader</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package stream.writer;</span><br><span class="line"></span><br><span class="line">import java.io.FileReader;</span><br><span class="line">import java.io.FileWriter;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">public class FileWriterTest &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line"></span><br><span class="line">        FileWriter fw &#x3D; new FileWriter(&quot;IdeaProjects&#x2F;Chapter14&#x2F;writer.txt&quot;);</span><br><span class="line"></span><br><span class="line">        fw.write(&#39;A&#39;);</span><br><span class="line"></span><br><span class="line">        char[] cArr &#x3D; &#123;&#39;B&#39;,&#39;C&#39;,&#39;D&#39;,&#39;E&#39;,&#39;F&#39;&#125;;</span><br><span class="line">        fw.write(cArr);</span><br><span class="line">        fw.write(cArr,2,2); &#x2F;&#x2F;DE</span><br><span class="line"></span><br><span class="line">        String str &#x3D; &quot;안녕하세요.&quot;;</span><br><span class="line">        fw.write(str);</span><br><span class="line">        fw.close();</span><br><span class="line"></span><br><span class="line">        FileReader fr &#x3D; new FileReader(&quot;IdeaProjects&#x2F;Chapter14&#x2F;writer.txt&quot;);</span><br><span class="line">        int i;</span><br><span class="line">        while ((i&#x3D;fr.read()) !&#x3D; -1) &#123;</span><br><span class="line">            System.out.print((char)i);</span><br><span class="line">        &#125;</span><br><span class="line">        fr.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Study</category>
        <category>JAVA OOP</category>
      </categories>
  </entry>
  <entry>
    <title>70. 보조 스트림</title>
    <url>/2020/08/12/hexo_OOP_70/</url>
    <content><![CDATA[<h1 id="객체-지향-프로그래밍"><a href="#객체-지향-프로그래밍" class="headerlink" title="객체 지향 프로그래밍"></a>객체 지향 프로그래밍</h1><h4 id="70-보조-스트림"><a href="#70-보조-스트림" class="headerlink" title="70. 보조 스트림"></a>70. 보조 스트림</h4><p>실제 읽고 쓰는 스트림이 아닌 보조적인 기능을 추가하는 스트림<br>데코레이터라고도 불린다<br>상위 클래스 FilterInputStream, FilterOutputStream<br>생성자의 매개변수로 다른 스트림을 가진다</p>
<p>데코레이터 패턴(Decorator Pattern)<br>기반 스트림 &gt; 보조 스트림1 &gt; 보조 스트림2  </p>
<p>Buffered 스트림 : 내부에 8192바이트 배열을 가지고 있음, 읽거나 쓸때 속도가 빠름    </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private static int DEFAULT_BUFFER_SIZE &#x3D; 8192;</span><br></pre></td></tr></table></figure>

<p>Buffered 스트림을 이용하여 파일 복사</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package stream.decorator;</span><br><span class="line"></span><br><span class="line">import java.io.*;</span><br><span class="line">&#x2F;&#x2F;import java.net.Socket;</span><br><span class="line">&#x2F;&#x2F;import java.nio.Buffer;</span><br><span class="line"></span><br><span class="line">public class FileCopy &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line"></span><br><span class="line">        long milliseconds &#x3D; 0;</span><br><span class="line"></span><br><span class="line">        try(FileInputStream fis &#x3D; new FileInputStream(&quot;IdeaProjects&#x2F;Chapter14&#x2F;alpha.txt&quot;);</span><br><span class="line">            FileOutputStream fos &#x3D; new FileOutputStream(&quot;IdeaProjects&#x2F;Chapter14&#x2F;copy.txt&quot;);</span><br><span class="line">            BufferedInputStream bis &#x3D; new BufferedInputStream(fis); &#x2F;&#x2F;더 빠르게 처리하기 위해 데코레이터 사용</span><br><span class="line">            BufferedOutputStream bos &#x3D; new BufferedOutputStream(fos)) &#123;</span><br><span class="line"></span><br><span class="line">            milliseconds &#x3D; System.currentTimeMillis(); &#x2F;&#x2F;현재시간</span><br><span class="line"></span><br><span class="line">            int i;</span><br><span class="line">            while ((i&#x3D;bis.read()) !&#x3D; -1) &#123;</span><br><span class="line">                bos.write(i); &#x2F;&#x2F;while 동안 한 바이트씩 읽어서 바로 쓰기</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            milliseconds &#x3D; System.currentTimeMillis() - milliseconds; &#x2F;&#x2F;시간차 계산</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(milliseconds);</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;Socket socket &#x3D; new Socket();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;BufferedReader isr &#x3D; new BufferedReader(new InputStreamReader(socket.getInputStream())); &#x2F;&#x2F;byte-&gt;문자 보조에 추가로 버퍼기능까지</span><br><span class="line">        &#x2F;&#x2F;isr.readLine();&#x2F;&#x2F;BufferedReader에만 있는 메서드, 한줄만 읽는 기능(&#x2F;n 까지)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DataInputStream/DataOutputStream : 자료가 저장된 상태 그대로 자료형을 유지하며 읽거나 쓰는 기능을 제공하는 스트림    </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package stream.decorator;</span><br><span class="line"></span><br><span class="line">import java.io.*;</span><br><span class="line"></span><br><span class="line">public class DataStreamTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        try(FileOutputStream fos &#x3D; new FileOutputStream(&quot;IdeaProjects&#x2F;Chapter14&#x2F;data.txt&quot;);</span><br><span class="line">            DataOutputStream dos &#x3D; new DataOutputStream(fos);</span><br><span class="line">            FileInputStream fis &#x3D; new FileInputStream(&quot;IdeaProjects&#x2F;Chapter14&#x2F;data.txt&quot;);</span><br><span class="line">            DataInputStream dis &#x3D; new DataInputStream(fis)) &#123;</span><br><span class="line"></span><br><span class="line">            dos.writeByte(100); &#x2F;&#x2F;한 바이트로 씀</span><br><span class="line">            dos.write(100); &#x2F;&#x2F;4 바이트로 씀</span><br><span class="line">            dos.writeChar(&#39;A&#39;);</span><br><span class="line">            dos.writeUTF(&quot;안녕하세요&quot;);</span><br><span class="line"></span><br><span class="line">            System.out.println(dis.readByte()); &#x2F;&#x2F;쓴 방식대로 읽어야 한다 </span><br><span class="line">            System.out.println(dis.read());</span><br><span class="line">            System.out.println(dis.readChar());</span><br><span class="line">            System.out.println(dis.readUTF());</span><br><span class="line"></span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Study</category>
        <category>JAVA OOP</category>
      </categories>
  </entry>
  <entry>
    <title>71. 직렬화</title>
    <url>/2020/08/12/hexo_OOP_71/</url>
    <content><![CDATA[<h1 id="객체-지향-프로그래밍"><a href="#객체-지향-프로그래밍" class="headerlink" title="객체 지향 프로그래밍"></a>객체 지향 프로그래밍</h1><h4 id="71-직렬화"><a href="#71-직렬화" class="headerlink" title="71. 직렬화"></a>71. 직렬화</h4><p>인스턴스의 상태를 그대로 저장하거나 네트웍으로 전송하고 이를 다시 복원하는 방식<br>ObjectInputStream, ObjectOutputStream 보조스트림 사용  </p>
<p>Serializable 인터페이스<br>직렬화는 인스턴스의 내용이 외부로 유출되는 것이므로 프로그래머가 객체의 직렬화 가능 여부를 명시함<br>구현 코드가 없는 마크 인터페이스  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package stream.serialization;</span><br><span class="line"></span><br><span class="line">import java.io.*;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; class Person implements Externalizable &#123; &#x2F;&#x2F;직렬화가능하며 구현해야할 기능이 있음  </span><br><span class="line">class Person implements Serializable &#123; &#x2F;&#x2F;직렬화가능하다는 마크 인터페이스 </span><br><span class="line">    String name;</span><br><span class="line">    transient String job; &#x2F;&#x2F;직렬화 제외 키워드</span><br><span class="line"></span><br><span class="line">    public Person(String name, String job) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">        this.job &#x3D; job;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return name + &quot;,&quot; + job;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class SerializationTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        Person personLee &#x3D; new Person(&quot;이순신&quot;,&quot;엔지니어&quot;);</span><br><span class="line">        Person personKim &#x3D; new Person(&quot;김유신&quot;,&quot;선생님&quot;);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;객체 파일 생성</span><br><span class="line">        try (FileOutputStream fos &#x3D; new FileOutputStream(&quot;IdeaProjects&#x2F;Chapter14&#x2F;serial.dat&quot;);</span><br><span class="line">             ObjectOutputStream oos &#x3D; new ObjectOutputStream(fos)) &#123;</span><br><span class="line">            oos.writeObject(personLee);</span><br><span class="line">            oos.writeObject(personKim);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;객체 파일 읽기</span><br><span class="line">        try (FileInputStream fis &#x3D; new FileInputStream(&quot;IdeaProjects&#x2F;Chapter14&#x2F;serial.dat&quot;);</span><br><span class="line">        ObjectInputStream ois &#x3D; new ObjectInputStream(fis)) &#123;</span><br><span class="line">            Person p1 &#x3D; (Person) ois.readObject();</span><br><span class="line">            Person p2 &#x3D; (Person) ois.readObject();</span><br><span class="line"></span><br><span class="line">            System.out.println(p1);</span><br><span class="line">            System.out.println(p2);</span><br><span class="line"></span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Study</category>
        <category>JAVA OOP</category>
      </categories>
  </entry>
  <entry>
    <title>72. 그 외 입출력 클래스와 데코레이터 패턴</title>
    <url>/2020/08/12/hexo_OOP_72/</url>
    <content><![CDATA[<h1 id="객체-지향-프로그래밍"><a href="#객체-지향-프로그래밍" class="headerlink" title="객체 지향 프로그래밍"></a>객체 지향 프로그래밍</h1><h4 id="72-그-외-입출력-클래스와-데코레이터-패턴"><a href="#72-그-외-입출력-클래스와-데코레이터-패턴" class="headerlink" title="72. 그 외 입출력 클래스와 데코레이터 패턴"></a>72. 그 외 입출력 클래스와 데코레이터 패턴</h4><ul>
<li><p>File 클래스<br>파일 개념을 추상화한 클래스<br>입출력 기능은 없고 파일의 속성, 경로, 이름 등을 알 수 있음     </p>
</li>
<li><p>RandomAccessFile 클래스<br>입출력 클래스 중 유일하게 파일 입출력을 동시에 할 수 있는 클래스<br>파일 포인터가 있어서 읽고 쓰는 위치의 이동이 가능함<br>다양한 자료형에 대한 메서드가 제공됨    </p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package stream.others;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.RandomAccessFile;</span><br><span class="line"></span><br><span class="line">public class RandomAccessFileTest &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line"></span><br><span class="line">        RandomAccessFile rf &#x3D; new RandomAccessFile(&quot;IdeaProjects&#x2F;Chapter14&#x2F;random.txt&quot;,&quot;rw&quot;);</span><br><span class="line"></span><br><span class="line">        rf.writeInt(100);</span><br><span class="line">        System.out.println(rf.getFilePointer()); &#x2F;&#x2F;현재 포인터 위치</span><br><span class="line">        rf.writeDouble(3.14);</span><br><span class="line">        rf.writeUTF(&quot;안녕하세요&quot;);</span><br><span class="line"></span><br><span class="line">        rf.seek(0); &#x2F;&#x2F;포인터 위치 변경</span><br><span class="line">        int i &#x3D; rf.readInt();</span><br><span class="line">        double d &#x3D; rf.readDouble();</span><br><span class="line">        String str &#x3D; rf.readUTF();</span><br><span class="line"></span><br><span class="line">        System.out.println(i);</span><br><span class="line">        System.out.println(d);</span><br><span class="line">        System.out.println(str);</span><br><span class="line"></span><br><span class="line">        rf.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>데코레이터 패턴<br>자바의 입출력 스트림은 데코레이터 패턴을 사용<br>실제 입출력 기능을 가진 객체(컴포넌트)와 그 외 다양한 기능을 제공하는 데코레이터(보조스트림)을 사용하여 다양한 입출력 기능을 구현<br>상속보다 유연한 확장성을 가짐<br>지속적인 서비스의 증가와 제거가 용이함   </li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package stream.coffee;</span><br><span class="line"></span><br><span class="line">public class CoffeeTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        Coffee americano &#x3D; new KenyaAmericano();</span><br><span class="line">        americano.brewing();</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        Coffee kenyaLatte &#x3D; new Latte(new KenyaAmericano());</span><br><span class="line">        kenyaLatte.brewing();</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        Coffee mocha &#x3D; new Mocha(new Latte(new KenyaAmericano()));</span><br><span class="line">        mocha.brewing();</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        Coffee etiopiaLatte &#x3D; new Latte(new EtiopiaAmericano());</span><br><span class="line">        etiopiaLatte.brewing();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Study</category>
        <category>JAVA OOP</category>
      </categories>
  </entry>
  <entry>
    <title>74. Thread 구현하기</title>
    <url>/2020/08/12/hexo_OOP_74/</url>
    <content><![CDATA[<h1 id="객체-지향-프로그래밍"><a href="#객체-지향-프로그래밍" class="headerlink" title="객체 지향 프로그래밍"></a>객체 지향 프로그래밍</h1><h4 id="74-Thread-구현하기"><a href="#74-Thread-구현하기" class="headerlink" title="74. Thread 구현하기"></a>74. Thread 구현하기</h4><p>쓰레드를 구현할 일이 많지는 않지만 안드로이드 개발에서 쓰임<br>쓰레드 프로그래밍에서는 공유 자원이 중요  </p>
<ul>
<li><p>Process<br>실행중인 프로그램, OS로부터 메모리를 할당 받음     </p>
</li>
<li><p>Thread<br>실제 프로그램이 수행되는 작업의 최소 단위<br>하나의 프로세스는 하나 이상의 Thread를 가지게 됨  </p>
</li>
<li><p>Thread 구현하기   </p>
</li>
</ul>
<ol>
<li>자바 Thread 클래스로부터 상속받아 구현    </li>
<li>Runnable 인터페이스 구현   </li>
</ol>
<p>상속 방식</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package thread;</span><br><span class="line"></span><br><span class="line">class MyThread extends Thread &#123; </span><br><span class="line">    public void run() &#123;</span><br><span class="line">        int i;</span><br><span class="line">        for (i&#x3D;0;i&lt;200;i++) &#123;</span><br><span class="line">            System.out.print(i + &quot;\t&quot;);</span><br><span class="line">            try &#123;</span><br><span class="line">                sleep(100); &#x2F;&#x2F;Thread 클래스의 메서드</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                System.out.println(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ThreadTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;start&quot;);</span><br><span class="line">        MyThread th1 &#x3D; new MyThread(); &#x2F;&#x2F;main이랑 별개로 수행됨</span><br><span class="line">        MyThread th2 &#x3D; new MyThread();</span><br><span class="line"></span><br><span class="line">        th1.start(); &#x2F;&#x2F;클래스의 run() 수행</span><br><span class="line">        th2.start();</span><br><span class="line">        System.out.println(&quot;end&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>구현 방식   </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package thread;</span><br><span class="line"></span><br><span class="line">class MyThread implements Runnable &#123;</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        int i;</span><br><span class="line">        for (i&#x3D;0;i&lt;100;i++) &#123;</span><br><span class="line">            System.out.print(i + &quot;\t&quot;);</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(100); &#x2F;&#x2F;Thread 클래스의 메서드</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                System.out.println(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ThreadTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;start&quot;);</span><br><span class="line">        MyThread runner1 &#x3D; new MyThread();</span><br><span class="line">        MyThread runner2 &#x3D; new MyThread();</span><br><span class="line">        Thread th1 &#x3D; new Thread(runner1); &#x2F;&#x2F;Runnable을 구현한 객체를 매개변수로 가능</span><br><span class="line">        Thread th2 &#x3D; new Thread(runner2);</span><br><span class="line"></span><br><span class="line">        th1.start();</span><br><span class="line">        th2.start();</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;end&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>Multi-thread 프로그래밍<br>동시에 여러 개의 Thread가 수행되는 프로그래밍<br>Thread는 각각의 작업공간(context)를 가짐<br>공유 자원이 있는 경우 race condition이 발생<br>critical section은 한번에 하나의 thread만 접근할 수 있으며<br>critical section에 대한 동기화(synchronization)의 구현이 필요   </p>
</li>
<li><p>Thread의 여러가지 메서드 활용   </p>
</li>
</ul>
<p>Thread 우선 순위<br>Thread.MIN_PRIORITY(=1) ~ Thread.MAX_PRIORITY(=10)<br>디폴트 우선 순위 : Thread.NORM_PRIORITY(=5)    </p>
<p>setPriority(int newPriority)<br>int getPriority()</p>
<p>우선 순위가 높은 thread는 CPU를 배분 받을 확률이 높다     </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ThreadTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;start&quot;);</span><br><span class="line"></span><br><span class="line">        Thread t &#x3D; Thread.currentThread(); &#x2F;&#x2F;현재 수행중인 thread(main)</span><br><span class="line">        System.out.println(t); &#x2F;&#x2F;이름, priority, 그룹</span><br><span class="line">        </span><br><span class="line">        System.out.println(&quot;end&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>join() 메서드  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package thread;</span><br><span class="line"></span><br><span class="line">public class JoinTest extends Thread&#123;</span><br><span class="line"></span><br><span class="line">    int start;</span><br><span class="line">    int end;</span><br><span class="line">    int total;</span><br><span class="line"></span><br><span class="line">    public JoinTest(int start,int end) &#123;</span><br><span class="line">        this.start &#x3D; start;</span><br><span class="line">        this.end &#x3D; end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void run() &#123;</span><br><span class="line">        int i;</span><br><span class="line">        for(i&#x3D;start; i&lt;&#x3D;end; i++) &#123;</span><br><span class="line">            total +&#x3D; i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        JoinTest jt1 &#x3D; new JoinTest(1,50);</span><br><span class="line">        JoinTest jt2 &#x3D; new JoinTest(51,100);</span><br><span class="line"></span><br><span class="line">        jt1.start();</span><br><span class="line">        jt2.start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            jt1.join(); &#x2F;&#x2F;main thread가 jt1, jt2 thread를 대기(not runnable)</span><br><span class="line">            jt2.join();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int total &#x3D; jt1.total+jt2.total;</span><br><span class="line">        System.out.println(jt1.total);</span><br><span class="line">        System.out.println(jt2.total);</span><br><span class="line">        System.out.println(total);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>interrupt() 메서드<br>다른 thread에 예외를 발생시키는 interrupt를 보냄<br>thread가 join(),sleep(),wait() 메서드에 의해 블럭킹 되었다면 interrupt에 의해 다시 runnable 상태가 될 수 있음     </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package thread;</span><br><span class="line"></span><br><span class="line">public class InterruptTest extends Thread&#123;</span><br><span class="line"></span><br><span class="line">    public void run() &#123;</span><br><span class="line">        int i;</span><br><span class="line">        for (i&#x3D;0;i&lt;100;i++) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            sleep(5000); &#x2F;&#x2F;5초 not runnable</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">            System.out.println(&quot;Wake!!!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        InterruptTest test &#x3D; new InterruptTest();</span><br><span class="line">        test.start();</span><br><span class="line">        test.interrupt(); &#x2F;&#x2F;Interrupt 예외 발생</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;end&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Thread 종료하기<br>데몬등 무한 반복하는 thread가 종료될 수 있도록 run() 메서드 내의 while문을 활용<br>Thread.stop()은 사용하지 않는다     </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package thread;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">public class TerminateThread extends Thread&#123;</span><br><span class="line"></span><br><span class="line">    private boolean flag &#x3D; false;</span><br><span class="line">    int i;</span><br><span class="line"></span><br><span class="line">    public TerminateThread(String name) &#123; &#x2F;&#x2F;thread 이름 주기</span><br><span class="line">        super(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while( !flag ) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                sleep(100);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(getName()+&quot; end&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setFlag(boolean flag) &#123;</span><br><span class="line">        this.flag &#x3D; flag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line"></span><br><span class="line">        TerminateThread threadA &#x3D; new TerminateThread(&quot;A&quot;);</span><br><span class="line">        TerminateThread threadB &#x3D; new TerminateThread(&quot;B&quot;);</span><br><span class="line"></span><br><span class="line">        threadA.start();</span><br><span class="line">        threadB.start();</span><br><span class="line"></span><br><span class="line">        int in;</span><br><span class="line">        while(true) &#123;</span><br><span class="line">            in &#x3D; System.in.read();</span><br><span class="line">            if (in &#x3D;&#x3D; &#39;A&#39;) &#123;</span><br><span class="line">                threadA.setFlag(true);</span><br><span class="line">            &#125; else if (in &#x3D;&#x3D; &#39;B&#39;) &#123;</span><br><span class="line">                threadB.setFlag(true);</span><br><span class="line">            &#125; else if (in &#x3D;&#x3D; &#39;M&#39;) &#123;</span><br><span class="line">                threadA.setFlag(true);</span><br><span class="line">                threadB.setFlag(true);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;main end&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Study</category>
        <category>JAVA OOP</category>
      </categories>
  </entry>
  <entry>
    <title>77. Multi-thread 프로그래밍</title>
    <url>/2020/08/12/hexo_OOP_77/</url>
    <content><![CDATA[<h1 id="객체-지향-프로그래밍"><a href="#객체-지향-프로그래밍" class="headerlink" title="객체 지향 프로그래밍"></a>객체 지향 프로그래밍</h1><h4 id="77-Multi-thread-프로그래밍"><a href="#77-Multi-thread-프로그래밍" class="headerlink" title="77. Multi-thread 프로그래밍"></a>77. Multi-thread 프로그래밍</h4><ul>
<li><p>임계 영역(critical section)<br>두 개 이상의 thread가 동시에 접근하게 되는 리소스<br>critical section에 동시에 thread가 접근하게 되면 실행 결과를 보장할 수 없음<br>thread간의 순서를 맞추는 동기화(synchronization)가 필요   </p>
</li>
<li><p>동기화<br>임계 영역에 여러 thread가 접근하는 경우, 한 thread가 수행하는 동안 공유 자원을 lock하여 다른 thread의 접근을 막음<br>동기화를 잘못 구현하면 deadlock에 빠질 수 있음      </p>
</li>
<li><p>자바에서 동기화 구현<br>synchronized 수행문과 synchronized 메서드를 이용  </p>
</li>
</ul>
<p>synchronized 수행문</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">synchronized(참조형 수식) &#123;</span><br><span class="line">&#125; &#x2F;&#x2F;참조형 수식에 해당되는 객체에 lock을 건다</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package thread;</span><br><span class="line"></span><br><span class="line">class Bank &#123; &#x2F;&#x2F;critical section</span><br><span class="line">    private int money &#x3D; 10000;</span><br><span class="line"></span><br><span class="line">    public int getMoney() &#123;</span><br><span class="line">        return money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setMoney(int money) &#123;</span><br><span class="line">        this.money &#x3D; money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void saveMoney(int save) &#123;</span><br><span class="line">        synchronized (this) &#123; &#x2F;&#x2F;Bank가 shared resource 이므로</span><br><span class="line">            int m &#x3D; this.getMoney();</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(3000);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            setMoney(m+save);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void minusMoney(int minus) &#123;</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            int m &#x3D; this.getMoney();</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(200);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            setMoney(m - minus);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Park extends Thread &#123;</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(&quot;start save&quot;);</span><br><span class="line">        SyncTest.myBank.saveMoney(3000);</span><br><span class="line">        System.out.println(&quot;save money:&quot; + SyncTest.myBank.getMoney());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ParkWife extends Thread &#123;</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(&quot;start minus&quot;);</span><br><span class="line">        SyncTest.myBank.minusMoney(1000);</span><br><span class="line">        System.out.println(&quot;minus money:&quot; + SyncTest.myBank.getMoney());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class SyncTest &#123;</span><br><span class="line">    public static Bank myBank &#x3D; new Bank();</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        Park park &#x3D; new Park();</span><br><span class="line">        ParkWife parkwife &#x3D; new ParkWife();</span><br><span class="line"></span><br><span class="line">        park.start();</span><br><span class="line">        Thread.sleep(200);</span><br><span class="line">        parkwife.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>synchronized 메서드<br>현재 이 메서드가 속한 객체에 lock을 건다<br>deadlock 방지를 위해 synchronized 메서드 내에서 다른 synchronized 메서드를 호출하지 않는다  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package thread;</span><br><span class="line"></span><br><span class="line">class Bank &#123; &#x2F;&#x2F;critical section</span><br><span class="line">    private int money &#x3D; 10000;</span><br><span class="line"></span><br><span class="line">    public int getMoney() &#123;</span><br><span class="line">        return money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setMoney(int money) &#123;</span><br><span class="line">        this.money &#x3D; money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized void saveMoney(int save) &#123; &#x2F;&#x2F;synchronized 키워드로 lock</span><br><span class="line">        int m &#x3D; this.getMoney();</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(3000);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        setMoney(m+save);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized void minusMoney(int minus) &#123;</span><br><span class="line">        int m &#x3D; this.getMoney();</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(200);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        setMoney(m-minus);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Park extends Thread &#123;</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(&quot;start save&quot;);</span><br><span class="line">        SyncTest.myBank.saveMoney(3000);</span><br><span class="line">        System.out.println(&quot;save money:&quot; + SyncTest.myBank.getMoney());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ParkWife extends Thread &#123;</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(&quot;start minus&quot;);</span><br><span class="line">        SyncTest.myBank.minusMoney(1000);</span><br><span class="line">        System.out.println(&quot;minus money:&quot; + SyncTest.myBank.getMoney());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class SyncTest &#123;</span><br><span class="line">    public static Bank myBank &#x3D; new Bank();</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        Park park &#x3D; new Park();</span><br><span class="line">        ParkWife parkwife &#x3D; new ParkWife();</span><br><span class="line"></span><br><span class="line">        park.start();</span><br><span class="line">        Thread.sleep(200);</span><br><span class="line">        parkwife.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>wait(),notify() 메소드   </li>
</ul>
<p>wait() : 리소스가 더 이상 유효하지 않은 경우 리소스가 사용 가능할 때 까지 기다리기 위해 thread를 non-runnable 상태로 전환<br>wait() 상태가 된 thread는 notify()가 호출 될 때까지 기다린다    </p>
<p>notify() : wait()하고 있는 thread중 한 thread를 runnable한 상태로 깨움   </p>
<p>nofifyAll() : wait()하고 있는 모든 thread가 runnable한 상태가 되도록 함<br>notify()보다 notifyAll()을 사용하길 권장됨<br>특정 thread가 통지를 받도록 제어할 수 없으므로 모두 깨운 후 scheduler에 CPU를 점유하는 것이 좀더 공평     </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package thread;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line"></span><br><span class="line">class FastLibrary&#123;</span><br><span class="line"></span><br><span class="line">    public ArrayList&lt;String&gt; books &#x3D; new ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">    public FastLibrary() &#123;</span><br><span class="line">        books.add(&quot;태백산맥1&quot;);</span><br><span class="line">        books.add(&quot;태백산맥2&quot;);</span><br><span class="line">        books.add(&quot;태백산맥3&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized String lendBook() throws InterruptedException &#123;</span><br><span class="line">        Thread t &#x3D; Thread.currentThread();</span><br><span class="line">        while (books.size() &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            System.out.println(t.getName() + &quot; waiting start&quot;);</span><br><span class="line">            wait();</span><br><span class="line">            System.out.println(t.getName() + &quot; waiting end&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        String title &#x3D; books.remove(0);</span><br><span class="line">        System.out.println(t.getName() +&quot;:&quot;+ title + &quot; lend&quot;);</span><br><span class="line">        return title;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized void returnBook(String title) &#123;</span><br><span class="line">        Thread t &#x3D; Thread.currentThread();</span><br><span class="line">        books.add(title);</span><br><span class="line">        notifyAll(); &#x2F;&#x2F;모든 wait 스레드를 깨운다     </span><br><span class="line">        System.out.println(t.getName() +&quot;:&quot;+ title + &quot; return&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Student extends Thread&#123;</span><br><span class="line"></span><br><span class="line">    public void run() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            String title &#x3D; LibraryMain.library.lendBook();</span><br><span class="line">            if (title &#x3D;&#x3D; null) return;</span><br><span class="line">            sleep(5000);</span><br><span class="line">            LibraryMain.library.returnBook(title);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class LibraryMain &#123;</span><br><span class="line"></span><br><span class="line">    public static FastLibrary library &#x3D; new FastLibrary();</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        Student std1 &#x3D; new Student();</span><br><span class="line">        Student std2 &#x3D; new Student();</span><br><span class="line">        Student std3 &#x3D; new Student();</span><br><span class="line">        Student std4 &#x3D; new Student();</span><br><span class="line">        Student std5 &#x3D; new Student();</span><br><span class="line">        Student std6 &#x3D; new Student();</span><br><span class="line"></span><br><span class="line">        std1.start();</span><br><span class="line">        std2.start();</span><br><span class="line">        std3.start();</span><br><span class="line">        std4.start();</span><br><span class="line">        std5.start();</span><br><span class="line">        std6.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Study</category>
        <category>JAVA OOP</category>
      </categories>
  </entry>
  <entry>
    <title>maven / logback</title>
    <url>/2020/08/15/hexo_spring_project_1/</url>
    <content><![CDATA[<h2 id="maven-logback"><a href="#maven-logback" class="headerlink" title="maven / logback"></a>maven / logback</h2><ul>
<li>maven  </li>
</ul>
<p>build를 담당하는 maven &amp; gradle<br>mvc compile을 통해 필요한 library들을 검토하고 자동으로 다운로드 해준다.<br>다운받은 jar파일들은 User Home 디렉토리의 .m2/repository에 보관된다.<br>설정 파일<br>maven : pom.xml<br>gradle : build.gradle<br>컴파일하면 target으로 실행가능하도록 생성됨  </p>
<ul>
<li>logback (slf4j) </li>
</ul>
<p>level이 내려갈수록 log 범위가 작아짐<br>logging을 담당하는 logback<br>.trace<br>.debug<br>.info<br>.warn<br>.error  </p>
<p>logback에 대한 설정은 src/main/resources에 logback.xml(spring-boot에서는 logback-spring.xml)을 생성하여 할 수 있다.<br>ex) logback.xml</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;appender name&#x3D;&quot;STDOUT&quot; class&#x3D;&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;</span><br><span class="line">        &lt;encoder&gt;</span><br><span class="line">            &lt;pattern&gt;%-5level %logger&#123;36&#125; - %msg%n&lt;&#x2F;pattern&gt;</span><br><span class="line">        &lt;&#x2F;encoder&gt;</span><br><span class="line">    &lt;&#x2F;appender&gt;</span><br><span class="line"></span><br><span class="line">    &lt;root level&#x3D;&quot;trace&quot;&gt;</span><br><span class="line">        &lt;appender-ref ref&#x3D;&quot;STDOUT&quot; &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;root&gt;</span><br><span class="line">&lt;&#x2F;configuration&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>DB(h2)  </li>
</ul>
<p>설치</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew install h2</span><br></pre></td></tr></table></figure>
<p>실행 (브라우저에서 h2-console로 연결된다)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">h2</span><br></pre></td></tr></table></figure>

<p>JDBC API는 java.sql과 javax.sql이 있는데 각각 JAVA SE와 EE에 호환된다.  </p>
<p>연결, 테이블생성, 조회</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    private static Logger logger &#x3D; LoggerFactory.getLogger(Main.class);</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        logger.info(&quot;Hello World&quot;);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;Connection, Statement, ResultSet은 java.sql에 있는 구현체이다.</span><br><span class="line">        Connection connection &#x3D; null;</span><br><span class="line">        Statement statement &#x3D; null;</span><br><span class="line">        try &#123;</span><br><span class="line">            Class.forName(&quot;org.h2.Driver&quot;);</span><br><span class="line">            String url &#x3D; &quot;jdbc:h2:mem:test;MODE&#x3D;MySQL;&quot;;</span><br><span class="line">            connection &#x3D; DriverManager.getConnection(url, &quot;sa&quot;, &quot;&quot;);</span><br><span class="line">            statement &#x3D; connection.createStatement();</span><br><span class="line"></span><br><span class="line">            connection.setAutoCommit(false);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;테이블 생성</span><br><span class="line">            statement.execute(&quot;create table member(&quot; +</span><br><span class="line">                    &quot;id int auto_increment, &quot; +</span><br><span class="line">                    &quot;username varchar(255) not null, &quot; +</span><br><span class="line">                    &quot;password varchar(255) not null, &quot; +</span><br><span class="line">                    &quot;primary key(id))&quot;);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;데이터 insert</span><br><span class="line">            statement.executeUpdate(&quot;insert into member(username, password)&quot; +</span><br><span class="line">                    &quot;values(&#39;jilee&#39;,&#39;1234&#39;)&quot;);</span><br><span class="line"></span><br><span class="line">            ResultSet resultSet &#x3D; statement.executeQuery(&quot;select * from member&quot;);</span><br><span class="line">            </span><br><span class="line">            &#x2F;&#x2F;select 결과는 ResultSet에 저장되며</span><br><span class="line">            &#x2F;&#x2F;ResultSet.next()는 커서를 레코드 단위로 리턴한 뒤 마지막에는 false를 리턴한다. </span><br><span class="line">            while (resultSet.next()) &#123;</span><br><span class="line">                int id &#x3D; resultSet.getInt(&quot;id&quot;);</span><br><span class="line">                String username &#x3D; resultSet.getString(&quot;username&quot;);</span><br><span class="line">                String password &#x3D; resultSet.getString(&quot;password&quot;);</span><br><span class="line"></span><br><span class="line">                logger.info(id + username + password);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            connection.commit();</span><br><span class="line"></span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (SQLException throwables) &#123;</span><br><span class="line">            throwables.printStackTrace();</span><br><span class="line">            try &#123;</span><br><span class="line">                connection.rollback();</span><br><span class="line">            &#125; catch (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;사용한 자원 정리 단계</span><br><span class="line">        &#125; finally &#123; </span><br><span class="line">            try &#123;</span><br><span class="line">                statement.close();</span><br><span class="line">            &#125; catch (SQLException throwables) &#123;</span><br><span class="line">                throwables.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            try &#123;</span><br><span class="line">                connection.close();</span><br><span class="line">            &#125; catch (SQLException throwables) &#123;</span><br><span class="line">                    throwables.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>리팩토링 후<br>var 사용 / try with resource 사용 / Member 모델 사용</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    private static Logger logger &#x3D; LoggerFactory.getLogger(Main.class);</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws ClassNotFoundException &#123;</span><br><span class="line">        logger.info(&quot;Hello World&quot;);</span><br><span class="line"></span><br><span class="line">        Class.forName(&quot;org.h2.Driver&quot;);</span><br><span class="line">        var url &#x3D; &quot;jdbc:h2:mem:test;MODE&#x3D;MySQL;&quot;;</span><br><span class="line"></span><br><span class="line">        try(var connection &#x3D; DriverManager.getConnection(url, &quot;sa&quot;, &quot;&quot;);</span><br><span class="line">            var statement &#x3D; connection.createStatement();)</span><br><span class="line">        &#123;</span><br><span class="line">            connection.setAutoCommit(false);</span><br><span class="line">            statement.execute(&quot;create table member(&quot; +</span><br><span class="line">                    &quot;id int auto_increment, &quot; +</span><br><span class="line">                    &quot;username varchar(255) not null, &quot; +</span><br><span class="line">                    &quot;password varchar(255) not null, &quot; +</span><br><span class="line">                    &quot;primary key(id))&quot;);</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                statement.executeUpdate(&quot;insert into member(username, password)&quot; +</span><br><span class="line">                        &quot;values(&#39;jilee&#39;,&#39;1234&#39;)&quot;);</span><br><span class="line">                connection.commit();</span><br><span class="line">            &#125; catch (SQLException e) &#123;</span><br><span class="line">                connection.rollback();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            var resultSet &#x3D; statement.executeQuery(&quot;select * from member&quot;);</span><br><span class="line">            while (resultSet.next()) &#123;</span><br><span class="line">                var member &#x3D; new Member(resultSet);</span><br><span class="line">                logger.info(member.toString());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; catch (SQLException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Lombok  </li>
</ul>
<p>코드의 가독성을 위하여 사용한다.  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Getter</span><br><span class="line">@Setter</span><br><span class="line">@ToString</span><br><span class="line">@NoArgsConstructor</span><br><span class="line">@RequiredArgsConstructor</span><br><span class="line">public class Member &#123;</span><br><span class="line"></span><br><span class="line">    private int id;</span><br><span class="line">    @NonNull private String userName;</span><br><span class="line">    @NonNull private String password;</span><br><span class="line"></span><br><span class="line">    public Member(ResultSet resultSet) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            this.id &#x3D; resultSet.getInt(&quot;id&quot;);</span><br><span class="line">            this.userName &#x3D; resultSet.getString(&quot;username&quot;);</span><br><span class="line">            this.password &#x3D; resultSet.getString(&quot;password&quot;);</span><br><span class="line">        &#125; catch (SQLException throwables) &#123;</span><br><span class="line">            throwables.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>servlet  </li>
</ul>
<p>EE 버전의 스팩을 구현한 servlet 서버로는 tomcat / jeus / oracle weblogic 등이 있다.  </p>
<p>EE 사용을 위한 의존성 추가</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;javax.servlet&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;javax.servlet-api&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;4.0.1&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;scope&gt;provided&lt;&#x2F;scope&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<p>WAR 설정 추가</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;groupId&gt;com.mycompany.app&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;my-app&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt;</span><br><span class="line">&lt;packaging&gt;war&lt;&#x2F;packaging&gt;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Study</category>
        <category>Spring Framework</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>IoC (Inversion of Control)</title>
    <url>/2020/08/15/hexo_spring_project_2/</url>
    <content><![CDATA[<h2 id="IoC-Inversion-of-Control"><a href="#IoC-Inversion-of-Control" class="headerlink" title="IoC (Inversion of Control)"></a>IoC (Inversion of Control)</h2><p>Spring의 대표적인 특징 중 하나.</p>
<p>어떤 객체가 사용하는 의존 객체를 직접 만들어서 사용하는게 아니라, 주입(DI)받아서 사용하는 것.  </p>
<p>Spring IoC Container<br> : 애플리케이션 컴포넌트의 중앙 저장소.</p>
<p>ApplicationContext<br> : IoC 컨테이너의 핵심적인 인터페이스.<br> IoC 컨테이너의 최상위 인터페이스인 BeanFactory를 상속받아 여러 기능이 추가됨.</p>
<ul>
<li><p>메시지 소스 처리 (i18n)  </p>
</li>
<li><p>이벤트 발행</p>
</li>
<li><p>리소스 로딩  </p>
<p>IoC 컨테이너에 객체를 생성하고 생성된 객체들(Bean)의 의존성을 관리해준다.<br>이해만 해둘뿐, 딱히 이 인터페이스에 대해 직접 보거나 사용할 일은 없는 듯.<br>ClassPathXmlApplicationContext : XML 설정 파일 사용<br>AnnotationConfigApplicationContext : 자바 설정 파일 사용 (@Configuration)</p>
</li>
</ul>
<p>Bean<br> : Spring IoC 컨테이너가 관리하는 객체.<br>Class를 Bean으로 등록하려면 Component Scan을 사용하거나<br>또는 직접 XML이나 자바 설정 파일(@Configuration)에 등록해야 한다.  </p>
<p>IoC 컨테이너에 등록되는 Bean들의 특징</p>
<ul>
<li>의존성 관리, 특히 테스트에서 가짜 객체(@Mock)를 활용한 단위테스트에 용이하다.</li>
<li>스코프 : 기본적으로 싱글톤 스코프로 등록이된다. (or 프로토타입)<br>싱글톤 스코프로 등록되는 클래스는 애플리케이션이 구동되는 초기에 Bean으로 생성된다.  </li>
<li>라이프사이클 인터페이스</li>
</ul>
<p>Component Scanning<br> : Annotation 처리 프로세서 역할을 하는 @ComponentScan에 의하여<br> 모든 @Component Annotation이 붙은 Class들을 Bean으로 등록한다.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">    @Repository</span><br><span class="line">    @Service</span><br><span class="line">    @Controller</span><br></pre></td></tr></table></figure>

<p>참고로 @ComponentScan은 기본적으로 이 어노테이션이 붙은 클래스가 위치한 곳 부터 Component Scanning을 실시한다.<br>또는 특정 위치에서 부터 Scanning을 하도록 설정할수도 있고 Filter 옵션을 통해 어떤 클래스를 스캔할 지 또는 하지 않을 지 정할 수도 있다.   </p>
<p>직접 등록하기</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class Config() &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public String test() &#123;</span><br><span class="line">        return &quot;test&quot;;</span><br><span class="line">    &#125;   </span><br><span class="line">    </span><br><span class="line">    @Bean</span><br><span class="line">    public BookRepository bookRepository() &#123;</span><br><span class="line">        return new BookRepository();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public BookService bookService &#123;</span><br><span class="line">        return new BookService(bookRespsitory());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>function을 이용한 직접 등록</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    new SpringApplicationBuilder()</span><br><span class="line">        .sources(Demospring51Application.class)</span><br><span class="line">        .initializers((ApplicationContextInitializer&lt;GenericApplicationContext&gt;)</span><br><span class="line">            applicationContext -&gt; &#123;</span><br><span class="line">                applicationContext.registerBean(MyBean.class);</span><br><span class="line">            &#125;)</span><br><span class="line">        .run(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>이 방법은 리플랙션이나 프록시를 사용하지 않기 때문에 애플리케이션 구동 시 성능상의 이점이 있다지만..<br>ComponentScan을 대체하기에는 쓰기 불편해서 좋은 방법은 아닌 것 같다. </p>
<p>Bean을 꺼내어 쓰는 방법<br> : @Autowired 또는 @Inject 또는 ApplicationContext.getBean()으로 직접 꺼내기<br>Bean으로 등록된 Class만 Bean을 꺼내어 쓸 수 있다.</p>
<p>의존성 주입(Dependency Injection)<br> : @Autowired 또는 @Inject를 사용하는데,<br> 예외로 생성자가 오직 하나이면서 Bean을 파라미터로 받는다면 @Autowired를 생략하고도 DI를 자동으로 해준다.<br> @Autowired/@Inject를 붙인다면 생성자/필드/Setter에 붙이게 된다.</p>
<h4 id="Autowired에-대하여…"><a href="#Autowired에-대하여…" class="headerlink" title="@Autowired에 대하여…"></a>@Autowired에 대하여…</h4><p>어노테이션을 setter에 달려있고 의존성의 Bean이 없을 때,<br>setter임에도 불구하고 생각과 달리 다른 경우와 마찬가지로 객체생성이 불가능할 수 있는데<br>Spring이 해당 의존성을 위해 Bean을 찾기 때문이다.<br>이를 피하기 위해서는 @Autowired(required = false)로 설정하여 의존성 주입이 안된 상태로 생성할 수 있다.<br>필드에 어노테이션을 다는 경우도 비슷함.  </p>
<p>그리고 의존성 타입의 Bean이 여러가지 일 경우에 객체생성이 안될 수 있는데,<br>이때는 주입받으려는 Bean을 @Primary로 마킹하거나,</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Repository @Primary</span><br><span class="line">public class PrimaryBookRepository implements BookRepository &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>해당 타입의 모든 Bean을 주입 받거나</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">List&lt;BookRepository&gt; bookrepositories;</span><br></pre></td></tr></table></figure>
<p>@Qualifier(“beanName”)으로 특정 Bean을 주입받는다.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Autowired @Qualifier(&quot;sampleBookRepository&quot;)</span><br><span class="line">BookRepository bookrepository;</span><br></pre></td></tr></table></figure>

<p>BeanPostProcessor<br> : 빈 라이프 사이클 인터페이스이다.<br> 빈 인스턴스의 생성 전후에 부가적인 작업을 할 수 있다.<br> 특히, AutowiredAnnotationBeanPostProcessor의 postProcessorBeforeInitialization 메서드로 인해<br> 빈 인스턴스 생성 전에 @Autowired 어노테이션을 처리한다.</p>
<p>BeanFactoryPostProcessor<br> : 다른 모든 Bean들을 만들기 이전에 수행된다.<br> 특히, BeanFactoryPostProcessor를 구현한 ConfigurationClassPostProcessor는 @ComponentScan 어노테이션을 처리한다.  </p>
<h4 id="빈의-스코프에-대하여…"><a href="#빈의-스코프에-대하여…" class="headerlink" title="빈의 스코프에 대하여…"></a>빈의 스코프에 대하여…</h4><p>빈의 스코프는 기본적으로 싱글톤이고, 그 외에 프로토타입이 있다.<br>프로토타입</p>
<ul>
<li>Request</li>
<li>Session</li>
<li>WebSocket</li>
<li>…  </li>
</ul>
<p>@Component @Scope(“prototype”)<br>위의 어노테이션처리된 Bean은 받아 올 때마다 새로운 인스턴스가 생성된다.  </p>
<p>참고로 프로토타입 빈이 싱글톤 빈을 의존하는 것은 문제없지만,<br>싱글톤 빈이 의존하는 프로토타입 빈은 의도한 것처럼 새로운 인스턴스가 생성되지 않는다는 문제가 있다.<br>이 문제를 해결하는 방법으로</p>
<ul>
<li>Proxy mode<br>프로토타입 빈을 Proxy 빈으로 감싸서 다른 빈이 이 프로토타입 빈을 참조할 때 Proxy를 거쳐서 참조하도록<br>이때, Proxy 빈은 해당 프로토타입 빈을 상속하며, 참조하는 빈은 Proxy 빈을 참조한다. <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">##for class</span><br><span class="line">@Component @Scope(value &#x3D; &quot;prototype&quot;, proxyMode &#x3D; ScopedProxyMode.TARGET_CLASS)</span><br><span class="line">##for interface</span><br><span class="line">@Component @Scope(value &#x3D; &quot;prototype&quot;, proxyMode &#x3D; ScopedProxyMode.INTERFACES)</span><br></pre></td></tr></table></figure></li>
<li>Object-Provider<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">ObjectProvider&lt;Proto&gt; proto;</span><br></pre></td></tr></table></figure></li>
<li>Provider</li>
</ul>
<h4 id="ApplicationContext의-기능-Environment…"><a href="#ApplicationContext의-기능-Environment…" class="headerlink" title="ApplicationContext의 기능 Environment…"></a>ApplicationContext의 기능 Environment…</h4><p>EnvironmentCapable<br> : 프로파일과 프로퍼티를 다루는 인터페이스이다.  </p>
<p>프로파일<br> : 빈들의 그룹, Environment가 활성화할 프로파일을 확인하고 설정한다.<br> 환경에따라 사용할 빈을 구분할 때 사용된다. (ex 프로덕션에서는 A 빈, 테스트환경에서는 B 빈을 사용)</p>
<p>프로파일 정의하기</p>
<ul>
<li>클래스에 정의<br>test 프로파일로 애플리케이션을 실행할 때 사용될 Java Configuration<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Configuration @Profile(&quot;test&quot;)</span><br></pre></td></tr></table></figure>
proc 프로파일이 아닌 애플리케이션을 실행할 때 사용될 Component <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Component @Profile(&quot;!proc&quot;)</span><br></pre></td></tr></table></figure></li>
<li>Bean 생성 메서드에 정의<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Bean @Profile(&quot;test&quot;)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>@Profile에는 표현식으로 !(not), &amp;(and), |(or) 가능.</p>
<p>프로파일 지정하기</p>
<ul>
<li><p>JVM 시스템 프로퍼티 [-Dspring.profiles.avtive=”test,A,B,…”]<br>== intelliJ의 Run/Debug Configuration의 Active profiles </p>
</li>
<li><p>@ActiveProfiles (테스트용)</p>
</li>
</ul>
<p>프로퍼티<br> : 다양한 방법으로 정의할 수 있는 설정 값, Environment가 프로퍼티 소스를 설정하고 프로퍼티 값을 가져온다.<br> 프로퍼티는 우선순위가 있다.(계층형이다.)<br> 1.ServletConfig<br> 1.ServletContext<br> 1.JNDI (java:comp/env/)<br> 1.JVM 시스템 프로퍼티 (-Dkey=”value”)<br> 1.JVM 시스템 환경 변수 (OS 환경 변수)</p>
<p>Environment를 통해 프로퍼티 추가하기</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@PropertySource(&quot;classpath:&#x2F;app.properties&quot;)</span><br></pre></td></tr></table></figure>
<p>app.properties 파일을 참조한다.<br>참고로 스프링부트에서는 application.properties라는 기본 프로퍼티 소스를 지원한다.  </p>
<h4 id="ApplicationContext의-기능-MessageSource…"><a href="#ApplicationContext의-기능-MessageSource…" class="headerlink" title="ApplicationContext의 기능 MessageSource…"></a>ApplicationContext의 기능 MessageSource…</h4><p>MessageSource<br> : i18n(국제화) 기능을 제공하는 인터페이스이다.  </p>
<p>MessageSource의 getMessage로 참조할 수 있다.<br>Locale에 따라서 다른 메세지를 보여준다.  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">MessageSource messageSource;</span><br><span class="line"></span><br><span class="line">public void run() &#123;</span><br><span class="line">    System.out.println(messageSource.getMessage(&quot;code1&quot;), Locale.KOREA);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>스프링부트에서는 messages로 시작하는 소스들을 자동으로 참조한다.<br>messages.properties<br>messages_ko_KR.properties</p>
<p>리로딩 기능이 있는 메시지 소스를 @Bean으로 직접 만들어서 참조</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public MessageSource messageSource() &#123;</span><br><span class="line">    var messageSource &#x3D; new ReloadableResourceBundleMessageSource();</span><br><span class="line">    messageSource.setBasename(&quot;classpath:&#x2F;messages&quot;);</span><br><span class="line">    messageSource.setDefaultEncoding(&quot;UTF-8&quot;);</span><br><span class="line">    return messageSource;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ApplicationContext의-기능-ApplicationEventPublisher…"><a href="#ApplicationContext의-기능-ApplicationEventPublisher…" class="headerlink" title="ApplicationContext의 기능 ApplicationEventPublisher…"></a>ApplicationContext의 기능 ApplicationEventPublisher…</h4><p>ApplicationEventPublisher<br> : 이벤트 프로그래밍에 필요한 인터페이스. 옵저버 패턴의 구현체이다.  </p>
<p>spring 4.2 전에는<br>이벤트 만들기<br>ApplicationEvent Class를 상속받아야 한다.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MyEvent extends ApplicationEvent &#123;</span><br><span class="line">    public MyEvent(Object source) &#123;</span><br><span class="line">        super(source);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>이벤트 핸들러 만들기<br>ApplicationListener&lt;이벤트&gt; 인터페이스를 구현하고 빈으로 등록되어야 한다.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class MyEventHandler implements ApplicationListener&lt;MyEvent&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onApplicationEvent(MyEvent event) &#123;</span><br><span class="line">        System.out.println(&quot;이벤트 확인&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>spring 4.2 부터는 이벤트나 이벤트 핸들러 생성에서 상속/구현이 빠지고 어노테이션으로 처리한다.<br>이벤트 만들기</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MyEvent &#123;</span><br><span class="line">    private Object source;</span><br><span class="line"></span><br><span class="line">    public MyEvent(Object source) &#123;</span><br><span class="line">        this.source &#x3D; source;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public Object getSource() &#123;</span><br><span class="line">        return source;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>이벤트 핸들러 만들기</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class MyEventHandler &#123;</span><br><span class="line">    </span><br><span class="line">    @EventListener</span><br><span class="line">    public void handle(MyEvent event) &#123;</span><br><span class="line">        System.out.println(&quot;이벤트 확인&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>이벤트 발생시키기</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ApplicationEventPublisher.publishEvent(new MyEvent(this));</span><br></pre></td></tr></table></figure>

<p>만약 이벤트 핸들러가 여러개라면, Spring은 기본적으로 이벤트를 여러 핸들러로 순차적으로 처리하게 된다.<br>이때, 순서를 정하고 싶다면 핸들러에 @Order 어노테이션을 사용한다.<br>또는 비동기적(여러 쓰레드)으로 처리하고 싶다면 @Async 사용한다. (Java Configuration File에서는 @EnableAsync 필요)  </p>
<p>Spring에서 제공하는 기본 이벤트</p>
<ul>
<li>ContextRefreshedEvent</li>
<li>ContextStartedEvent</li>
<li>ContextStoppedEvent</li>
<li>ContextClosedEvent</li>
<li>RequestHandledEvent</li>
</ul>
<h4 id="ResouceLoader"><a href="#ResouceLoader" class="headerlink" title="ResouceLoader"></a>ResouceLoader</h4><p> : 리소스를 읽어오는 기능을 제공하는 인터페이스  </p>
<p> Resource getResource(String location);</p>
<p> 파일시스템에서 읽어오기<br> 클래스패스에서 읽어오기(target/classes) getResource(“classpath:test.txt”);<br>    resources에 있는 파일들이 빌드될 때 클래스패스에 들어가게 된다.<br> URL로 읽어오기<br> 상대/절대 경로로 읽어오기</p>
]]></content>
      <categories>
        <category>Study</category>
        <category>Spring Framework</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>AOP (Aspect Oriented Programming)</title>
    <url>/2020/08/15/hexo_spring_project_3/</url>
    <content><![CDATA[<h2 id="AOP-Aspect-Oriented-Programming"><a href="#AOP-Aspect-Oriented-Programming" class="headerlink" title="AOP (Aspect Oriented Programming)"></a>AOP (Aspect Oriented Programming)</h2><p>흩어진 Concern을 Aspect로 모듈화 할 수 있는 프로그래밍 기법이다.<br>AOP의 핵심은 흩어진 코드(여러 곳에서 반복되는 코드)를 한 곳으로 모으는 것.<br>AOP의 구현체로 AspectJ와 스프링 AOP가 있다.  </p>
<p>Concern(여러 경로에 흩어져 있는 비슷한 코드)의 변경이 있을때<br>Concern들을 Aspect로 모아서 Aspect만 변경함으로서<br>모든 경로에서 각각 따로 변경해줘야 하는 번거로움을 방지해준다.  </p>
<h4 id="AOP-주요-개념"><a href="#AOP-주요-개념" class="headerlink" title="AOP 주요 개념"></a>AOP 주요 개념</h4><p>Aspect : 모아진 코드와 정보 집합 모듈<br>Advice : 구현될 기능<br>PointCut : 어디에 적용되는지의 정보<br>Target : 적용이 되는 대상<br>Join Point : 생성자 호출 직전/직후, 메서드 호출시 등등 적용 가능한 시점</p>
<h4 id="AOP-적용-방법"><a href="#AOP-적용-방법" class="headerlink" title="AOP 적용 방법"></a>AOP 적용 방법</h4><p>AspectJ<br>컴파일 타임 : 자바파일을 class 파일로 만들 때, 추가 컴파일링 필요<br>로딩 타임 : class 로딩 시점, java agent 로드타임위버 설정 필요<br>Spring AOP (쉽고 현실적임)<br>런 타임 : A 빈이 만들어질때 A 타입의 proxy 빈을 만들어서 proxy 빈이 Advice를 먼저 호출  </p>
<p>대표적으로 @Transactional 어노테이션이 있는데,<br>트랜잭션 처리(트랜잭션 시작, 커밋/롤백)에 대한 동일한 부분을 어노테이션 하나로 처리한다.<br>참고로 JPA Repository의 모든 메서드에는 @Transactional이 생략되어 적용되어있다.  </p>
<h4 id="스프링-AOP"><a href="#스프링-AOP" class="headerlink" title="스프링 AOP"></a>스프링 AOP</h4><p>프록시 기반의 AOP 구현체이며 스프링 빈에만 적용할 수 있다.  </p>
<p>프록시 패턴은 주로 접근 제어 또는 부가기능을 추가하기 위해 사용한다.  </p>
<ol>
<li>프록시는 Real Subject와 같은 인터페이스를 구현하고(같은 타입) Real Subject를 의존한다.    </li>
<li>프록시에만 부가기능을 추가하고 Real Subject는 변경하지 않는다.  </li>
<li>사용자는 부가기능이 구현된 프록시를 사용한다.</li>
</ol>
<p>이때, 프록시를 작성하는 어려움이나 반복적인 코드, 그리고 객체들 사이의 복잡한 관계 등 문제가 발생하는데  </p>
<p>스프링 AOP는 스프링 IoC 컨테이너가 제공하는 기반시설과<br>런 타임 시점에 동적으로 프록시를 만들어 주는 기능(Dynamic Proxy)을 사용하여 이런 문제를 해결한다.  </p>
<p>스프링 IoC 컨테이너의 AbstractAutoProxyCreator(implements BeanPostProcessor)에 의하여<br>기존 빈을 대체하는 프록시를 동적으로 생성하고 프록시를 기존 빈 대신에 컨테이너에 등록한다.  </p>
<p>Aspect 정의<br>Pointcut과 Advice의 정보가 필요하다.  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Component &#x2F;&#x2F;Aspect Bean 이어야 한다.</span><br><span class="line">@Aspect</span><br><span class="line">public class PerfAspect &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;Advice 생성</span><br><span class="line">    @Around(&quot;execution(* kr.co.testproject..*.EventService.*(..))&quot;) </span><br><span class="line">    &#x2F;&#x2F;Advice는 @Around 어노테이션이 붙어야 하고 값으로 pointcut을 이름으로 적용하거나 또는 직접 정의할 수 있다.</span><br><span class="line">    &#x2F;&#x2F;표현식을 사용할 수 있다. </span><br><span class="line">    public Object logPerf(ProceedingJoinPoint pjp) throws Throwable &#123; </span><br><span class="line">    &#x2F;&#x2F;ProceedingJoinPoint는 적용될 메소드라고 보면 된다.</span><br><span class="line">        long begin &#x3D; System.currentTimeMillis();</span><br><span class="line">        Object retVal &#x3D; pjp.proceed(); &#x2F;&#x2F;메소드 호출</span><br><span class="line">        System.out.println(System.currentTimeMillis() - begin);</span><br><span class="line">        return retVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>또는 어노테이션으로 pointcut을 정의할 수 있는데<br>먼저 어노테이션을 생성하고</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Target(ElementType.METHOD) &#x2F;&#x2F; 이 어노테이션은 메서드에 붙일것이다라고 명시.  </span><br><span class="line">@Retention(RetentionPolicy.CLASS) &#x2F;&#x2F; 어노테이션 정보를 유지할 기간, AOP는 CLASS 이상으로 사용해야 한다.  </span><br><span class="line">public @interface PerfLogging &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Aspect의 @Around에서 execution 대신 어노테이션 표현식을 사용한다.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Around(&quot;@annotation(PerfLogging)&quot;) </span><br><span class="line">&#x2F;&#x2F;@PerfLogging 어노테이션이 붙은 메서드가 pointcut이 된다.</span><br></pre></td></tr></table></figure>

<p>또는 특정 Bean에 적용</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Around(&quot;bean(simpleEventService)&quot;) </span><br><span class="line">&#x2F;&#x2F;@PerfLogging 어노테이션이 붙은 메서드가 pointcut이 된다.</span><br></pre></td></tr></table></figure>

<p>단순히 메서드 실행 기준 특정 시점에만 부가기능이 있는 경우에는<br>@Around 대신 @Before, @AfterReturning, @AfterThrowing를 사용해도 된다.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Before(&quot;bean(simpleEventService)&quot;)</span><br></pre></td></tr></table></figure>


<h4 id="스프링-AOP-활용하기-예시"><a href="#스프링-AOP-활용하기-예시" class="headerlink" title="스프링 AOP 활용하기 예시"></a>스프링 AOP 활용하기 예시</h4><p>Annotation 생성</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Target(ElementType.METHOD)  </span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)  </span><br><span class="line">public @interface LogExecutionTime &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>실제 Aspect 생성</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">@Aspect</span><br><span class="line">public class LogAspect &#123;</span><br><span class="line">	Logger logger &#x3D; LoggerFactory.getLogger(LogAspect.class);</span><br><span class="line"></span><br><span class="line">	@Around(&quot;@annotation(LogExecutionTime)&quot;)</span><br><span class="line">	public Object logExecutionTime(ProceedingJoinPoint joinPoint) throws Throwable &#123;</span><br><span class="line">		StopWatch stopWatch &#x3D; new StopWatch();</span><br><span class="line">		stopWatch.start();</span><br><span class="line"></span><br><span class="line">		Object proceed &#x3D; joinPoint.proceed();</span><br><span class="line"></span><br><span class="line">		stopWatch.stop();</span><br><span class="line">		logger.info(stopWatch.prettyPrint());</span><br><span class="line"></span><br><span class="line">		return proceed;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Annotation 달기</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@LogExecutionTime</span><br><span class="line">@GetMapping(&quot;&#x2F;owners&#x2F;find&quot;)</span><br><span class="line">public String initFindForm(Map&lt;String, Object&gt; model) &#123;</span><br><span class="line">	model.put(&quot;owner&quot;, new Owner());</span><br><span class="line">	return &quot;owners&#x2F;findOwners&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>결과적으로, AOP를 통하여 하나의 클래스(Aspect)로<br>Annotation이 달려있는 모든 메서드는 수행 시간이 계산된다.  </p>
]]></content>
      <categories>
        <category>Study</category>
        <category>Spring Framework</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>PSA (Portable Service Abstraction)</title>
    <url>/2020/08/15/hexo_spring_project_4/</url>
    <content><![CDATA[<h2 id="PSA-Portable-Service-Abstraction"><a href="#PSA-Portable-Service-Abstraction" class="headerlink" title="PSA (Portable Service Abstraction)"></a>PSA (Portable Service Abstraction)</h2><p>이미 잘 만들어진 인터페이스를 사용하는 것.<br>확장성이 좋지 못한 코드 또는 기술에 특화되어 있는 코드에 사용하면 좋다.</p>
<p>Spring Framework이 제공하는 API는 대부분이 추상화되어있다.  </p>
<hr>
<h4 id="추상화-예제"><a href="#추상화-예제" class="headerlink" title="추상화 예제"></a>추상화 예제</h4><ul>
<li><p>스프링 트랜잭션<br>@Transactional 어노테이션의 Aspect는 PlatformTransactionManager 인터페이스를 사용하여 코딩되어 있는데,<br>그렇기 때문에 PlatformTransactionManager에 대한 구현체<br>(JpaTransactionManager, DatasourceTransactionManager, HibernateTransactionManager 등)가 바뀌더라도<br>@Transactional Aspect의 코드가 변경될 필요가 없다.  </p>
</li>
<li><p>스프링 캐시<br>@Cacheable / @CacheEvict 등 스프링 캐시 관련 어노테이션의 Aspect는<br>CacheManager 인터페이스를 사용하여 코딩되어있으며,<br>위와 동일하게 구현체가 바뀌더라도 Aspect 코드는 변경될 필요가 없다.</p>
</li>
<li><p>스프링 웹 MVC<br>@Controller / @RequestMapping 등 스프링 웹 MVC 관련 어노테이션은<br>의존성에 따라 Servlet을 사용할 수도 있고 Reactive를 사용할 수도 있다.<br>고로, 해당 어노테이션을 사용한 나의 코드는 변경하기 쉽거나 변경되지 않아도 된다.  </p>
</li>
</ul>
]]></content>
      <categories>
        <category>Study</category>
        <category>Spring Framework</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>01. What, How, Hello world</title>
    <url>/2020/08/12/hexo_springboot_1_01/</url>
    <content><![CDATA[<h1 id="스프링-부트-프로젝트"><a href="#스프링-부트-프로젝트" class="headerlink" title="스프링 부트 프로젝트"></a>스프링 부트 프로젝트</h1><h3 id="레스토랑-예약-사이트-만들기"><a href="#레스토랑-예약-사이트-만들기" class="headerlink" title="레스토랑 예약 사이트 만들기"></a>레스토랑 예약 사이트 만들기</h3><h4 id="01-What-How-Hello-world"><a href="#01-What-How-Hello-world" class="headerlink" title="01. What, How, Hello world"></a>01. What, How, Hello world</h4><ul>
<li><p>무엇을 만들 것인가<br>프로그래밍은 프로그램을 만드는 것이며, 이는 문제를 해결하는 것이다.<br>무엇을 만들 것인가의 시작은 무엇이 문제인가로부터 시작된다.   </p>
</li>
<li><p>사용자 스토리<br>사용자 입장에서 프로그램의 기능을 서술한 것<br>(사용자)는 (가치)를 위해 (기능)을 할 수 있다.<br>ex) &lt;고객&gt;은 &lt;뭘 먹고 싶은지 발견&gt;할 수 있도록 &lt;가게 목록을 볼&gt; 수 있다.</p>
</li>
<li><p>계획을 세워야 한다<br>사용자 스토리 기반에서 어떤 순서로 개발할 것인지 세운다.<br>계획을 세워두면 변경이 있을 떄 얼마나 기간이 늘어날 지, 또는 어떤 것을 포기할지 선택하는 기준이 된다.      </p>
</li>
<li><p>어떻게 만들 것인가<br>도메인 모델링 : 해결하려는 문제에서 쓰이는 개념들을 정의하고 필요한 것을 알아보는것<br>모델 : 가게, 메뉴 정보, 사용자, 즐겨찾기 정보, 리뷰 정보, 예약 정보<br>시스템 아키텍쳐 : 시스템의 구성, 제약 조건을 알아야 한다.<br>제약 조건 : 홈페이지를 통해 서비스(Web), 모바일(Mobile App)<br>3-tier Architecture : 가장 흔하게 쓰이는 시스템 아키텍쳐<br>Presentation : 사용자와 소통하는 부분 (Front-end|HTML,CSS,JS)<br>Business : 소통의 결과, 사용자 요청 처리 등 (Back-end|Rest API)<br>Data source : 처리된 데이터가 저장되는 곳 (Database|DBMS)    </p>
</li>
<li><p>Back-end를 어떻게 만들 것인가<br>Layered Architecture (4개의 층으로 구성됨)  </p>
<blockquote>
<p>UI Layer    </p>
<blockquote>
<p>Application Layer   </p>
<blockquote>
<p>Domain Layer    </p>
<blockquote>
<p>Infrastructure Layer</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>  각 레이어는 아래의 레이어에 의존하고 위의 레이어를 사용하지 않는다.    </p>
</li>
<li><p>기술 선택<br>JAVA, Spring Boot, Rest API     </p>
</li>
<li><p>프로젝트 생성<br>스프링 부트 프로젝트 생성 (Spring Initailizer 이용)<br><a href="https://spring.io/" target="_blank" rel="noopener">Spring Home page</a> &gt; Projects &gt; Spring Boot &gt; Quickstart &gt; 여러 선택 후 GENERATE &gt; IDEA에서 open</p>
</li>
</ul>
<p>UI 레이어를 위한 interfaces 패키지 추가 및 Welcome 컨트롤러 생성    </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package kr.co.fastcampus.eatgo.interfaces;</span><br><span class="line"></span><br><span class="line">import org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line">@RestController &#x2F;&#x2F;웹에서 접속 가능한 컨트롤러 어노테이션</span><br><span class="line">public class WelcomController &#123;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;&#x2F;&quot;) &#x2F;&#x2F;Get: http에서 접속하는데 쓰는 기본적인 4가지 메소드중 하나</span><br><span class="line">    public String hello() &#123;</span><br><span class="line">        return &quot;Hello, world!!!&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Study</category>
        <category>Spring Boot Project</category>
      </categories>
      <tags>
        <tag>spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title>05. Test Driven Development(TDD)</title>
    <url>/2020/08/12/hexo_springboot_1_05/</url>
    <content><![CDATA[<h1 id="스프링-부트-프로젝트"><a href="#스프링-부트-프로젝트" class="headerlink" title="스프링 부트 프로젝트"></a>스프링 부트 프로젝트</h1><h3 id="레스토랑-예약-사이트-만들기"><a href="#레스토랑-예약-사이트-만들기" class="headerlink" title="레스토랑 예약 사이트 만들기"></a>레스토랑 예약 사이트 만들기</h3><h4 id="05-Test-Driven-Development-TDD"><a href="#05-Test-Driven-Development-TDD" class="headerlink" title="05. Test Driven Development(TDD)"></a>05. Test Driven Development(TDD)</h4><p>테스트 주도 개발<br>목표 주도 개발<br>사용자 중심 개발<br>인터페이스 중심 개발     </p>
<p>TDD를 하는 이유는 올바르게 작동하는 깔끔한 코드 작성을 위함<br>Refactoring : 작동은 그대로 둔 상태로 코드만 바꾸는 것<br>Refactoring을 위해서는 올바르게 작동한다는 것을 보장해 줄 Test 코드가 필요하다.<br>TDD의 핵심은 Test 코드를 먼저 작성하는 것이다.  </p>
<p>TDD 사이클<br>Red : 실패하는 테스트<br>Green : 성공하는 테스트<br>Refactoring : 테스트는 그대로인 상태에서 내부 구현을 변경  </p>
<p>Demo<br>레스토랑 모델 생성</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package kr.co.fastcampus.eatgo.domain;</span><br><span class="line"></span><br><span class="line">public class Restourant &#123;</span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return &quot;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>레스토랑 테스트 생성</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package kr.co.fastcampus.eatgo.domain;</span><br><span class="line"></span><br><span class="line">import org.junit.Test;</span><br><span class="line"></span><br><span class="line">import static org.hamcrest.CoreMatchers.is;</span><br><span class="line">import static org.junit.Assert.*;</span><br><span class="line"></span><br><span class="line">public class RestaurantTests &#123;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void creation() &#123;</span><br><span class="line">        Restourant restaurant &#x3D; new Restaurant();</span><br><span class="line">        assertThat(restaurant.getName(), is(&quot;Bob zip&quot;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>테스트 실패 내역이 출력된다.(Red)<br>(“Bob zip”을 기대했지만 값은 “”이다.)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Expected: is &quot;Bob zip&quot;</span><br><span class="line">     but: was &quot;&quot;</span><br><span class="line">Expected :Bob zip</span><br><span class="line">Actual   :</span><br><span class="line">&lt;Click to see difference&gt;</span><br></pre></td></tr></table></figure>

<p>=&gt; 성공 하도록 코딩 (Green)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package kr.co.fastcampus.eatgo.domain;</span><br><span class="line"></span><br><span class="line">public class Restourant &#123;</span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return &quot;Bob zip&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Red,Green에서 이 모델을 어떻게 사용할 것인지 먼저 정의<br>실제 구현은 그 다음 Refactoring</p>
<p>=&gt; 실제 구현 (Refactoring)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package kr.co.fastcampus.eatgo.domain;</span><br><span class="line"></span><br><span class="line">public class Restourant &#123;</span><br><span class="line">    private final String name;</span><br><span class="line">    private final String address;</span><br><span class="line"></span><br><span class="line">    public Restourant(String name, String address) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">        this.address &#x3D; address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getAddress() &#123;</span><br><span class="line">        return address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getInformation() &#123;</span><br><span class="line">        return name+&quot; in &quot;+address;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Study</category>
        <category>Spring Boot Project</category>
      </categories>
      <tags>
        <tag>spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title>06. REST API</title>
    <url>/2020/08/12/hexo_springboot_1_06/</url>
    <content><![CDATA[<h1 id="스프링-부트-프로젝트"><a href="#스프링-부트-프로젝트" class="headerlink" title="스프링 부트 프로젝트"></a>스프링 부트 프로젝트</h1><h3 id="레스토랑-예약-사이트-만들기"><a href="#레스토랑-예약-사이트-만들기" class="headerlink" title="레스토랑 예약 사이트 만들기"></a>레스토랑 예약 사이트 만들기</h3><h4 id="06-REST-API"><a href="#06-REST-API" class="headerlink" title="06. REST API"></a>06. REST API</h4><p>다양한 환경(Web, Mobile)을 지원하려면,<br>서로 다른 Front-end로 구성되어야 한다.<br>대신 공통으로 사용하는 기능들은 하나의 Back-end를 통해 제공한다.    </p>
<p>이때 Back-end를 만드는 기술이 Rest API.  </p>
<p>REST(REpresentational State Transfer)<br>표현 상태 전달, 곧 Resource를 처리하는 방식을 의미한다.</p>
<p>Resource의 처리 방식은 4가지(CRUD)<br>CRUD와 http의 표준 4가지 메서드와 연결<br>Create &gt; POST<br>Read &gt; GET<br>Update &gt; PUT/PATCH<br>Delete &gt; DELETE     </p>
<p>URI(Uniform Resource Identifier)<br>리소스를 지정할 때 사용하는 식별자(resource 식별)<br>URL(Uniform Resource Locator)<br>리소스를 지정할 때 사용하는 지시자(resource 위치)   </p>
<p>리소스의 분류<br>1.Collection<br>2.Member    </p>
<ul>
<li><p>Collection : 여러 리소스 목록<br>Read(List), Create</p>
</li>
<li><p>Member : 개별 리소스<br>Read(Detail), Update, Delete</p>
</li>
</ul>
<p>Collection 표현 : <a href="http://hostname/restorants" target="_blank" rel="noopener">http://hostname/restorants</a><br>Member표현 : <a href="http://hostname/restorants/{id}" target="_blank" rel="noopener">http://hostname/restorants/{id}</a>, {id} : 개별 리소스의 id   </p>
<p>JSON(JavaScript Object Notation)<br>결과를 받거나 넘길때 사용되는 포맷<br>자바 스크립트에서 오브젝를 표현할때 쓰는 방식을 여러 언어 또는 환경에서 표준으로 사용할 수 있음  </p>
<p>JSON 에서 Member 표현</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;id&quot;:2019,</span><br><span class="line">&quot;name&quot;:&quot;식당&quot;,</span><br><span class="line">&quot;address&quot;:&quot;골목&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JSON 에서 Collection 표현</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">&#123;</span><br><span class="line">&quot;id&quot;:2001,</span><br><span class="line">&quot;name&quot;:&quot;오디세이&quot;,</span><br><span class="line">&quot;address&quot;:&quot;우주&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">&quot;id&quot;:2019,</span><br><span class="line">&quot;name&quot;:&quot;식당&quot;,</span><br><span class="line">&quot;address&quot;:&quot;골목&quot;</span><br><span class="line">&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>APIs를 Rest API에 맞춰 정의하기<br>가게 목록 얻기(read Collection)<br>GET /restaurants<br>개별 가게 정보 얻기(read Member)<br>GET /restaurants/{id}<br>가게 추가(create Collection)<br>POST /restaurants<br>가게 수정(update Member)<br>PATCH /restaurants/{id}<br>가게 삭제(delete Member)<br>DELETE /restaurants/{id}    </p>
]]></content>
      <categories>
        <category>Study</category>
        <category>Spring Boot Project</category>
      </categories>
      <tags>
        <tag>spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title>10. 의존성 주입 (DI)</title>
    <url>/2020/08/12/hexo_springboot_1_10/</url>
    <content><![CDATA[<h1 id="스프링-부트-프로젝트"><a href="#스프링-부트-프로젝트" class="headerlink" title="스프링 부트 프로젝트"></a>스프링 부트 프로젝트</h1><h3 id="레스토랑-예약-사이트-만들기"><a href="#레스토랑-예약-사이트-만들기" class="headerlink" title="레스토랑 예약 사이트 만들기"></a>레스토랑 예약 사이트 만들기</h3><h4 id="10-의존성-주입-DI"><a href="#10-의존성-주입-DI" class="headerlink" title="10. 의존성 주입 (DI)"></a>10. 의존성 주입 (DI)</h4><p>의존성 주입 (Dependency injection)   </p>
<p>의존성 : 의존 관계, 둘 이상의 객체가 서로 협력하는 방법에 대한 것<br>ex1) A는 B에 의존 =&gt; A가 B를 사용한다 =&gt; B의 변화가 A에 영향을 끼친다 =&gt; 효과적인 관리가 필요하다<br>ex2) RestaurantController는 RestaurantRepository에 의존한다.  </p>
<p>레스토랑 컨트롤러에서 저장소 객체를 생성하고 멤버변수로 사용했었는데,<br>이런 작업을 다른 곳에서 할수 있다.<br>=&gt; Spring IOC Container</p>
<p>DI는 이런 객체간의 의존 관계를 Spring이 직접 관리해주도록 하는 것<br>DI를 위해 두가지 어노테이션을 지원한다.<br>@Component<br>@Autowired  </p>
<p>Demo<br>Repository  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Component &#x2F;&#x2F;Spring이 직접 관리하도록</span><br><span class="line">public class RestaurantRepository &#123;</span><br><span class="line">~</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Controller  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RestController </span><br><span class="line">public class RestaurantController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired &#x2F;&#x2F;Spring이 알아서 객체를 생성해서 멤버변수에 넣어준다.</span><br><span class="line">    private RestaurantRepository repository;</span><br><span class="line"></span><br><span class="line">~</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>주의해야 할 것은 WebMvcTest에서 제대로 사용되지 못하기 때문에<br>직접 의존성 주입을 해야할 필요가 있다   </p>
<p>Controller Test     </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RunWith(SpringRunner.class) </span><br><span class="line">@WebMvcTest(RestaurantController.class)</span><br><span class="line">public class RestaurantControllerTest &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private MockMvc mvc;</span><br><span class="line"></span><br><span class="line">    @SpyBean &#x2F;&#x2F;WebMvcTest에서는 제대로된 저장소를 사용할수 없기때문에 직접 의존성 주입</span><br><span class="line">    private RestaurantRepository restaurantRepository;</span><br><span class="line"></span><br><span class="line">~</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>의존성 주입을 통해 얻을 수 있는 이점은<br>객체 간의 의존성을 좀더 유연하게 해준다.<br>예를 들어 저장소를 interface로 만들어 의존성 주입을 하면<br>여러 구현체를 만들수 있고 얼마든지 다른 형태로 변경할 수 있다.<br>(Controller가 직접적으로 저장소에 의존하고 있던 것을 분리할 수 있다.)     </p>
<p>저장소  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package kr.co.fastcampus.eatgo.domain;</span><br><span class="line"></span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public interface RestaurantRepository &#123;</span><br><span class="line">    List&lt;Restaurant&gt; findAll();</span><br><span class="line"></span><br><span class="line">    Restaurant findById(Long id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>구현체</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package kr.co.fastcampus.eatgo.domain;</span><br><span class="line"></span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">@Component &#x2F;&#x2F;Spring이 직접 관리하도록</span><br><span class="line">public class RestaurantRepositoryImpl implements RestaurantRepository &#123;</span><br><span class="line"></span><br><span class="line">~</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Controller</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class RestaurantController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired </span><br><span class="line">    private RestaurantRepository repository; &#x2F;&#x2F;구현체가 아닌 인터페이스를 사용할 수 있다  </span><br><span class="line"></span><br><span class="line">~</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>주의해야 할 것은 SpyBean에서 실질적인 구현이 없는것은 사용할 수 없으므로<br>어떤 구현을 사용할 것인지 입력해주어야 한다.   </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RunWith(SpringRunner.class) </span><br><span class="line">@WebMvcTest(RestaurantController.class) </span><br><span class="line">public class RestaurantControllerTest &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private MockMvc mvc;</span><br><span class="line"></span><br><span class="line">    @SpyBean(RestaurantRepositoryImpl.class) &#x2F;&#x2F;어떤 구현체를 사용할 것인지 입력해줘야 한다     </span><br><span class="line">    private RestaurantRepository restaurantRepository;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Study</category>
        <category>Spring Boot Project</category>
      </categories>
      <tags>
        <tag>spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title>07. 가게 목록, 가게 상세</title>
    <url>/2020/08/12/hexo_springboot_1_07/</url>
    <content><![CDATA[<h1 id="스프링-부트-프로젝트"><a href="#스프링-부트-프로젝트" class="headerlink" title="스프링 부트 프로젝트"></a>스프링 부트 프로젝트</h1><h3 id="레스토랑-예약-사이트-만들기"><a href="#레스토랑-예약-사이트-만들기" class="headerlink" title="레스토랑 예약 사이트 만들기"></a>레스토랑 예약 사이트 만들기</h3><h4 id="07-가게-목록-가게-상세"><a href="#07-가게-목록-가게-상세" class="headerlink" title="07. 가게 목록, 가게 상세"></a>07. 가게 목록, 가게 상세</h4><p>가게 목록 Demo<br>Controller  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package kr.co.fastcampus.eatgo.interfaces;</span><br><span class="line"></span><br><span class="line">import kr.co.fastcampus.eatgo.domain.Restaurant;</span><br><span class="line">import org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">@RestController &#x2F;&#x2F;Rest API 를 사용하는 컨트롤러 임을 명시</span><br><span class="line">public class RestaurantController &#123;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;&#x2F;restaurants&quot;)</span><br><span class="line">    public List&lt;Restaurant&gt; list() &#123;</span><br><span class="line">        List&lt;Restaurant&gt; restaurants &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        Restaurant restaurant &#x3D; new Restaurant(1004l, &quot;Bob zip&quot;,&quot;Seoul&quot;);</span><br><span class="line">        restaurants.add(restaurant);</span><br><span class="line">        &#x2F;&#x2F;웹에서 출력은 아래와 같다    </span><br><span class="line">        &#x2F;&#x2F;[&#123;&quot;name&quot;:&quot;Bob zip&quot;,&quot;address&quot;:&quot;Seoul&quot;,&quot;id&quot;:1004,&quot;information&quot;:&quot;Bob zip in Seoul&quot;&#125;]</span><br><span class="line">        return restaurants;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Controller TEST</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package kr.co.fastcampus.eatgo.interfaces;</span><br><span class="line"></span><br><span class="line">import org.junit.Test;</span><br><span class="line">import org.junit.runner.RunWith;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;</span><br><span class="line">import org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line">import org.springframework.test.web.servlet.MockMvc;</span><br><span class="line">import org.springframework.test.web.servlet.request.MockMvcRequestBuilders;</span><br><span class="line"></span><br><span class="line">import static org.hamcrest.core.StringContains.containsString;</span><br><span class="line">import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;</span><br><span class="line">import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;</span><br><span class="line"></span><br><span class="line">@RunWith(SpringRunner.class) &#x2F;&#x2F;spring을 이용하여 테스트 실행</span><br><span class="line">@WebMvcTest(RestaurantController.class) &#x2F;&#x2F;특정 컨트롤러를 테스트한다고 명시</span><br><span class="line">public class RestaurantControllerTest &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired &#x2F;&#x2F;spring에서 알아서 넣어줄 수 있도록</span><br><span class="line">    private MockMvc mvc; &#x2F;&#x2F;spring mvc 테스트를 위한 객체    </span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void list() throws Exception &#123;</span><br><span class="line">        mvc.perform(MockMvcRequestBuilders.get(&quot;&#x2F;restaurants&quot;))</span><br><span class="line">                .andExpect(status().isOk())</span><br><span class="line">                .andExpect(content().string(</span><br><span class="line">                        containsString(&quot;\&quot;id\&quot;:1004&quot;)</span><br><span class="line">                ))</span><br><span class="line">                .andExpect(content().string(</span><br><span class="line">                        containsString(&quot;\&quot;name\&quot;:\&quot;Bob zip\&quot;&quot;)</span><br><span class="line">                ));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>가게 상세 Demo<br>가게 저장소 생성 in domain   </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package kr.co.fastcampus.eatgo.domain;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public class RestaurantRepository &#123;</span><br><span class="line">    List&lt;Restaurant&gt; restaurants &#x3D; new ArrayList&lt;&gt;(); &#x2F;&#x2F;가게마다 if문을 쓰지 않기 위해 List로 가게 관리</span><br><span class="line">                                                      &#x2F;&#x2F;여러 메서드에서 사용될 수 있도록 멤버변수로    </span><br><span class="line"></span><br><span class="line">    public RestaurantRepository() &#123;</span><br><span class="line">        restaurants.add(new Restaurant(1004L,&quot;Bob zip&quot;,&quot;Seoul&quot;));</span><br><span class="line">        restaurants.add(new Restaurant(2020L,&quot;Cyber Food&quot;,&quot;Seoul&quot;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public List&lt;Restaurant&gt; findAll() &#123;</span><br><span class="line">        return restaurants;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Restaurant findById(Long id) &#123;   &#x2F;&#x2F;찾는 기능을 UI에 구현하지 않고 저장소에서 구현    </span><br><span class="line">        return restaurants.stream()</span><br><span class="line">                .filter(r -&gt; r.getId().equals(id))</span><br><span class="line">                .findFirst()</span><br><span class="line">                .orElse(null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Controller</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package kr.co.fastcampus.eatgo.interfaces;</span><br><span class="line"></span><br><span class="line">import kr.co.fastcampus.eatgo.domain.Restaurant;</span><br><span class="line">import kr.co.fastcampus.eatgo.domain.RestaurantRepository;</span><br><span class="line">import org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">@RestController &#x2F;&#x2F;Rest API 를 사용하는 컨트롤러 임을 명시</span><br><span class="line">public class RestaurantController &#123;</span><br><span class="line"></span><br><span class="line">    private RestaurantRepository repository &#x3D; new RestaurantRepository(); &#x2F;&#x2F;저장소 객체 선언</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;UI 레이어는 사용자와 내부의 비즈니스 로직, 도메인 모델들이 서로 상관 없도록 중간 다리 역할만 하는 것이 좋다</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;&#x2F;restaurants&quot;)</span><br><span class="line">    public List&lt;Restaurant&gt; list() &#123;</span><br><span class="line"></span><br><span class="line">        List&lt;Restaurant&gt; restaurants &#x3D; repository.findAll(); &#x2F;&#x2F;API들의 중복제거를 위해 가게 저장소 사용</span><br><span class="line">        return restaurants;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;&#x2F;restaurants&#x2F;&#123;id&#125;&quot;) &#x2F;&#x2F;&#123;&#125;로 바뀌는 부분을 매핑가능</span><br><span class="line">    public Restaurant detail(@PathVariable(&quot;id&quot;) Long id) &#123; &#x2F;&#x2F;주소의 파라미터를 활용할 수 있음</span><br><span class="line"></span><br><span class="line">        Restaurant restaurant &#x3D; repository.findById(id); &#x2F;&#x2F;저장소에서 기능을 생성하여 사용</span><br><span class="line">        return restaurant;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Controller Test</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package kr.co.fastcampus.eatgo.interfaces;</span><br><span class="line"></span><br><span class="line">import org.junit.Test;</span><br><span class="line">import org.junit.runner.RunWith;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;</span><br><span class="line">import org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line">import org.springframework.test.web.servlet.MockMvc;</span><br><span class="line">import org.springframework.test.web.servlet.request.MockMvcRequestBuilders;</span><br><span class="line"></span><br><span class="line">import static org.hamcrest.core.StringContains.containsString;</span><br><span class="line">import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;</span><br><span class="line">import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;</span><br><span class="line"></span><br><span class="line">@RunWith(SpringRunner.class) &#x2F;&#x2F;spring을 이용하여 테스트 실행</span><br><span class="line">@WebMvcTest(RestaurantController.class) &#x2F;&#x2F;특정 컨트롤러를 테스트한다고 명시</span><br><span class="line">public class RestaurantControllerTest &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired &#x2F;&#x2F;spring에서 알아서 넣어줄 수 있도록</span><br><span class="line">    private MockMvc mvc;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void list() throws Exception &#123;</span><br><span class="line">        mvc.perform(MockMvcRequestBuilders.get(&quot;&#x2F;restaurants&quot;))</span><br><span class="line">                .andExpect(status().isOk())</span><br><span class="line">                .andExpect(content().string(</span><br><span class="line">                        containsString(&quot;\&quot;id\&quot;:1004&quot;)</span><br><span class="line">                ))</span><br><span class="line">                .andExpect(content().string(</span><br><span class="line">                        containsString(&quot;\&quot;name\&quot;:\&quot;Bob zip\&quot;&quot;)</span><br><span class="line">                ));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void detail() throws Exception &#123;</span><br><span class="line">        mvc.perform(MockMvcRequestBuilders.get(&quot;&#x2F;restaurants&#x2F;1004&quot;))</span><br><span class="line">                .andExpect(status().isOk())</span><br><span class="line">                .andExpect(content().string(</span><br><span class="line">                        containsString(&quot;\&quot;id\&quot;:1004&quot;)</span><br><span class="line">                ))</span><br><span class="line">                .andExpect(content().string(</span><br><span class="line">                        containsString(&quot;\&quot;name\&quot;:\&quot;Bob zip\&quot;&quot;)</span><br><span class="line">                ));</span><br><span class="line">        mvc.perform(MockMvcRequestBuilders.get(&quot;&#x2F;restaurants&#x2F;2020&quot;))</span><br><span class="line">                .andExpect(status().isOk())</span><br><span class="line">                .andExpect(content().string(</span><br><span class="line">                        containsString(&quot;\&quot;id\&quot;:2020&quot;)</span><br><span class="line">                ))</span><br><span class="line">                .andExpect(content().string(</span><br><span class="line">                        containsString(&quot;\&quot;name\&quot;:\&quot;Cyber Food\&quot;&quot;)</span><br><span class="line">                ));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Study</category>
        <category>Spring Boot Project</category>
      </categories>
      <tags>
        <tag>spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title>11. 레이어 분리</title>
    <url>/2020/08/12/hexo_springboot_1_11/</url>
    <content><![CDATA[<h1 id="스프링-부트-프로젝트"><a href="#스프링-부트-프로젝트" class="headerlink" title="스프링 부트 프로젝트"></a>스프링 부트 프로젝트</h1><h3 id="레스토랑-예약-사이트-만들기"><a href="#레스토랑-예약-사이트-만들기" class="headerlink" title="레스토랑 예약 사이트 만들기"></a>레스토랑 예약 사이트 만들기</h3><h4 id="11-레이어-분리"><a href="#11-레이어-분리" class="headerlink" title="11. 레이어 분리"></a>11. 레이어 분리</h4><p>UI Layer는 interfaces 패키지로 분리하여 Controller를 저장했다.<br>Domain Layer는 domain 패키지로 분리하여 도메인 모델과 저장소를 저장했다.   </p>
<p>Application Layer를 중간에 추가할 것이다.<br>application 패키지 추가 및 MenuItem 도메인 모델 추가    </p>
<p>application이 없을때 menu를 사용하려면    </p>
<p>MenuItem Repository</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class MenuItemRepositoryImpl implements MenuItemRepository&#123;</span><br><span class="line"></span><br><span class="line">    private List&lt;MenuItem&gt; menuitems &#x3D; new ArrayList&lt;MenuItem&gt;();</span><br><span class="line">    </span><br><span class="line">    public MenuItemRepositoryImpl() &#123;</span><br><span class="line">        menuitems.add(new MenuItem(&quot;Kimchi&quot;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public List&lt;MenuItem&gt; findAllByRestaurantId(Long restaurantId) &#123;</span><br><span class="line">        return this.menuitems;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Controller</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Autowired &#x2F;&#x2F;Spring이 알아서 객체를 생성해서 멤버변수에 넣어준다.</span><br><span class="line">private RestaurantRepository restaurantRepository;</span><br><span class="line"></span><br><span class="line">@Autowired</span><br><span class="line">private MenuItemRepository menuItemRepository;</span><br><span class="line"></span><br><span class="line">@GetMapping(&quot;&#x2F;restaurants&#x2F;&#123;id&#125;&quot;) &#x2F;&#x2F;&#123;&#125;로 바뀌는 부분을 매핑가능</span><br><span class="line">public Restaurant detail(@PathVariable(&quot;id&quot;) Long id) &#123; &#x2F;&#x2F;주소의 파라미터를 활용할 수 있음</span><br><span class="line"></span><br><span class="line">    Restaurant restaurant &#x3D; restaurantRepository.findById(id); &#x2F;&#x2F;저장소에서 기능을 생성하여 사용</span><br><span class="line"></span><br><span class="line">    List&lt;MenuItem&gt; menuItems &#x3D; menuItemRepository.findAllByRestaurantId(id);</span><br><span class="line">    restaurant.setMenuItems(menuItems);</span><br><span class="line"></span><br><span class="line">    return restaurant;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>위처럼 Controller가 복잡해진다…<br>때문에 application layer를 추가해서 기능적인 부분을 분리한다.<br>하려고 하는것은 다음과 같다<br>application layer 역할을 해줄 RestaurantService 객체 생성<br>Service에서 구현된 기능을 Controller에서 사용<br>repository에 대한 의존성을 Service로 이관     </p>
<p>RestaurantService</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Service &#x2F;&#x2F;Spring에서 application으로 정의</span><br><span class="line">public class RestaurantService &#123;</span><br><span class="line">    &#x2F;&#x2F;의존성 연결을 Service에서 미리</span><br><span class="line">    @Autowired </span><br><span class="line">    private RestaurantRepository restaurantRepository;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private MenuItemRepository menuItemRepository;</span><br><span class="line">    </span><br><span class="line">    public RestaurantService(RestaurantRepository restaurantRepository, MenuItemRepository menuItemRepository) &#123;</span><br><span class="line">        this.restaurantRepository &#x3D; restaurantRepository;</span><br><span class="line">        this.menuItemRepository &#x3D; menuItemRepository;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;Controller에서 사용될 기능 구현    </span><br><span class="line">    public List&lt;Restaurant&gt; getRestaurants() &#123;</span><br><span class="line">        List&lt;Restaurant&gt; restaurants &#x3D; restaurantRepository.findAll();</span><br><span class="line">        return restaurants;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Restaurant getRestaurant(Long id) &#123;</span><br><span class="line">        &#x2F;&#x2F;가게 정보 </span><br><span class="line">        Restaurant restaurant &#x3D;  restaurantRepository.findById(id);</span><br><span class="line">        &#x2F;&#x2F;메뉴 정보 </span><br><span class="line">        List&lt;MenuItem&gt; menuItems &#x3D; menuItemRepository.findAllByRestaurantId(id);</span><br><span class="line">        restaurant.setMenuItems(menuItems);</span><br><span class="line"></span><br><span class="line">        return restaurant;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Controller 처럼 Service 또한 Test를 하자<br>Service Test    </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class RestaurantServiceTest &#123;</span><br><span class="line"></span><br><span class="line">    private RestaurantService restaurantService;</span><br><span class="line">    private RestaurantRepository restaurantRepository;</span><br><span class="line">    private MenuItemRepository menuItemRepository;</span><br><span class="line"></span><br><span class="line">    @Before &#x2F;&#x2F;모든 Test가 실행되기 전에 수행 됨</span><br><span class="line">    public void setUp() &#123;</span><br><span class="line">        restaurantRepository &#x3D; new RestaurantRepositoryImpl();</span><br><span class="line">        menuItemRepository &#x3D; new MenuItemRepositoryImpl();</span><br><span class="line">        restaurantService &#x3D; new RestaurantService(restaurantRepository,menuItemRepository);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void getRestaurants() &#123;</span><br><span class="line">        List&lt;Restaurant&gt; restaurants &#x3D; restaurantService.getRestaurants();</span><br><span class="line"></span><br><span class="line">        Restaurant restaurant &#x3D; restaurants.get(0);</span><br><span class="line">        assertThat(restaurant.getId(), is(1004L));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void getRestaurant() &#123;</span><br><span class="line">        Restaurant restaurant &#x3D; restaurantService.getRestaurant(1004L);</span><br><span class="line"></span><br><span class="line">        assertThat(restaurant.getId(), is(1004L));</span><br><span class="line"></span><br><span class="line">        MenuItem menuItem &#x3D; restaurant.getMenuItems().get(0);</span><br><span class="line"></span><br><span class="line">        assertThat(menuItem.getName(), is(&quot;Kimchi&quot;));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Controller가 단순화 된다.     </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class RestaurantController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired &#x2F;&#x2F;Service만 의존성 연결</span><br><span class="line">    private RestaurantService restaurantService;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;&#x2F;restaurants&quot;)</span><br><span class="line">    public List&lt;Restaurant&gt; list() &#123;</span><br><span class="line"></span><br><span class="line">        List&lt;Restaurant&gt; restaurants &#x3D; restaurantService.getRestaurants();</span><br><span class="line">        return restaurants;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;&#x2F;restaurants&#x2F;&#123;id&#125;&quot;)</span><br><span class="line">    public Restaurant detail(@PathVariable(&quot;id&quot;) Long id) &#123;</span><br><span class="line"></span><br><span class="line">        Restaurant restaurant &#x3D; restaurantService.getRestaurant(id); &#x2F;&#x2F;기본 정보 + 메뉴 정보를 가져올 새로운 메서드</span><br><span class="line">        &#x2F;&#x2F;repository가 저장소 역할을 했다면, 복잡한 처리들을 저장할 application layer</span><br><span class="line"></span><br><span class="line">        return restaurant;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Study</category>
        <category>Spring Boot Project</category>
      </categories>
      <tags>
        <tag>spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title>13. 가짜 객체</title>
    <url>/2020/08/12/hexo_springboot_1_13/</url>
    <content><![CDATA[<h1 id="스프링-부트-프로젝트"><a href="#스프링-부트-프로젝트" class="headerlink" title="스프링 부트 프로젝트"></a>스프링 부트 프로젝트</h1><h3 id="레스토랑-예약-사이트-만들기"><a href="#레스토랑-예약-사이트-만들기" class="headerlink" title="레스토랑 예약 사이트 만들기"></a>레스토랑 예약 사이트 만들기</h3><h4 id="13-가짜-객체"><a href="#13-가짜-객체" class="headerlink" title="13. 가짜 객체"></a>13. 가짜 객체</h4><p>의존성 주입이 너무 많이 된 경우,<br>테스트 하고자 하는 대상 외의 것들에 대한 의존성이 너무 커져서 테스트가 어려워지고<br>테스트를 진행하기 위해 의존하는 부분들을 모두 만들어줘야 한다.     </p>
<p>이때 사용할만한 것이 Mock Object.<br>Mock Object를 만들기 위해서 spring에서는 Mockito라는 framework 사용    </p>
<p>Spring은 기본적으로 POJO(Plain Old Java Object),<br>전통적인 자바 오브젝트를 사용할 것을 권장하고 지원한다. (=&gt;Mockito)  </p>
<p>Controller Test, MockBean</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RunWith(SpringRunner.class)</span><br><span class="line">@WebMvcTest(RestaurantController.class)</span><br><span class="line">public class RestaurantControllerTest &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private MockMvc mvc;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;Test하려는 대상은 RestaurantController 이므로 그 외의 대상을 가짜로 배치하려고 함</span><br><span class="line">    @MockBean</span><br><span class="line">    private RestaurantService restaurantService;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void list() throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;가짜 객체 생성, 가짜 처리 정의(willReturn)</span><br><span class="line">        &#x2F;&#x2F;실제 서비스, 저장소와는 무관하게 동작</span><br><span class="line">        List&lt;Restaurant&gt; restaurants &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        restaurants.add(new Restaurant(1004L,&quot;No Bob zip&quot;,&quot;Seoul&quot;));</span><br><span class="line">        given(restaurantService.getRestaurants()).willReturn(restaurants);</span><br><span class="line"></span><br><span class="line">        mvc.perform(MockMvcRequestBuilders.get(&quot;&#x2F;restaurants&quot;))</span><br><span class="line">                .andExpect(status().isOk())</span><br><span class="line">                .andExpect(content().string(</span><br><span class="line">                        containsString(&quot;\&quot;id\&quot;:1004&quot;)</span><br><span class="line">                ))</span><br><span class="line">                .andExpect(content().string(</span><br><span class="line">                        containsString(&quot;\&quot;name\&quot;:\&quot;No Bob zip\&quot;&quot;)</span><br><span class="line">                ));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void detail() throws Exception &#123;</span><br><span class="line">        Restaurant restaurant1 &#x3D; new Restaurant(1004L,&quot;No Bob zip&quot;,&quot;Seoul&quot;);</span><br><span class="line">        restaurant1.addMenuItem(new MenuItem(&quot;Kimchi&quot;));</span><br><span class="line">        given(restaurantService.getRestaurant(1004L)).willReturn(restaurant1);</span><br><span class="line"></span><br><span class="line">        Restaurant restaurant2 &#x3D; new Restaurant(2020L,&quot;Cyber Food&quot;,&quot;Seoul&quot;);</span><br><span class="line">        restaurant2.addMenuItem(new MenuItem(&quot;Kimchi&quot;));</span><br><span class="line">        given(restaurantService.getRestaurant(2020L)).willReturn(restaurant2);</span><br><span class="line"></span><br><span class="line">        mvc.perform(MockMvcRequestBuilders.get(&quot;&#x2F;restaurants&#x2F;1004&quot;))</span><br><span class="line">                .andExpect(status().isOk())</span><br><span class="line">                .andExpect(content().string(</span><br><span class="line">                        containsString(&quot;\&quot;id\&quot;:1004&quot;)</span><br><span class="line">                ))</span><br><span class="line">                .andExpect(content().string(</span><br><span class="line">                        containsString(&quot;\&quot;name\&quot;:\&quot;No Bob zip\&quot;&quot;)</span><br><span class="line">                ))</span><br><span class="line">                .andExpect(content().string(</span><br><span class="line">                        containsString(&quot;Kimchi&quot;)</span><br><span class="line">                ));</span><br><span class="line"></span><br><span class="line">        mvc.perform(MockMvcRequestBuilders.get(&quot;&#x2F;restaurants&#x2F;2020&quot;))</span><br><span class="line">                .andExpect(status().isOk())</span><br><span class="line">                .andExpect(content().string(</span><br><span class="line">                        containsString(&quot;\&quot;id\&quot;:2020&quot;)</span><br><span class="line">                ))</span><br><span class="line">                .andExpect(content().string(</span><br><span class="line">                        containsString(&quot;\&quot;name\&quot;:\&quot;Cyber Food\&quot;&quot;)</span><br><span class="line">                ));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Service Test, Mock, Mockito</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class RestaurantServiceTest &#123;</span><br><span class="line"></span><br><span class="line">    private RestaurantService restaurantService;</span><br><span class="line"></span><br><span class="line">    @Mock &#x2F;&#x2F;저장소를 가짜로 주입</span><br><span class="line">    private RestaurantRepository restaurantRepository;</span><br><span class="line">    @Mock</span><br><span class="line">    private MenuItemRepository menuItemRepository;</span><br><span class="line"></span><br><span class="line">    @Before &#x2F;&#x2F;모든 Test가 실행되기 전에 수행 됨</span><br><span class="line">    public void setUp() &#123;</span><br><span class="line">        MockitoAnnotations.initMocks(this); &#x2F;&#x2F;현재 Class의 Mock annotation이 붙어있는 곳에 객체 설정</span><br><span class="line"></span><br><span class="line">        mockRestaurantRepository();</span><br><span class="line">        mockMenuItemRepository();</span><br><span class="line"></span><br><span class="line">        restaurantService &#x3D; new RestaurantService(restaurantRepository,menuItemRepository);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void mockRestaurantRepository() &#123;</span><br><span class="line">        &#x2F;&#x2F;가짜 restaurant 생성</span><br><span class="line">        List&lt;Restaurant&gt; restaurants &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        Restaurant restaurant &#x3D; new Restaurant(1004L,&quot;Bob zip&quot;,&quot;Seoul&quot;);</span><br><span class="line">        restaurants.add(restaurant);</span><br><span class="line"></span><br><span class="line">        given(restaurantRepository.findAll()).willReturn(restaurants);</span><br><span class="line"></span><br><span class="line">        given(restaurantRepository.findById(1004L)).willReturn(restaurant);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void mockMenuItemRepository() &#123;</span><br><span class="line">        &#x2F;&#x2F;가짜 Menu Item 생성   </span><br><span class="line">        List&lt;MenuItem&gt; menuItems &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        MenuItem menuItem &#x3D; new MenuItem(&quot;Kimchi&quot;);</span><br><span class="line">        menuItems.add(menuItem);</span><br><span class="line"></span><br><span class="line">        given(menuItemRepository.findAllByRestaurantId(1004L)).willReturn(menuItems);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void getRestaurants() &#123;</span><br><span class="line">        List&lt;Restaurant&gt; restaurants &#x3D; restaurantService.getRestaurants();</span><br><span class="line"></span><br><span class="line">        Restaurant restaurant &#x3D; restaurants.get(0);</span><br><span class="line">        assertThat(restaurant.getId(), is(1004L));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void getRestaurant() &#123;</span><br><span class="line">        Restaurant restaurant &#x3D; restaurantService.getRestaurant(1004L);</span><br><span class="line"></span><br><span class="line">        assertThat(restaurant.getId(), is(1004L));</span><br><span class="line"></span><br><span class="line">        MenuItem menuItem &#x3D; restaurant.getMenuItems().get(0);</span><br><span class="line"></span><br><span class="line">        assertThat(menuItem.getName(), is(&quot;Kimchi&quot;));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Study</category>
        <category>Spring Boot Project</category>
      </categories>
      <tags>
        <tag>spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title>14. 가게 추가</title>
    <url>/2020/08/12/hexo_springboot_1_14/</url>
    <content><![CDATA[<h1 id="스프링-부트-프로젝트"><a href="#스프링-부트-프로젝트" class="headerlink" title="스프링 부트 프로젝트"></a>스프링 부트 프로젝트</h1><h3 id="레스토랑-예약-사이트-만들기"><a href="#레스토랑-예약-사이트-만들기" class="headerlink" title="레스토랑 예약 사이트 만들기"></a>레스토랑 예약 사이트 만들기</h3><h4 id="14-가게-추가"><a href="#14-가게-추가" class="headerlink" title="14. 가게 추가"></a>14. 가게 추가</h4><p>POST 메서드를 사용하여 /restaurants 에 추가할 것임<br>성공하면 HTTP status 201<br>넣을 레스토랑 정보는 Header에 담아 보내게 되는데<br>Header Location에 리소스 주소가 들어가게 된다.   </p>
<p>Client에서 보내준 결과를 JSON parser가 수행되도록 할 수 있다.<br>Empty {}</p>
<p>HTTPie 활용하여 확인할 것이다.<br>HTTPie 설치 (MAC OS)</p>
<figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> brew install httpie</span></span><br></pre></td></tr></table></figure>

<p>Controller에 가게를 추가하는 작업을 추가할 것이고,<br>Service에 실제로 기능을 구현할 것이다.   </p>
<p>1.POST 요청을 처리하기 위한 Controller 생성</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@PostMapping(&quot;&#x2F;restaurants&quot;)</span><br><span class="line">public ResponseEntity&lt;?&gt; create(@RequestBody Restaurant resource) &#x2F;&#x2F;content로 넘겨준 내용을 매개변수로 받기</span><br><span class="line">        throws URISyntaxException &#123;</span><br><span class="line"></span><br><span class="line">    String name&#x3D;resource.getName();</span><br><span class="line">    String address&#x3D;resource.getAddress();</span><br><span class="line"></span><br><span class="line">    Restaurant restaurant &#x3D; new Restaurant(1234L,name,address);</span><br><span class="line">    restaurantService.addRestaurant(restaurant);</span><br><span class="line"></span><br><span class="line">    URI location &#x3D; new URI(&quot;&#x2F;restaurants&#x2F;&quot;+restaurant.getId());</span><br><span class="line">    return ResponseEntity.created(location).body(&quot;&#123;&#125;&quot;); &#x2F;&#x2F;빈 내용</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Controller Test</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void create() throws Exception &#123;</span><br><span class="line">    mvc.perform(post(&quot;&#x2F;restaurants&quot;)</span><br><span class="line">            .contentType(MediaType.APPLICATION_JSON) &#x2F;&#x2F;JSON 타입임을 알려준다</span><br><span class="line">            .content(&quot;&#123;\&quot;name\&quot;:\&quot;BeRyong\&quot;,\&quot;address\&quot;:\&quot;Busan\&quot;&#125;&quot;)) &#x2F;&#x2F;JSON 타입으로 데이터 전달</span><br><span class="line">            .andExpect(status().isCreated())</span><br><span class="line">            .andExpect(header().string(&quot;location&quot;, &quot;&#x2F;restaurants&#x2F;1234&quot;))</span><br><span class="line">            .andExpect(content().string(&quot;&#123;&#125;&quot;)); &#x2F;&#x2F;비어있는지 확인</span><br><span class="line"></span><br><span class="line">    verify(restaurantService).addRestaurant(any()); &#x2F;&#x2F;any():뭘 넣든지 작동할 수 있도록, Mockito에서 제공</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.Service 및 Repository 추가<br>Restaurant Service Test</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void addRestaurant() &#123;</span><br><span class="line">    Restaurant restaurant &#x3D; new Restaurant(&quot;BeRyong&quot;, &quot;Busan&quot;);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;가짜 saved</span><br><span class="line">    Restaurant saved &#x3D; new Restaurant(1234L,&quot;BeRyong&quot;, &quot;Busan&quot;);</span><br><span class="line">    given(restaurantRepository.save(any())).willReturn(saved);</span><br><span class="line"></span><br><span class="line">    Restaurant created &#x3D; restaurantService.addRestaurant(restaurant);</span><br><span class="line"></span><br><span class="line">    assertThat(created.getId(), is(1234L));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Restaurant Service</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public Restaurant addRestaurant(Restaurant restaurant) &#123;</span><br><span class="line">    return restaurantRepository.save(restaurant);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Restaurant Repository Test</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class RestaurantRepositoryImplTest &#123;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void save() &#123;</span><br><span class="line">        RestaurantRepository repository &#x3D; new RestaurantRepositoryImpl();</span><br><span class="line"></span><br><span class="line">        int oldCount &#x3D; repository.findAll().size();</span><br><span class="line">        Restaurant restaurant &#x3D; new Restaurant(&quot;BeRyong&quot;,&quot;Busan&quot;);</span><br><span class="line">        repository.save(restaurant);</span><br><span class="line"></span><br><span class="line">        assertThat(restaurant.getId(), is(1234L)); &#x2F;&#x2F;저장된 뒤 id가 생성되었는지 확인    </span><br><span class="line">        int newCount &#x3D; repository.findAll().size();</span><br><span class="line"></span><br><span class="line">        assertThat(newCount-oldCount, is(1)); &#x2F;&#x2F;개수가 늘어났는지 확인</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Restaurant Repository</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Restaurant save(Restaurant restaurant) &#123;</span><br><span class="line">    restaurant.setId(1234L);</span><br><span class="line">    restaurants.add(restaurant);</span><br><span class="line">    return restaurant;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>POST by HTTPie</p>
<figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> http POST localhost:8080/restaurants name=BeRyong address=Busan</span></span><br></pre></td></tr></table></figure>

<p>GET by HTTPie</p>
<figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> http GET localhost:8080/restaurants</span></span><br><span class="line"></span><br><span class="line">HTTP/1.1 200 </span><br><span class="line">Connection: keep-alive</span><br><span class="line">Content-Type: application/json;charset=UTF-8</span><br><span class="line">Date: Mon, 01 Jun 2020 21:07:17 GMT</span><br><span class="line">Keep-Alive: timeout=60</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        "address": "Seoul",</span><br><span class="line">        "id": 1004,</span><br><span class="line">        "information": "Bob zip in Seoul",</span><br><span class="line">        "menuItems": [],</span><br><span class="line">        "name": "Bob zip"</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        "address": "Seoul",</span><br><span class="line">        "id": 2020,</span><br><span class="line">        "information": "Cyber Food in Seoul",</span><br><span class="line">        "menuItems": [],</span><br><span class="line">        "name": "Cyber Food"</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        "address": "Busan",</span><br><span class="line">        "id": 1234,</span><br><span class="line">        "information": "BeRyong in Busan",</span><br><span class="line">        "menuItems": [],</span><br><span class="line">        "name": "BeRyong"</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Study</category>
        <category>Spring Boot Project</category>
      </categories>
      <tags>
        <tag>spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title>16. JPA</title>
    <url>/2020/08/12/hexo_springboot_1_16/</url>
    <content><![CDATA[<h1 id="스프링-부트-프로젝트"><a href="#스프링-부트-프로젝트" class="headerlink" title="스프링 부트 프로젝트"></a>스프링 부트 프로젝트</h1><h3 id="레스토랑-예약-사이트-만들기"><a href="#레스토랑-예약-사이트-만들기" class="headerlink" title="레스토랑 예약 사이트 만들기"></a>레스토랑 예약 사이트 만들기</h3><h4 id="16-JPA"><a href="#16-JPA" class="headerlink" title="16. JPA"></a>16. JPA</h4><p>데이터의 영속화(Persistence) 작업이 필요하다.<br>Java는 영속화에 대한 표준을 가지고 있다.<br>= JPA (Java Persistence API)    </p>
<p>Hibernate : JPA에서 유명한 Library<br>@Entity : Identifier로 구분되는 객체   </p>
<p>Spring Data JPA를 활용하여 쉽게 JPA를 사용할 수 있음  </p>
<p>H2 DBMS를 In-memory로 사용할 것임</p>
<p>build.gradle의 dependencies 부분에 아래와 같이 추가했다.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">	implementation &#39;org.springframework.boot:spring-boot-starter-web&#39;</span><br><span class="line">    &#x2F;&#x2F;추가1 Spring Data JPA</span><br><span class="line">	implementation &#39;org.springframework.boot:spring-boot-starter-data-jpa&#39;</span><br><span class="line">    &#x2F;&#x2F;추가2 H2 Database</span><br><span class="line">	implementation &#39;com.h2database:h2&#39;</span><br><span class="line"></span><br><span class="line">	compileOnly &#39;org.projectlombok:lombok&#39;</span><br><span class="line">	developmentOnly &#39;org.springframework.boot:spring-boot-devtools&#39;</span><br><span class="line">	annotationProcessor &#39;org.projectlombok:lombok&#39;</span><br><span class="line">	testImplementation &#39;org.springframework.boot:spring-boot-starter-test&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>View &gt; Tool Windows &gt; Gradle &gt; Refresh Gradle Dependencies</p>
<p>Restaurant 와 MenuItem 를 Entity로 정의  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Entity</span><br><span class="line">public class Restaurant &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private String address;</span><br><span class="line">    @Id</span><br><span class="line">    @GeneratedValue</span><br><span class="line">    private Long id;</span><br><span class="line"></span><br><span class="line">    @Transient &#x2F;&#x2F;영속화에서 제외   </span><br><span class="line">    private List&lt;MenuItem&gt; menuItems &#x3D; new ArrayList&lt;MenuItem&gt;();</span><br><span class="line"></span><br><span class="line">~</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Entity</span><br><span class="line">public class MenuItem &#123;</span><br><span class="line"></span><br><span class="line">    @Id &#x2F;&#x2F;Identifier for Entity</span><br><span class="line">    @GeneratedValue &#x2F;&#x2F;1부터 순차적으로 들어감</span><br><span class="line">    private Long id;</span><br><span class="line"></span><br><span class="line">    private Long restaurantId;</span><br><span class="line"></span><br><span class="line">~</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Repository 인터페이스를 통해 JPA 사용     </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface MenuItemRepository</span><br><span class="line">        extends CrudRepository&lt;MenuItem, Long&gt; &#123; &#x2F;&#x2F;인터페이스만 이용하여 JPA와 연결하여 사용 &lt;T, ID&gt;</span><br><span class="line">                                                 &#x2F;&#x2F;T : Entity의 타입, ID : id의 타입</span><br><span class="line">    List&lt;MenuItem&gt; findAllByRestaurantId(Long restaurantId);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface RestaurantRepository</span><br><span class="line">        extends CrudRepository&lt;Restaurant, Long&gt; &#123;</span><br><span class="line">    List&lt;Restaurant&gt; findAll();</span><br><span class="line"></span><br><span class="line">    Optional&lt;Restaurant&gt; findById(Long id); &#x2F;&#x2F;Optional : 존재할 수도 있지만 안할수도 있는 객체</span><br><span class="line">                                            &#x2F;&#x2F;NPE 회피..</span><br><span class="line">    Restaurant save(Restaurant restaurant);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Study</category>
        <category>Spring Boot Project</category>
      </categories>
      <tags>
        <tag>spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title>17. 프론트 엔드</title>
    <url>/2020/08/12/hexo_springboot_1_17/</url>
    <content><![CDATA[<h1 id="스프링-부트-프로젝트"><a href="#스프링-부트-프로젝트" class="headerlink" title="스프링 부트 프로젝트"></a>스프링 부트 프로젝트</h1><h3 id="레스토랑-예약-사이트-만들기"><a href="#레스토랑-예약-사이트-만들기" class="headerlink" title="레스토랑 예약 사이트 만들기"></a>레스토랑 예약 사이트 만들기</h3><h4 id="17-프론트-엔드"><a href="#17-프론트-엔드" class="headerlink" title="17. 프론트 엔드"></a>17. 프론트 엔드</h4><p>webpack / webpack-cli / webpack-dev-server 설치</p>
<figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="code"><pre><span class="line">npm install -save-dev webpack webpack-cli webpack-dev-server</span><br></pre></td></tr></table></figure>

<p>start 추가</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;eatgo-web&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;1.0.0&quot;,</span><br><span class="line">  &quot;description&quot;: &quot;EatGo Web Project&quot;,</span><br><span class="line">  &quot;main&quot;: &quot;src&#x2F;index.js&quot;,</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;start&quot;: &quot;webpack-dev-server --port 3000&quot;,</span><br><span class="line">    &quot;test&quot;: &quot;jest&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;author&quot;: &quot;Jeong In&quot;,</span><br><span class="line">  &quot;license&quot;: &quot;ISC&quot;,</span><br><span class="line">  &quot;devDependencies&quot;: &#123;</span><br><span class="line">    &quot;webpack&quot;: &quot;^4.43.0&quot;,</span><br><span class="line">    &quot;webpack-cli&quot;: &quot;^3.3.11&quot;,</span><br><span class="line">    &quot;webpack-dev-server&quot;: &quot;^3.11.0&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>webpack-dev-server 실행</p>
<figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="code"><pre><span class="line">npm start</span><br></pre></td></tr></table></figure>
<p>실제로는 아래와 같은 프로세스가 실행되어 있다   </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ps -ef | grep webpack</span><br><span class="line">                                          </span><br><span class="line">501 43162 43161   0 11:28PM ttys000    0:03.58 node &#x2F;Users&#x2F;ijeong-in&#x2F;Git_repo&#x2F;eatgo&#x2F;eatgo-web&#x2F;node_modules&#x2F;.bin&#x2F;webpack-dev-server --port 3000</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">index.html</span><br><span class="line">webpack-dev-server가 index.js를 main.js로 바꿔준다.</span><br></pre></td></tr></table></figure>
<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>EatGo</title>
</head>
<body>
    <div id="app"></div>
    <script src="./main.js"></script>
</body>
</html>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">index.js</span><br><span class="line">app을 가져와서 내용 고치기    </span><br><span class="line">모든 가게의 id, 이름, 주소 출력</span><br></pre></td></tr></table></figure>
(async () => {
    const url = 'http://localhost:8080/restaurants';
    const response = await fetch(url);
    const restaurants = await response.json();

<pre><code>const element = document.getElementById(&apos;app&apos;);
element.innerHTML = `
    ${restaurants.map(restaurant =&gt; `
    &lt;p&gt;
        ${restaurant.id}
        ${restaurant.name}
        ${restaurant.address}
    &lt;/p&gt;
    `).join(&apos;&apos;)}
`;</code></pre><p>})();</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">별도의 웹서버에서 CORS에 따라 서로 보안을 위해 접근할 수 없기때문에 </span><br><span class="line">Spring에서 CrossOrigin annotation 처리</span><br></pre></td></tr></table></figure>
<p>@CrossOrigin<br>@RestController<br>public class RestaurantController {</p>
<pre><code>@Autowired
private RestaurantService restaurantService;

@GetMapping(&quot;/restaurants&quot;)
public List&lt;Restaurant&gt; list() {

    List&lt;Restaurant&gt; restaurants = restaurantService.getRestaurants(); //API들의 중복제거를 위해 가게 저장소 사용
    return restaurants;
}</code></pre><pre><code></code></pre>]]></content>
      <categories>
        <category>Study</category>
        <category>Spring Boot Project</category>
      </categories>
      <tags>
        <tag>spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title>18. 가게 수정</title>
    <url>/2020/08/12/hexo_springboot_1_18/</url>
    <content><![CDATA[<h1 id="스프링-부트-프로젝트"><a href="#스프링-부트-프로젝트" class="headerlink" title="스프링 부트 프로젝트"></a>스프링 부트 프로젝트</h1><h3 id="레스토랑-예약-사이트-만들기"><a href="#레스토랑-예약-사이트-만들기" class="headerlink" title="레스토랑 예약 사이트 만들기"></a>레스토랑 예약 사이트 만들기</h3><h4 id="18-가게-수정"><a href="#18-가게-수정" class="headerlink" title="18. 가게 수정"></a>18. 가게 수정</h4><p>PATCH /restaurants/{id}<br>성공 http status 200  </p>
<p>Controller Test에서 새로운 기능 테스트    </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void update() throws Exception &#123;</span><br><span class="line">    mvc.perform(patch(&quot;&#x2F;restaurants&#x2F;1&quot;)</span><br><span class="line">            .contentType(MediaType.APPLICATION_JSON)</span><br><span class="line">            .content(&quot;&#123;\&quot;name\&quot;:\&quot;GukBobZip\&quot;,\&quot;address\&quot;:\&quot;Busan\&quot;&#125;&quot;))</span><br><span class="line">            .andExpect(status().isOk());</span><br><span class="line"></span><br><span class="line">    verify(restaurantService).updateRestaurant(1L, &quot;GukBobZip&quot;, &quot;Busan&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Controller에 실제 기능 추가    </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@PatchMapping(&quot;&#x2F;restaurants&#x2F;&#123;id&#125;&quot;)</span><br><span class="line">public String update(@PathVariable(&quot;id&quot;) Long id,</span><br><span class="line">                     @RequestBody Restaurant resource) &#123;</span><br><span class="line"></span><br><span class="line">    String name &#x3D; resource.getName();</span><br><span class="line">    String address &#x3D; resource.getAddress();</span><br><span class="line"></span><br><span class="line">    restaurantService.updateRestaurant(id, name, address);</span><br><span class="line">    return &quot;&#123;&#125;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Service Test</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void updateRestaurant() &#123;</span><br><span class="line"></span><br><span class="line">    Restaurant restaurant &#x3D; new Restaurant(1L, &quot;BobZip&quot;, &quot;Seoul&quot;);</span><br><span class="line">    given(restaurantRepository.findById(1L)).willReturn(java.util.Optional.of(restaurant));</span><br><span class="line"></span><br><span class="line">    restaurantService.updateRestaurant(1L,&quot;GukBobZip&quot;,&quot;Busan&quot;);</span><br><span class="line"></span><br><span class="line">    assertThat(restaurant.getName(), is(&quot;GukBobZip&quot;));</span><br><span class="line">    assertThat(restaurant.getAddress(), is(&quot;Busan&quot;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Service 추가</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Transactional &#x2F;&#x2F;트랜젝션 범위에서 처리되고 범위에서 처리가 벗어났을때 내용이 적용됨</span><br><span class="line">public Restaurant updateRestaurant(Long id, String name, String address) &#123;</span><br><span class="line">    Restaurant restaurant &#x3D; restaurantRepository.findById(id).orElse(null);</span><br><span class="line"></span><br><span class="line">    restaurant.setInformation(name,address);</span><br><span class="line">    return restaurant;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>테스트</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ http PATCH localhost:8080&#x2F;restaurants&#x2F;1 name&#x3D;BeRyong address&#x3D;Seoul</span><br><span class="line">HTTP&#x2F;1.1 200 </span><br><span class="line">~</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Study</category>
        <category>Spring Boot Project</category>
      </categories>
      <tags>
        <tag>spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title>19. Lombok</title>
    <url>/2020/08/12/hexo_springboot_1_19/</url>
    <content><![CDATA[<h1 id="스프링-부트-프로젝트"><a href="#스프링-부트-프로젝트" class="headerlink" title="스프링 부트 프로젝트"></a>스프링 부트 프로젝트</h1><h3 id="레스토랑-예약-사이트-만들기"><a href="#레스토랑-예약-사이트-만들기" class="headerlink" title="레스토랑 예약 사이트 만들기"></a>레스토랑 예약 사이트 만들기</h3><h4 id="19-Lombok"><a href="#19-Lombok" class="headerlink" title="19. Lombok"></a>19. Lombok</h4><p>Annotation Processor 를 이용해서 코딩 자동화</p>
<p>@Setter<br>@Getter<br>@Builder    </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Entity</span><br><span class="line">@Getter &#x2F;&#x2F;모든 속성들에 대한 getter 가 알아서 만들어 진다</span><br><span class="line">@NoArgsConstructor &#x2F;&#x2F;디폴트 생성자</span><br><span class="line">@AllArgsConstructor &#x2F;&#x2F;모든 속성 조합을 사용하는 생성자들</span><br><span class="line">@Builder &#x2F;&#x2F;Builder 패턴을 사용</span><br><span class="line">public class Restaurant &#123;</span><br><span class="line">    @Id</span><br><span class="line">    @Setter</span><br><span class="line">    @GeneratedValue</span><br><span class="line">    private Long id;</span><br><span class="line">    @Setter &#x2F;&#x2F;name에 대한 setter 가 알아서 만들어 진다</span><br><span class="line">    private String name;</span><br><span class="line">    private String address;</span><br><span class="line"></span><br><span class="line">    @Transient  </span><br><span class="line">    private List&lt;MenuItem&gt; menuItems;</span><br><span class="line"></span><br><span class="line">    public String getInformation() &#123;</span><br><span class="line">        return name+&quot; in &quot;+address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setMenuItems(List&lt;MenuItem&gt; menuItems) &#123;</span><br><span class="line">        this.menuItems &#x3D; new ArrayList&lt;MenuItem&gt;(menuItems);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setInformation(String name, String address) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">        this.address &#x3D; address;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Builder로 인스턴스 생성시</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void creation() &#123;</span><br><span class="line">    Restaurant restaurant &#x3D; Restaurant.builder() &#x2F;&#x2F;@Builder 패턴을 사용, 가독이 좋고 순서가 없다는 장점이 있다.  </span><br><span class="line">            .id(1004L)</span><br><span class="line">            .name(&quot;Bob zip&quot;)</span><br><span class="line">            .address(&quot;Seoul&quot;)</span><br><span class="line">            .build();</span><br><span class="line"></span><br><span class="line">    assertThat(restaurant.getId(), is(1004L));</span><br><span class="line">    assertThat(restaurant.getName(), is(&quot;Bob zip&quot;));</span><br><span class="line">    assertThat(restaurant.getAddress(), is(&quot;Seoul&quot;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Study</category>
        <category>Spring Boot Project</category>
      </categories>
      <tags>
        <tag>spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title>21. Validation, 에러 처리</title>
    <url>/2020/08/12/hexo_springboot_1_21/</url>
    <content><![CDATA[<h1 id="스프링-부트-프로젝트"><a href="#스프링-부트-프로젝트" class="headerlink" title="스프링 부트 프로젝트"></a>스프링 부트 프로젝트</h1><h3 id="레스토랑-예약-사이트-만들기"><a href="#레스토랑-예약-사이트-만들기" class="headerlink" title="레스토랑 예약 사이트 만들기"></a>레스토랑 예약 사이트 만들기</h3><h4 id="21-Validation-에러-처리"><a href="#21-Validation-에러-처리" class="headerlink" title="21. Validation, 에러 처리"></a>21. Validation, 에러 처리</h4><p>Validation : 유효성 검사<br>사용자들이 입력한 데이터가 올바른지 검증하는 작업이다.  </p>
<p>@Valid</p>
<p>@NotNull<br>@NotEmpty<br>@Size(max=10)</p>
<p>올바르지 않을 시 Error(http status 400)를 리턴하도록</p>
<p>Controller의 기능에 @Valid 추가   </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@PostMapping(&quot;&#x2F;restaurants&quot;)</span><br><span class="line">public ResponseEntity&lt;?&gt; create(@Valid @RequestBody Restaurant resource) &#x2F;&#x2F;Valid: 검증할 것이라 정의</span><br><span class="line">        throws URISyntaxException &#123;</span><br><span class="line"></span><br><span class="line">            Restaurant restaurant &#x3D; Restaurant.builder()</span><br><span class="line">            .name(resource.getName())</span><br><span class="line">            .address(resource.getAddress())</span><br><span class="line">            .build();</span><br><span class="line">    restaurantService.addRestaurant(restaurant);</span><br><span class="line"></span><br><span class="line">    URI location &#x3D; new URI(&quot;&#x2F;restaurants&#x2F;&quot;+restaurant.getId());</span><br><span class="line">    return ResponseEntity.created(location).body(&quot;&#123;&#125;&quot;); &#x2F;&#x2F;빈 내용</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@PatchMapping(&quot;&#x2F;restaurants&#x2F;&#123;id&#125;&quot;)</span><br><span class="line">public String update(@PathVariable(&quot;id&quot;) Long id,</span><br><span class="line">                     @Valid @RequestBody Restaurant resource) &#123;</span><br><span class="line"></span><br><span class="line">    restaurantService.updateRestaurant(id, resource.getName(), resource.getAddress());</span><br><span class="line">    return &quot;&#123;&#125;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Model에서 속성 특징 변경</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@NotEmpty &#x2F;&#x2F;비어있으면 안된다고 정의</span><br><span class="line">private String name;</span><br><span class="line">@NotEmpty</span><br><span class="line">private String address;</span><br></pre></td></tr></table></figure>

<p>Controller Test</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void createWithInvalidData() throws Exception &#123;</span><br><span class="line">    mvc.perform(post(&quot;&#x2F;restaurants&quot;)</span><br><span class="line">            .contentType(MediaType.APPLICATION_JSON)</span><br><span class="line">            .content(&quot;&#123;\&quot;name\&quot;:\&quot;\&quot;,\&quot;address\&quot;:\&quot;\&quot;&#125;&quot;))</span><br><span class="line">            .andExpect(status().isBadRequest());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void updateWithInvalidData() throws Exception &#123;</span><br><span class="line">    mvc.perform(patch(&quot;&#x2F;restaurants&#x2F;1&quot;)</span><br><span class="line">            .contentType(MediaType.APPLICATION_JSON)</span><br><span class="line">            .content(&quot;&#123;\&quot;name\&quot;:\&quot;\&quot;,\&quot;address\&quot;:\&quot;\&quot;&#125;&quot;))</span><br><span class="line">            .andExpect(status().isBadRequest());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Not Found에 대한 처리 =&gt; Exception (http status 404)<br>ex) 없는 URL</p>
<p>@ControllerAdvice : 예외를 받아 처리할 클래스  </p>
<p>Demo<br>존재하지 않는 id의 가게를 조회했을 때 http status 404를 response하려면</p>
<p>id:404(없는 id)의 디테일을 Get했을때 not found를 받고싶다.  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void detailWithNotExist() throws Exception &#123;</span><br><span class="line">    given(restaurantService.getRestaurant(404L))</span><br><span class="line">            .willThrow(new RestaurantNotFoundException(404L)); &#x2F;&#x2F;서비스는 사용자 예외를 던질건데  </span><br><span class="line"></span><br><span class="line">    mvc.perform(MockMvcRequestBuilders.get(&quot;&#x2F;restaurants&#x2F;404&quot;))</span><br><span class="line">            .andExpect(status().isNotFound()) &#x2F;&#x2F;status 404인지 확인하고싶다.</span><br><span class="line">            .andExpect(content().string(&quot;&#123;&#125;&quot;)); &#x2F;&#x2F;빈 body도 받는지 확인하고싶다.  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>사용자 예외 클래스 생성 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class RestaurantNotFoundException extends RuntimeException &#123;</span><br><span class="line"></span><br><span class="line">    public RestaurantNotFoundException(long id) &#123;</span><br><span class="line">        super(&quot;Could not find restaurant &quot;+id); &#x2F;&#x2F;RuntimeException의 매개변수 massage(String)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Controller에서 try/catch로 예외처리 해줄수도 있겠지만<br>예외처리를 맡아줄 ControllerAdvice를 생성해준다.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@ControllerAdvice &#x2F;&#x2F;예외를 처리할 클래스  </span><br><span class="line">public class RestaurantErrorAdvice &#123;</span><br><span class="line"></span><br><span class="line">    @ResponseBody</span><br><span class="line">    @ResponseStatus(HttpStatus.NOT_FOUND) &#x2F;&#x2F;response 404 할것임</span><br><span class="line">    @ExceptionHandler(RestaurantNotFoundException.class) &#x2F;&#x2F;어떤 예외에 대한 정의</span><br><span class="line">    public String handleNotFound() &#123;</span><br><span class="line">        return &quot;&#123;&#125;&quot;; &#x2F;&#x2F;예외 처리하고 비어있는 body를 보낼것이다.</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Service에서도 test 진행</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test(expected &#x3D; RestaurantNotFoundException.class) &#x2F;&#x2F;사용자 예외가 발생할까?  </span><br><span class="line">public void getRestaurantWithNotExisted() &#123;</span><br><span class="line"></span><br><span class="line">    Restaurant restaurant &#x3D; restaurantService.getRestaurant(404L);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>orElseThrow()로 예외 처리</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public Restaurant getRestaurant(Long id) &#123;</span><br><span class="line"></span><br><span class="line">    Restaurant restaurant &#x3D;  restaurantRepository.findById(id)</span><br><span class="line">            .orElseThrow(() -&gt; new RestaurantNotFoundException(id)); &#x2F;&#x2F;사용자 예외 처리</span><br><span class="line">    List&lt;MenuItem&gt; menuItems &#x3D; menuItemRepository.findAllByRestaurantId(id);</span><br><span class="line">    restaurant.setMenuItems(menuItems);</span><br><span class="line"></span><br><span class="line">    return restaurant;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Study</category>
        <category>Spring Boot Project</category>
      </categories>
      <tags>
        <tag>spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title>23. 메뉴 관리</title>
    <url>/2020/08/12/hexo_springboot_1_23/</url>
    <content><![CDATA[<h1 id="스프링-부트-프로젝트"><a href="#스프링-부트-프로젝트" class="headerlink" title="스프링 부트 프로젝트"></a>스프링 부트 프로젝트</h1><h3 id="레스토랑-예약-사이트-만들기"><a href="#레스토랑-예약-사이트-만들기" class="headerlink" title="레스토랑 예약 사이트 만들기"></a>레스토랑 예약 사이트 만들기</h3><h4 id="23-메뉴-관리"><a href="#23-메뉴-관리" class="headerlink" title="23. 메뉴 관리"></a>23. 메뉴 관리</h4><p>메뉴 관리 : 추가 수정 삭제 기능 추가</p>
<p>한번에 여러게 업데이트 : Bulk Update<br>Patch “/restaurants/{id}/menuitems”<br>http status : 200</p>
<p>restaurant은 추가할때 save(), 수정할때 @Transactional으로 직접 수정했었는데,<br>메뉴는 Bulk Update를 할거고 save()와 deleteById()를 동시에 사용할 것임.  </p>
<p>MenuItem Controller Test</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void bulkUpdate() throws Exception &#123;</span><br><span class="line">    mvc.perform(patch(&quot;&#x2F;restaurants&#x2F;1&#x2F;menuitems&quot;) &#x2F;&#x2F;1번 가게의 menuitem을 bulk로 수정할껀데</span><br><span class="line">            .contentType(MediaType.APPLICATION_JSON) &#x2F;&#x2F;헤더에 content-Type이 Application&#x2F;json 이고</span><br><span class="line">            .content(&quot;[\n&quot; +</span><br><span class="line">                    &quot;  &#123;\n&quot; +</span><br><span class="line">                    &quot;    \&quot;name\&quot;: \&quot;Kimchi\&quot;\n&quot; +</span><br><span class="line">                    &quot;  &#125;,\n&quot; +</span><br><span class="line">                    &quot;  &#123;\n&quot; +</span><br><span class="line">                    &quot;    \&quot;name\&quot;: \&quot;Gukbob\&quot;\n&quot; +</span><br><span class="line">                    &quot;  &#125;\n&quot; +</span><br><span class="line">                    &quot;]&quot;)) &#x2F;&#x2F;이런 array를 입력할꺼야</span><br><span class="line">            .andExpect(status().isOk()); &#x2F;&#x2F;http status 200이야?</span><br><span class="line">            </span><br><span class="line">    verify(menuItemServices).bulkUpdate(eq(1L), any()); &#x2F;&#x2F;서비스에서 bulkUpdate()가 올바른 id(1L)로 호출되나?</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Controller에 PatchMapping 추가</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@PatchMapping(&quot;&#x2F;restaurants&#x2F;&#123;restaurantId&#125;&#x2F;menuitems&quot;)</span><br><span class="line">public void bulkUpdate(</span><br><span class="line">        @PathVariable(&quot;restaurantId&quot;) Long restaurantId,</span><br><span class="line">        @RequestBody List&lt;MenuItem&gt; menuItems &#x2F;&#x2F;MenuItem List를 사용자로부터 입력받는다. </span><br><span class="line">) &#123;</span><br><span class="line">    menuItemServices.bulkUpdate(restaurantId, menuItems);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>Service 테스트</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Mock</span><br><span class="line">private MenuItemRepository menuItemRepository;</span><br><span class="line"></span><br><span class="line">@Before</span><br><span class="line">public void setUp() &#123;</span><br><span class="line">    MockitoAnnotations.initMocks(this);</span><br><span class="line">    menuItemServices &#x3D; new MenuItemService(menuItemRepository);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void bulkUpdate() &#123;</span><br><span class="line">    </span><br><span class="line">    List&lt;MenuItem&gt; menuItems &#x3D; new ArrayList&lt;MenuItem&gt;();</span><br><span class="line">    </span><br><span class="line">    menuItems.add(MenuItem.builder().name(&quot;Kimchi&quot;).build()); &#x2F;&#x2F;add</span><br><span class="line">    menuItems.add(MenuItem.builder().id(12L).name(&quot;Gukbob&quot;).build()); &#x2F;&#x2F;add</span><br><span class="line">    menuItems.add(MenuItem.builder().id(1004L).destroy(true).build()); &#x2F;&#x2F;delete</span><br><span class="line">    menuItems.add(MenuItem.builder().id(12L).name(&quot;Guk Bob&quot;).build()); &#x2F;&#x2F;update</span><br><span class="line"></span><br><span class="line">    menuItemServices.bulkUpdate(1L,menuItems);</span><br><span class="line"></span><br><span class="line">    verify(menuItemRepository, times(3)).save(any()); &#x2F;&#x2F;save 함수가 3회 호출되나?</span><br><span class="line">    verify(menuItemRepository, times(1)).deleteById(1004L); &#x2F;&#x2F;deleteById 함수가 1회 호출되나?</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Restaurant Model의 menuItem이 안보이게 수정 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Transient</span><br><span class="line">@JsonInclude(JsonInclude.Include.NON_NULL) &#x2F;&#x2F;Null이 아닐때만 json에 넣어줘라</span><br><span class="line">private List&lt;MenuItem&gt; menuItems;</span><br></pre></td></tr></table></figure>

<p>MenuItem Model에 destory라는 속성 추가</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Transient</span><br><span class="line">@JsonInclude(JsonInclude.Include.NON_DEFAULT) &#x2F;&#x2F;json에 포함 X</span><br><span class="line">private boolean destroy;</span><br></pre></td></tr></table></figure>

<p>Service</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class MenuItemService &#123;</span><br><span class="line"></span><br><span class="line">    private MenuItemRepository menuItemRepository;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    public MenuItemService(MenuItemRepository menuItemRepository) &#123;</span><br><span class="line">        this.menuItemRepository&#x3D;menuItemRepository;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public void bulkUpdate(Long restaurantId, List&lt;MenuItem&gt; menuItems) &#123;</span><br><span class="line"></span><br><span class="line">        for(MenuItem menuItem : menuItems) &#123;</span><br><span class="line">            update(restaurantId, menuItem);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void update(Long restaurantId, MenuItem menuItem) &#123;</span><br><span class="line">        if (menuItem.isDestroy()) &#123;</span><br><span class="line">            menuItemRepository.deleteById(menuItem.getId());</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        menuItem.setRestaurantId(restaurantId);</span><br><span class="line">        menuItemRepository.save(menuItem);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Study</category>
        <category>Spring Boot Project</category>
      </categories>
      <tags>
        <tag>spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title>26. 리뷰 작성</title>
    <url>/2020/08/12/hexo_springboot_1_26/</url>
    <content><![CDATA[<h1 id="스프링-부트-프로젝트"><a href="#스프링-부트-프로젝트" class="headerlink" title="스프링 부트 프로젝트"></a>스프링 부트 프로젝트</h1><h3 id="레스토랑-예약-사이트-만들기"><a href="#레스토랑-예약-사이트-만들기" class="headerlink" title="레스토랑 예약 사이트 만들기"></a>레스토랑 예약 사이트 만들기</h3><h4 id="26-리뷰-작성"><a href="#26-리뷰-작성" class="headerlink" title="26. 리뷰 작성"></a>26. 리뷰 작성</h4><p>POST /restaurants/{id}/reviews</p>
<p>Review Controller Test</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RunWith(SpringRunner.class)</span><br><span class="line">@WebMvcTest(ReviewController.class)</span><br><span class="line">public class ReviewControllerTest &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private MockMvc mvc;</span><br><span class="line"></span><br><span class="line">    @MockBean</span><br><span class="line">    private ReviewService reviewService;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void createWithValidAttributes() throws Exception &#123;</span><br><span class="line">        given(reviewService.addReview(any(),eq(1L))).willReturn(</span><br><span class="line">                Review.builder().id(1004L).build()</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        mvc.perform(post(&quot;&#x2F;restaurants&#x2F;1&#x2F;reviews&quot;)</span><br><span class="line">                .contentType(MediaType.APPLICATION_JSON) &#x2F;&#x2F;json 타입이고</span><br><span class="line">                .content(&quot;&#123;\&quot;name\&quot;:\&quot;jilee\&quot;,\&quot;score\&quot;:3,\&quot;description\&quot;:\&quot;Mat-it-da\&quot;&#125;&quot;)) &#x2F;&#x2F;이렇게 넣을거야</span><br><span class="line">                .andExpect(status().isCreated()) &#x2F;&#x2F;잘 만들어지나?(status 201?)</span><br><span class="line">                .andExpect(header().string(&quot;location&quot;, &quot;&#x2F;restaurants&#x2F;1&#x2F;reviews&#x2F;1004&quot;)); &#x2F;&#x2F;header의 location 확인</span><br><span class="line"></span><br><span class="line">        verify(reviewService).addReview(any(),eq(1L)); &#x2F;&#x2F;addReview가 호출되니?</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void createWithInValidAttributes() throws Exception &#123;</span><br><span class="line">        mvc.perform(post(&quot;&#x2F;restaurants&#x2F;1&#x2F;reviews&quot;)</span><br><span class="line">                .contentType(MediaType.APPLICATION_JSON) &#x2F;&#x2F;json 타입이고</span><br><span class="line">                .content(&quot;&#123;&#125;&quot;)) &#x2F;&#x2F;이렇게 넣을거야</span><br><span class="line">                .andExpect(status().isBadRequest()); &#x2F;&#x2F;status 404?</span><br><span class="line"></span><br><span class="line">        verify(reviewService,never()).addReview(any(),eq(1L)); &#x2F;&#x2F;addReview가 호출되지 않니?</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Review Controller</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class ReviewController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private ReviewService reviewService;</span><br><span class="line"></span><br><span class="line">    @PostMapping(&quot;&#x2F;restaurants&#x2F;&#123;restaurantId&#125;&#x2F;reviews&quot;)</span><br><span class="line">    public ResponseEntity&lt;?&gt; create(</span><br><span class="line">            @PathVariable(&quot;restaurantId&quot;) Long restaurantId,</span><br><span class="line">            @Valid @RequestBody Review resource</span><br><span class="line">    ) throws URISyntaxException &#123;</span><br><span class="line"></span><br><span class="line">        Review review &#x3D; reviewService.addReview(resource,restaurantId);</span><br><span class="line"></span><br><span class="line">        String url &#x3D; &quot;&#x2F;restaurants&#x2F;&quot;+restaurantId+&quot;&#x2F;reviews&#x2F;&quot;+review.getId();</span><br><span class="line">        return ResponseEntity.created(new URI(url))</span><br><span class="line">                .body(&quot;&#123;&#125;&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Service Test</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ReviewServiceTest &#123;</span><br><span class="line"></span><br><span class="line">    private ReviewService reviewService;</span><br><span class="line"></span><br><span class="line">    @Mock</span><br><span class="line">    private ReviewRepository reviewRepository;</span><br><span class="line"></span><br><span class="line">    @Before</span><br><span class="line">    public void setUp() &#123;</span><br><span class="line">        MockitoAnnotations.initMocks(this);</span><br><span class="line"></span><br><span class="line">        reviewService &#x3D; new ReviewService(reviewRepository);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void addReview() &#123;</span><br><span class="line">        Review review &#x3D; Review.builder().name(&quot;jilee&quot;).score(3).description(&quot;Mat-it-da&quot;).build(); &#x2F;&#x2F;Review 객체 생성</span><br><span class="line">        reviewService.addReview(review,1004L); &#x2F;&#x2F;기능 실행할때</span><br><span class="line"></span><br><span class="line">        verify(reviewRepository).save(any()); &#x2F;&#x2F;save가 호출되니?</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Service</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class ReviewService &#123;</span><br><span class="line"></span><br><span class="line">    private ReviewRepository reviewRepository;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    public ReviewService(ReviewRepository reviewRepository) &#123;</span><br><span class="line">        this.reviewRepository &#x3D; reviewRepository;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Review addReview(Review review,Long restaurantId) &#123;</span><br><span class="line">        review.setRestaurantId(restaurantId);</span><br><span class="line">        return reviewRepository.save(review);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Review Repository</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface ReviewRepository extends CrudRepository&lt;Review, Long&gt; &#123;</span><br><span class="line"></span><br><span class="line">    Review save(Review review);</span><br><span class="line"></span><br><span class="line">    List&lt;Review&gt; findAllByRestaurantId(Long restaurantId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Study</category>
        <category>Spring Boot Project</category>
      </categories>
      <tags>
        <tag>spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title>29. 프로젝트 분리</title>
    <url>/2020/08/12/hexo_springboot_1_29/</url>
    <content><![CDATA[<h1 id="스프링-부트-프로젝트"><a href="#스프링-부트-프로젝트" class="headerlink" title="스프링 부트 프로젝트"></a>스프링 부트 프로젝트</h1><h3 id="레스토랑-예약-사이트-만들기"><a href="#레스토랑-예약-사이트-만들기" class="headerlink" title="레스토랑 예약 사이트 만들기"></a>레스토랑 예약 사이트 만들기</h3><h4 id="29-프로젝트-분리"><a href="#29-프로젝트-분리" class="headerlink" title="29. 프로젝트 분리"></a>29. 프로젝트 분리</h4><p>./gradlew build<br>./gradlew assamble<br>./gradlew test //전체 테스트 실행<br>./gradlew check  </p>
<p>사용자에 따른 API 분리  </p>
<p>기존 settings.gradle</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rootProject.name &#x3D; &#39;eatgo&#39;</span><br><span class="line"></span><br><span class="line">include &#39;eatgo-api&#39;</span><br></pre></td></tr></table></figure>
<p>변경 후 settings.gradle<br>eatgo-common : 공동으로 사용될 package들 (domain)<br>eatgo-admin-api : 가게 관리자용<br>eatgo-customer-api : 고객용    </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rootProject.name &#x3D; &#39;eatgo&#39;</span><br><span class="line"></span><br><span class="line">include &#39;eatgo-common&#39;</span><br><span class="line">include &#39;eatgo-admin-api&#39;</span><br><span class="line">include &#39;eatgo-customer-api&#39;</span><br></pre></td></tr></table></figure>

<p>eatgo-common의 build.gradle 수정<br>참고 : <a href="https://docs.spring.io/spring-boot/docs/current/gradle-plugin/reference/html/#packaging-executable-and-normal" target="_blank" rel="noopener">https://docs.spring.io/spring-boot/docs/current/gradle-plugin/reference/html/#packaging-executable-and-normal</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jar &#123; </span><br><span class="line">    enabled &#x3D; true &#x2F;&#x2F;default가 false이기때문에, false면 import에서 문제 발생  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bootJar &#123;</span><br><span class="line">    enabled &#x3D; false &#x2F;&#x2F;true면 gradle assamble&#x2F;build 에서 문제발생 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>eatgo-admin-api, eatgo-customer-api의 build.gradle 수정<br>eatgo-common 의존성 추가  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">	implementation project(&#39;:eatgo-common&#39;)</span><br><span class="line"></span><br><span class="line">    ~</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Study</category>
        <category>Spring Boot Project</category>
      </categories>
      <tags>
        <tag>spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title>34. 진짜 영속화</title>
    <url>/2020/08/12/hexo_springboot_1_34/</url>
    <content><![CDATA[<h1 id="스프링-부트-프로젝트"><a href="#스프링-부트-프로젝트" class="headerlink" title="스프링 부트 프로젝트"></a>스프링 부트 프로젝트</h1><h3 id="레스토랑-예약-사이트-만들기"><a href="#레스토랑-예약-사이트-만들기" class="headerlink" title="레스토랑 예약 사이트 만들기"></a>레스토랑 예약 사이트 만들기</h3><h4 id="34-진짜-영속화"><a href="#34-진짜-영속화" class="headerlink" title="34. 진짜 영속화"></a>34. 진짜 영속화</h4><p>database(h2)를 이제부터 file로 생성할 예정이다.<br>file을 사용하게 되면 test에 실행되는 내용도 file에 작성될 수 있기때문에<br>test, 개발, 서비스 등 다른 영역에서 각각 다른 설정으로 처리될 수 있도록 profiles를 사용한다.    </p>
<p>eatgo-admin-api &amp; eatgo-customer-api<br>resource에 application.yml 파일 추가</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">##spring:</span><br><span class="line">##  key: value</span><br><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    url: jdbc:h2:~&#x2F;data&#x2F;eatgo</span><br><span class="line">  jpa:</span><br><span class="line">    hibernate:</span><br><span class="line">      ddl-auto: update</span><br><span class="line">      </span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  profiles: test</span><br><span class="line">  datasource:</span><br><span class="line">    url: jdbc:h2:mem:test</span><br></pre></td></tr></table></figure>

<p>여러개의 설정을 나누려면 ‘—‘<br>SPRING_PROFILES_ACTIVE=test 일때, profiles: test의 설정이 적용된다.<br>ex) SPRING_PROFILES_ACTIVE=test ./gradlew test<br>intellij에서는 Test edit configuration에서 Environment value에 추가해주면 된다.</p>
]]></content>
      <categories>
        <category>Study</category>
        <category>Spring Boot Project</category>
      </categories>
      <tags>
        <tag>spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title>35. 가게 목록 필터링</title>
    <url>/2020/08/12/hexo_springboot_1_35/</url>
    <content><![CDATA[<h1 id="스프링-부트-프로젝트"><a href="#스프링-부트-프로젝트" class="headerlink" title="스프링 부트 프로젝트"></a>스프링 부트 프로젝트</h1><h3 id="레스토랑-예약-사이트-만들기"><a href="#레스토랑-예약-사이트-만들기" class="headerlink" title="레스토랑 예약 사이트 만들기"></a>레스토랑 예약 사이트 만들기</h3><h4 id="35-가게-목록-필터링"><a href="#35-가게-목록-필터링" class="headerlink" title="35. 가게 목록 필터링"></a>35. 가게 목록 필터링</h4><p>필터링 (지역, 분류 (Region, Category))</p>
<p>Region과 Category를 도메인 모델로 관리</p>
<ul>
<li><p>eatgo-admin-api<br>GET /regions<br>POST /regions<br>GET /categories<br>POST /categories  </p>
</li>
<li><p>eatgo-customer-api<br>GET /regions<br>GET /categories  </p>
</li>
</ul>
<p>JPA<br>findAllByAddressContaining<br>findAllByAddressStartingWith  </p>
<p>H2 Console<br><a href="http://localhost:8080/h2-console" target="_blank" rel="noopener">http://localhost:8080/h2-console</a> 에서 h2DB를 관리할 수 있다.  </p>
<p>eatgo-customer-api<br>Restaurant Controller 수정</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@GetMapping(&quot;&#x2F;restaurants&quot;)</span><br><span class="line">public List&lt;Restaurant&gt; list(</span><br><span class="line">        @RequestParam(&quot;region&quot;) String region, &#x2F;&#x2F;region 파라미터 추가</span><br><span class="line">        @RequestParam(&quot;category&quot;) Long categoryId &#x2F;&#x2F;category 파라미터 추가 </span><br><span class="line">) &#123;</span><br><span class="line">    List&lt;Restaurant&gt; restaurants &#x3D; restaurantService.getRestaurants(region,categoryId);</span><br><span class="line">    return restaurants;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Restaurant Service의 getRestaurants 메서드 매개변수 추가 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public List&lt;Restaurant&gt; getRestaurants(String region, long categoryId) &#123;</span><br><span class="line">    List&lt;Restaurant&gt; restaurants &#x3D;</span><br><span class="line">            restaurantRepository.findByAddressContainingAndCategoryId(region,categoryId);</span><br><span class="line">            &#x2F;&#x2F;입력받은 region을 포함하는 address &#x2F; 일치하는 categoryId </span><br><span class="line">    return restaurants;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Restaurant Repository JPA</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List&lt;Restaurant&gt; findByAddressContainingAndCategoryId(</span><br><span class="line">        String region, long categoryId);</span><br></pre></td></tr></table></figure>

<p>TEST</p>
<figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="code"><pre><span class="line">http GET "localhost:8080/restaurants?region=서울&amp;category=1"</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Study</category>
        <category>Spring Boot Project</category>
      </categories>
      <tags>
        <tag>spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title>41. 사용자 관리</title>
    <url>/2020/08/12/hexo_springboot_1_41/</url>
    <content><![CDATA[<h1 id="스프링-부트-프로젝트"><a href="#스프링-부트-프로젝트" class="headerlink" title="스프링 부트 프로젝트"></a>스프링 부트 프로젝트</h1><h3 id="레스토랑-예약-사이트-만들기"><a href="#레스토랑-예약-사이트-만들기" class="headerlink" title="레스토랑 예약 사이트 만들기"></a>레스토랑 예약 사이트 만들기</h3><h4 id="41-사용자-관리"><a href="#41-사용자-관리" class="headerlink" title="41. 사용자 관리"></a>41. 사용자 관리</h4><p>User 도메인 모델을 추가할것이다.<br>User의 속성<br>String name<br>Integer level : 1일반고객,2가게,100관리자,0deactive계정…<br>String email</p>
<p>User model</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Entity</span><br><span class="line">@Builder</span><br><span class="line">@Getter</span><br><span class="line">@AllArgsConstructor</span><br><span class="line">@NoArgsConstructor</span><br><span class="line">public class User &#123;</span><br><span class="line"></span><br><span class="line">    @Id</span><br><span class="line">    @GeneratedValue</span><br><span class="line">    Long id;</span><br><span class="line"></span><br><span class="line">    @NotEmpty</span><br><span class="line">    @Setter</span><br><span class="line">    String email;</span><br><span class="line"></span><br><span class="line">    @NotEmpty</span><br><span class="line">    @Setter</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    @NotNull</span><br><span class="line">    @Setter</span><br><span class="line">    Long level;</span><br><span class="line"></span><br><span class="line">    public boolean isAdmin() &#123;</span><br><span class="line">        return level &gt;&#x3D; 100;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean isActive() &#123;</span><br><span class="line">        return level &gt; 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void deactivate() &#123;</span><br><span class="line">        level &#x3D; 0L;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>Controller에 실제 계정을 제거하는 대신 deactive하는 기능구현  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void delete() throws Exception &#123;</span><br><span class="line">    mvc.perform(MockMvcRequestBuilders.delete(&quot;&#x2F;users&#x2F;1004&quot;))</span><br><span class="line">            .andExpect(status().isOk());</span><br><span class="line"></span><br><span class="line">    Long id &#x3D; 1004L;</span><br><span class="line">    verify(userService).deactiveUser(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Service  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Service</span><br><span class="line">@Transactional &#x2F;&#x2F;DB에 Transaction처리를 위함이다</span><br><span class="line">               &#x2F;&#x2F;안해주면 update&#x2F;delete 안되었음</span><br><span class="line">public class UserService &#123;</span><br><span class="line"></span><br><span class="line">~</span><br><span class="line"></span><br><span class="line">    public User updateUser(Long id, String email, String name, Long level) &#123;</span><br><span class="line">        &#x2F;&#x2F;TODO 예외처리 추가 필요</span><br><span class="line">        User user &#x3D; userRepository.findById(id).orElse(null);</span><br><span class="line">        user.setEmail(email);</span><br><span class="line">        user.setName(name);</span><br><span class="line">        user.setLevel(level);</span><br><span class="line">        return user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public User deactiveUser(Long id) &#123;</span><br><span class="line">        User user &#x3D; userRepository.findById(id).orElse(null);</span><br><span class="line">        user.deactivate();</span><br><span class="line">        return user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>패스워드, 회원가입등은 추후 추가 예정   </p>
]]></content>
      <categories>
        <category>Study</category>
        <category>Spring Boot Project</category>
      </categories>
      <tags>
        <tag>spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title>45. 회원가입</title>
    <url>/2020/08/12/hexo_springboot_1_45/</url>
    <content><![CDATA[<h1 id="스프링-부트-프로젝트"><a href="#스프링-부트-프로젝트" class="headerlink" title="스프링 부트 프로젝트"></a>스프링 부트 프로젝트</h1><h3 id="레스토랑-예약-사이트-만들기"><a href="#레스토랑-예약-사이트-만들기" class="headerlink" title="레스토랑 예약 사이트 만들기"></a>레스토랑 예약 사이트 만들기</h3><h4 id="45-회원가입"><a href="#45-회원가입" class="headerlink" title="45. 회원가입"></a>45. 회원가입</h4><p>BCrypt를 이용한 Hash 암호화를 사용하기 위해<br>제공되는 Spring Security 프로젝트 사용<br>HttpSecurity 부분을 직접 설정할 예정이다  </p>
<p>회원가입 변수<br>Email<br>Name<br>Password (2회 인증은 보통 front에서)  </p>
<ul>
<li>eatgo-customer-api<br>Gradle - Spring security 의존성 추가<br>build.gradle<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation project(&#39;:eatgo-common&#39;)</span><br><span class="line"></span><br><span class="line">    implementation &#39;org.springframework.boot:spring-boot-starter-web&#39;</span><br><span class="line">    implementation &#39;org.springframework.boot:spring-boot-starter-security&#39;</span><br><span class="line">    implementation &#39;org.springframework.boot:spring-boot-starter-data-jpa&#39;</span><br><span class="line">    implementation &#39;com.h2database:h2&#39;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>Spring security를 의존성으로 추가하면 기본적으로 <a href="http://localhost:8080/login" target="_blank" rel="noopener">http://localhost:8080/login</a> 페이지가 제공된다. </p>
<p>그러나 따로 API 서버를 사용하기 때문에 위와같은 페이지가 불필요하다.  </p>
<p>WebSecurityConfig Class를 상속받는 Config Class를 SpringBootApplication Class와 같은 위치에 생성하고<br>configure 메서드를 Overriding하여 설정 변경    </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableWebSecurity</span><br><span class="line">public class SecurityJavaConfig extends WebSecurityConfigurerAdapter &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void configure(HttpSecurity http) throws Exception &#123;</span><br><span class="line">        http</span><br><span class="line">                .formLogin().disable() &#x2F;&#x2F;login page 사용안함  </span><br><span class="line">                &#x2F;&#x2F;Connection 관련된 부분인데 </span><br><span class="line">                &#x2F;&#x2F;disable하지 않으면 h2-console을 사용할 수 없어서 일단 설정</span><br><span class="line">                .cors().disable() </span><br><span class="line">                .csrf().disable()</span><br><span class="line">                .headers().frameOptions().disable();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Service에서 회원가입하는 기능인 registerUser()를 생성하는데<br>중복 이메일에 대한 예외클래스를 생성하고 사용하며<br>BCryptPasswordEncoder 클래스를 통해 password를 암호화한다.  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public User registerUser(String email, String name, String password) &#123;</span><br><span class="line">    Optional&lt;User&gt; existed &#x3D; userRepository.findByEmail(email);</span><br><span class="line">    if (existed.isPresent()) &#123; &#x2F;&#x2F;email로 찾은 User가 존재한다면 if문 수행</span><br><span class="line">        throw new EmailExistedException(email);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PasswordEncoder passwordEncoder &#x3D; new BCryptPasswordEncoder();</span><br><span class="line">    String encodedPassword &#x3D; passwordEncoder.encode(password); &#x2F;&#x2F;암호화 </span><br><span class="line">    User user &#x3D; User.builder()</span><br><span class="line">            .email(email)</span><br><span class="line">            .name(name)</span><br><span class="line">            .level(1L)</span><br><span class="line">            .password(encodedPassword)</span><br><span class="line">            .build();</span><br><span class="line"></span><br><span class="line">    return userRepository.save(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Service Test</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;회원가입 테스트 </span><br><span class="line">@Test</span><br><span class="line">public void registerUser() &#123;</span><br><span class="line">    String email &#x3D; &quot;rockintuna@naver.com&quot;;</span><br><span class="line">    String name &#x3D; &quot;이정인&quot;;</span><br><span class="line">    String password &#x3D; &quot;test&quot;;</span><br><span class="line">    User mockUser &#x3D; User.builder().name(name).email(email).password(password).build();</span><br><span class="line">    given(userRepository.save(any())).willReturn(mockUser);</span><br><span class="line"></span><br><span class="line">    User user &#x3D; userService.registerUser(email, name, password);</span><br><span class="line"></span><br><span class="line">    assertThat(user.getName(), is(&quot;이정인&quot;));</span><br><span class="line"></span><br><span class="line">    verify(userRepository).save(any());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;email 중복 테스트 </span><br><span class="line">@Test(expected &#x3D; EmailExistedException.class)</span><br><span class="line">public void registerUserWithExistEmail() &#123;</span><br><span class="line">    String email &#x3D; &quot;rockintuna@naver.com&quot;;</span><br><span class="line">    String name &#x3D; &quot;이정인&quot;;</span><br><span class="line">    String password &#x3D; &quot;test&quot;;</span><br><span class="line">    User mockUser &#x3D; User.builder().name(name).email(email).password(password).build();</span><br><span class="line"></span><br><span class="line">    given(userRepository.findByEmail(email)).willReturn(Optional.of(mockUser));</span><br><span class="line"></span><br><span class="line">    userService.registerUser(email, name, password);</span><br><span class="line"></span><br><span class="line">    verify(userRepository,never()).save(any());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>사용자 예외 클래스  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class EmailExistedException extends RuntimeException&#123;</span><br><span class="line"></span><br><span class="line">    EmailExistedException(String email) &#123;</span><br><span class="line">        super(&quot;Email is already registered: &quot;+email);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>계정 생성</p>
<figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> http POST localhost:8080/users email=<span class="built_in">test</span>@example.com name=Tester password=<span class="built_in">test</span></span></span><br></pre></td></tr></table></figure>

<p>DB에는 암호화된 암호가 저장된다.<br><img src="encode.png" alt="password encoding"></p>
<p>한번더 같은 메일로 생성하면 생성한 예외 발생</p>
<figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> http POST localhost:8080/users email=<span class="built_in">test</span>@example.com name=Tester password=<span class="built_in">test</span></span></span><br><span class="line">HTTP/1.1 500 </span><br><span class="line">Cache-Control: no-cache, no-store, max-age=0, must-revalidate</span><br><span class="line">Connection: close</span><br><span class="line">Content-Type: application/json;charset=UTF-8</span><br><span class="line">Date: Fri, 19 Jun 2020 09:39:13 GMT</span><br><span class="line">Expires: 0</span><br><span class="line">Pragma: no-cache</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">X-Content-Type-Options: nosniff</span><br><span class="line">X-XSS-Protection: 1; mode=block</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    "error": "Internal Server Error",</span><br><span class="line">    "message": "Email is already registered: test@example.com",</span><br><span class="line">    "path": "/users",</span><br><span class="line">    "status": 500,</span><br><span class="line">    "timestamp": "2020-06-19T09:39:13.802+0000",</span><br><span class="line">    "trace": </span><br><span class="line">~~~</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Study</category>
        <category>Spring Boot Project</category>
      </categories>
      <tags>
        <tag>spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title>48. 인증</title>
    <url>/2020/08/12/hexo_springboot_1_48/</url>
    <content><![CDATA[<h1 id="스프링-부트-프로젝트"><a href="#스프링-부트-프로젝트" class="headerlink" title="스프링 부트 프로젝트"></a>스프링 부트 프로젝트</h1><h3 id="레스토랑-예약-사이트-만들기"><a href="#레스토랑-예약-사이트-만들기" class="headerlink" title="레스토랑 예약 사이트 만들기"></a>레스토랑 예약 사이트 만들기</h3><h4 id="48-인증"><a href="#48-인증" class="headerlink" title="48. 인증"></a>48. 인증</h4><p>POST /session<br>session이라는 resource를 구현할것이다<br>session이 올바르게 만들어졌다는 정보를 유지하기위해 accessToken을 사용한다<br>DTO(Data Transfer Object)를 통해 데이터 교환<br>SessionResponseDto session 결과(accessToken 등) 교환<br>SessionRequestDto session을 만들기위한 request 데이터 교환</p>
<p>SessionResponseDto</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;SessionDTO는 accessToken등 그 외 데이터를 처리하는 Class</span><br><span class="line">@Data &#x2F;&#x2F;DTO는 순수한 data객체이기 때문에 @Data 사용하면 유용하다</span><br><span class="line">@Builder</span><br><span class="line">public class SessionResponseDto &#123;</span><br><span class="line"></span><br><span class="line">    private String accessToken;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SessionRequestDto</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Data</span><br><span class="line">public class SessionRequestDto &#123;</span><br><span class="line"></span><br><span class="line">    private String email;</span><br><span class="line">    private String password;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Session Controller</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class SessionController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private UserService userService;</span><br><span class="line"></span><br><span class="line">    @PostMapping(&quot;&#x2F;session&quot;)</span><br><span class="line">    public ResponseEntity&lt;SessionResponseDto&gt; create(</span><br><span class="line">            @RequestBody SessionRequestDto resource  &#x2F;&#x2F;리소스 확인용 requestDTO </span><br><span class="line">    ) throws URISyntaxException &#123;</span><br><span class="line">        String email &#x3D; resource.getEmail();</span><br><span class="line">        String password &#x3D; resource.getPassword();</span><br><span class="line">        User user &#x3D; userService.authenticate(email,password);</span><br><span class="line"></span><br><span class="line">        String accessToken &#x3D; user.getAccessToken();</span><br><span class="line"></span><br><span class="line">        String url &#x3D; &quot;&#x2F;session&quot;;</span><br><span class="line">        return ResponseEntity.created(new URI(url)).body(</span><br><span class="line">                SessionResponseDto.builder()  &#x2F;&#x2F;responseDTO 객체를 전달  </span><br><span class="line">                        .accessToken(accessToken)</span><br><span class="line">                        .build());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>User 도메인 모델에 토큰 확인 기능 추가</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;@JsonIgnore : requestedbody에 password가 없는경우 그냥 무시할수도 있음</span><br><span class="line">public String getAccessToken() &#123;</span><br><span class="line">    if (password &#x3D;&#x3D; null) &#123;</span><br><span class="line">        return &quot;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    return password.substring(0, 10);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JPA - User Repository findByEmail(email) 추가    </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Optional&lt;User&gt; findByEmail(String email);</span><br></pre></td></tr></table></figure>

<p>Service에 인가 기능 추가   </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public User authenticate(String email, String password) &#123;</span><br><span class="line">    &#x2F;&#x2F;email확인 후 없는 경우(아마도 비어있는 Optinal) 예외 처리</span><br><span class="line">    User user &#x3D; userRepository.findByEmail(email)</span><br><span class="line">            .orElseThrow(() -&gt; new EmailNotExistedException(email)); </span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;저장되어있는 암호화된 password와 비교하여 일치하지 않는 경우 예외처리</span><br><span class="line">    if (!passwordEncoder.matches(password, user.getPassword())) &#123;</span><br><span class="line">        throw new PasswordWrongException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SpringSecurityConfig에<br>encode(), matches() 사용을 위한 PasswordEncoder 종속 추가</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public PasswordEncoder passwordEncoder() &#123;</span><br><span class="line">    return new BCryptPasswordEncoder();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Session 예외처리를 위한 Advice 추가</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@ControllerAdvice</span><br><span class="line">public class SessionErrorAdvice &#123;</span><br><span class="line"></span><br><span class="line">    @ResponseBody</span><br><span class="line">    @ResponseStatus(HttpStatus.BAD_REQUEST)</span><br><span class="line">    @ExceptionHandler(PasswordWrongException.class)</span><br><span class="line">    public String handlePasswordWrong() &#123;</span><br><span class="line">        return &quot;&#123;&#125;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @ResponseBody</span><br><span class="line">    @ResponseStatus(HttpStatus.BAD_REQUEST)</span><br><span class="line">    @ExceptionHandler(EmailNotExistedException.class)</span><br><span class="line">    public String handleEmailNotExisted() &#123;</span><br><span class="line">        return &quot;&#123;&#125;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>사용자 예외 2가지 추가  </p>
<p>패스워드 불일치 예외</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package kr.co.fastcampus.eatgo.application;</span><br><span class="line"></span><br><span class="line">public class PasswordWrongException extends RuntimeException&#123;</span><br><span class="line"></span><br><span class="line">    PasswordWrongException() &#123;</span><br><span class="line">        super(&quot;Password is wrong.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>존재하지 않는 메일 주소 예외</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package kr.co.fastcampus.eatgo.application;</span><br><span class="line"></span><br><span class="line">public class EmailNotExistedException extends RuntimeException&#123;</span><br><span class="line"></span><br><span class="line">    EmailNotExistedException(String email) &#123;</span><br><span class="line">        super(&quot;Email is not registered : &quot;+email);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Study</category>
        <category>Spring Boot Project</category>
      </categories>
      <tags>
        <tag>spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title>52. JWT</title>
    <url>/2020/08/12/hexo_springboot_1_52/</url>
    <content><![CDATA[<h1 id="스프링-부트-프로젝트"><a href="#스프링-부트-프로젝트" class="headerlink" title="스프링 부트 프로젝트"></a>스프링 부트 프로젝트</h1><h3 id="레스토랑-예약-사이트-만들기"><a href="#레스토랑-예약-사이트-만들기" class="headerlink" title="레스토랑 예약 사이트 만들기"></a>레스토랑 예약 사이트 만들기</h3><h4 id="52-JWT"><a href="#52-JWT" class="headerlink" title="52. JWT"></a>52. JWT</h4><p>JWT (Json Web Tokens)<br>Json 포맷을 이용해 웹에서 활용할 수 있는 Access Token을 다루는 표준  </p>
<p>3 Parts<br>Header - Type, 알고리즘<br>Payload - 실제 데이터(Claims)<br>Signature - 위변조 서명  </p>
<p>Base64 URL Encoding을 통해 Json 포맷을 문자열로 변경한다.<br>문자열로 변경되면 Header.Payload.Signature 형식으로 된다.<br>위변조 되지 않았음을 증명하기 위해 HS256 알고리즘을 이용할 것이다.  </p>
<p>eatgo-common-api, build.gradle<br>Java JWT library 추가  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation &#39;org.springframework.boot:spring-boot-starter-web&#39;</span><br><span class="line">    implementation &#39;org.springframework.boot:spring-boot-starter-data-jpa&#39;</span><br><span class="line">    implementation &#39;com.h2database:h2&#39;</span><br><span class="line">    implementation &#39;io.jsonwebtoken:jjwt-api:0.10.7&#39;</span><br></pre></td></tr></table></figure>


<p>JwtUtil 클래스 추가</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class JwtUtil &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private Key key;</span><br><span class="line"></span><br><span class="line">    public JwtUtil(String secret) &#123;</span><br><span class="line">        this.key &#x3D; Keys.hmacShaKeyFor(secret.getBytes()); &#x2F;&#x2F;secret HS key 생성  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String createToken(long userId, String name) &#123;</span><br><span class="line">        String token &#x3D; Jwts.builder()  </span><br><span class="line">                .claim(&quot;userId&quot;,userId)  </span><br><span class="line">                .claim(&quot;name&quot;,name)  </span><br><span class="line">                .signWith(key, SignatureAlgorithm.HS256)  &#x2F;&#x2F;HS256 알고리즘 사용  </span><br><span class="line">                .compact();</span><br><span class="line"></span><br><span class="line">        return token;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SecurityJavaConfig 클래스에서<br>secret 참조<br>JwtUtil Bean 설정  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Value(&quot;$&#123;jwt.secret&#125;&quot;)</span><br><span class="line">private String secret;</span><br><span class="line"></span><br><span class="line">@Bean</span><br><span class="line">public JwtUtil jwtUtil() &#123;</span><br><span class="line">    return new JwtUtil(secret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SessionController accessToken 변경  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@PostMapping(&quot;&#x2F;session&quot;)</span><br><span class="line">public ResponseEntity&lt;SessionResponseDto&gt; create(</span><br><span class="line">        @RequestBody SessionRequestDto resource</span><br><span class="line">) throws URISyntaxException &#123;</span><br><span class="line">    String email &#x3D; resource.getEmail();</span><br><span class="line">    String password &#x3D; resource.getPassword();</span><br><span class="line">    User user &#x3D; userService.authenticate(email,password);</span><br><span class="line"></span><br><span class="line">    String accessToken &#x3D; jwtUtil.createToken(user.getId(), user.getName());</span><br><span class="line"></span><br><span class="line">    String url &#x3D; &quot;&#x2F;session&quot;;</span><br><span class="line">    return ResponseEntity.created(new URI(url)).body(</span><br><span class="line">            SessionResponseDto.builder()</span><br><span class="line">                    .accessToken(accessToken)</span><br><span class="line">                    .build());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>application.yml 파일에<br>Signature를 위한 코드 저장  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jwt:</span><br><span class="line">  secret: 4abcdef2148724243984789347298634934</span><br></pre></td></tr></table></figure>

<p>test<br>accessToken : Header.Payload.Signature</p>
<figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="code"><pre><span class="line">http POST localhost:8080/session email=test.example.com password=test</span><br><span class="line">HTTP/1.1 201 </span><br><span class="line">Cache-Control: no-cache, no-store, max-age=0, must-revalidate</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Content-Type: application/json;charset=UTF-8</span><br><span class="line">Date: Mon, 29 Jun 2020 14:37:00 GMT</span><br><span class="line">Expires: 0</span><br><span class="line">Keep-Alive: timeout=60</span><br><span class="line">Location: /session</span><br><span class="line">Pragma: no-cache</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">X-Content-Type-Options: nosniff</span><br><span class="line">X-XSS-Protection: 1; mode=block</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    "accessToken": "eyJhbGciOiJIUzI1NiJ9.eyJ1c2VySWQiOjIxLCJuYW1lIjoidGVzdGVyIn0.GXdLiebW_gngO3Tpi8r-MbgCQzCJgxFZg1Kf5ojG0PI"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Study</category>
        <category>Spring Boot Project</category>
      </categories>
      <tags>
        <tag>spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title>54. 인가(Authorization)</title>
    <url>/2020/08/12/hexo_springboot_1_54/</url>
    <content><![CDATA[<h1 id="스프링-부트-프로젝트"><a href="#스프링-부트-프로젝트" class="headerlink" title="스프링 부트 프로젝트"></a>스프링 부트 프로젝트</h1><h3 id="레스토랑-예약-사이트-만들기"><a href="#레스토랑-예약-사이트-만들기" class="headerlink" title="레스토랑 예약 사이트 만들기"></a>레스토랑 예약 사이트 만들기</h3><h4 id="54-인가-Authorization"><a href="#54-인가-Authorization" class="headerlink" title="54. 인가(Authorization)"></a>54. 인가(Authorization)</h4><p>인증은 사용자를 증명하는 단계였다면,<br>인가는 발급된 access Token을 어떻게 다루고<br>어떤 서비스를 사용할 수 있는지 다루는 부분이다.  </p>
<p>Http의 Header를 통해서 Access Token을 전달한다.<br>Header의 key와 value는 아래와 같은 쌍으로 전달할것이다.<br>Authorization : Bearer  </p>
<p>StateLess<br>따로 세션에 대한 정보를 저장하지 않고 받은 Token을 Filter가 계속해서 작업하도록 할 것이다.  </p>
<p>BasicAuthenticationFilter<br>Filter 추가로 모든 요청에 대해 JWT Token이 실제로 세팅되었는지 확인하고<br>Access Token에서 정보를 얻어서 사용자 정보를 활용한다.</p>
<p>UsernamePasswordAuthenticationToken<br>AuthenticationToken 객체를 활용하여 어떤사용자가 사용중인지 확인<br>JWT를 분석하여 내부적으로 사용할 AuthenticationToken을 만들것이다.  </p>
<p>eatgo-customer-api</p>
<p>JwtAuthenticationFilter 클래스 작성<br>(BasicAuthenticationFilter 클래스를 참조하고<br>doFilterInternal 메서드를 오버라이딩)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class JwtAuthenticationFilter extends BasicAuthenticationFilter &#123;</span><br><span class="line"></span><br><span class="line">    private JwtUtil jwtUtil;</span><br><span class="line"></span><br><span class="line">    public JwtAuthenticationFilter(</span><br><span class="line">            AuthenticationManager authenticationManager, JwtUtil jwtUtil) &#123;</span><br><span class="line">        super(authenticationManager);</span><br><span class="line">        this.jwtUtil &#x3D; jwtUtil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">    protected void doFilterInternal(HttpServletRequest request,</span><br><span class="line">                                    HttpServletResponse response,</span><br><span class="line">                                    FilterChain chain</span><br><span class="line">    ) throws IOException, ServletException &#123;</span><br><span class="line">        Authentication authentication &#x3D; getAuthentication(request);</span><br><span class="line"></span><br><span class="line">        if (authentication !&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F;SecurityContext 객체를 통해 인증정보 관리</span><br><span class="line">            SecurityContext context &#x3D; SecurityContextHolder.getContext();</span><br><span class="line">            context.setAuthentication(authentication);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        chain.doFilter(request,response); &#x2F;&#x2F;다음 작업으로 연결됨</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;request Header의 Authrization부분(token)으로부터 Claims 객체 생성</span><br><span class="line">    &#x2F;&#x2F;Claims으로 authentication 객체 생성 및 반환</span><br><span class="line">    private Authentication getAuthentication(HttpServletRequest request) &#123;</span><br><span class="line">        String token &#x3D; request.getHeader(&quot;Authorization&quot;);</span><br><span class="line">        if (token&#x3D;&#x3D;null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Claims claims &#x3D; jwtUtil.getClaims(token.substring(&quot;Bearer &quot;.length()));</span><br><span class="line"></span><br><span class="line">        Authentication authentication &#x3D; new UsernamePasswordAuthenticationToken(</span><br><span class="line">                claims, null); &#x2F;&#x2F;간단하게 principal로 claims 만 사용</span><br><span class="line">        return authentication;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SecurityJavaConfig 클래스 변경   </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void configure(HttpSecurity http) throws Exception &#123;</span><br><span class="line">    &#x2F;&#x2F;Filter 객체 생성</span><br><span class="line">    Filter filter &#x3D; new JwtAuthenticationFilter(</span><br><span class="line">            authenticationManager(), jwtUtil());</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    http</span><br><span class="line">            .formLogin().disable()</span><br><span class="line">            .cors().disable()</span><br><span class="line">            .csrf().disable()</span><br><span class="line">            .headers().frameOptions().disable()</span><br><span class="line">    &#x2F;&#x2F;filter 추가, session stateless 처리</span><br><span class="line">            .and()</span><br><span class="line">            .addFilter(filter)</span><br><span class="line">            .sessionManagement()</span><br><span class="line">            .sessionCreationPolicy(SessionCreationPolicy.STATELESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JwtUtil 클래스에 claim을 얻는 메서드 추가  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public Claims getClaims(String token) &#123;</span><br><span class="line"></span><br><span class="line">    Claims claims &#x3D; Jwts.parser()</span><br><span class="line">            .setSigningKey(key) &#x2F;&#x2F;key는 기존 HSkey를 활용</span><br><span class="line">            .parseClaimsJws(token) &#x2F;&#x2F;Jws : sign이 포함된 Jwt</span><br><span class="line">            .getBody();</span><br><span class="line"></span><br><span class="line">    return claims;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ReviewController의 POST 메서드<br>name을 Claim으로부터 가져오도록 변경  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@PostMapping(&quot;&#x2F;restaurants&#x2F;&#123;restaurantId&#125;&#x2F;reviews&quot;)</span><br><span class="line">public ResponseEntity&lt;?&gt; create(</span><br><span class="line">        Authentication authentication,</span><br><span class="line">        @PathVariable(&quot;restaurantId&quot;) Long restaurantId,</span><br><span class="line">        @Valid @RequestBody Review resource</span><br><span class="line">) throws URISyntaxException &#123;</span><br><span class="line">    Claims claims &#x3D; (Claims) authentication.getPrincipal();</span><br><span class="line"></span><br><span class="line">    Review review &#x3D; reviewService.addReview(</span><br><span class="line">            restaurantId,</span><br><span class="line">            claims.get(&quot;name&quot;, String.class),</span><br><span class="line">            resource.getScore(),</span><br><span class="line">            resource.getDescription());</span><br><span class="line"></span><br><span class="line">    String url &#x3D; &quot;&#x2F;restaurants&#x2F;&quot;+restaurantId+&quot;&#x2F;reviews&#x2F;&quot;+review.getId();</span><br><span class="line">    return ResponseEntity.created(new URI(url))</span><br><span class="line">            .body(&quot;&#123;&#125;&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>test(http)<br>header의 “Authorization”을 참조하여 인증 및 name 활용</p>
<figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> http POST localhost:8080/restaurants/1/reviews score=3 description=<span class="string">"종습니다."</span> <span class="string">"Authorization:Bearer eyJhbGciOiJIUzI1NiJ9.eyJ1c2VySWQiOjEwMDQsIm5hbWUiOiLsnbTsoJXsnbgifQ.wKrAIT-cOCfQwBO_8UkhK_IOy4tl8uuIeBS4nppu_Vw"</span></span></span><br><span class="line">HTTP/1.1 201 </span><br><span class="line">Cache-Control: no-cache, no-store, max-age=0, must-revalidate</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Content-Length: 2</span><br><span class="line">Content-Type: application/json;charset=UTF-8</span><br><span class="line">Date: Fri, 03 Jul 2020 11:16:35 GMT</span><br><span class="line">Expires: 0</span><br><span class="line">Keep-Alive: timeout=60</span><br><span class="line">Location: /restaurants/1/reviews/22</span><br><span class="line">Pragma: no-cache</span><br><span class="line">X-Content-Type-Options: nosniff</span><br><span class="line">X-XSS-Protection: 1; mode=block</span><br><span class="line"></span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> http GET localhost:8080/restaurants/1                                                                                     HTTP/1.1 200                                                                               </span></span><br><span class="line">Cache-Control: no-cache, no-store, max-age=0, must-revalidate</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Content-Type: application/json;charset=UTF-8</span><br><span class="line">Date: Fri, 03 Jul 2020 11:16:37 GMT</span><br><span class="line">Expires: 0</span><br><span class="line">Keep-Alive: timeout=60</span><br><span class="line">Pragma: no-cache</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">X-Content-Type-Options: nosniff</span><br><span class="line">X-XSS-Protection: 1; mode=block</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    "address": "서울 마포구",</span><br><span class="line">    "categoryId": 1,</span><br><span class="line">    "id": 1,</span><br><span class="line">    "information": "밥집 in 서울 마포구",</span><br><span class="line">    "menuItems": [</span><br><span class="line">        &#123;</span><br><span class="line">            "id": 2,</span><br><span class="line">            "name": "Kimchi",</span><br><span class="line">            "restaurantId": 1</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            "id": 3,</span><br><span class="line">            "name": "Gukbob",</span><br><span class="line">            "restaurantId": 1</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            "id": 6,</span><br><span class="line">            "name": "Kimchi",</span><br><span class="line">            "restaurantId": 1</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            "id": 7,</span><br><span class="line">            "name": "Rice",</span><br><span class="line">            "restaurantId": 1</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    "name": "밥집",</span><br><span class="line">    "reviews": [</span><br><span class="line">        &#123;</span><br><span class="line">            "description": "Cool",</span><br><span class="line">            "id": 10,</span><br><span class="line">            "name": "jilee",</span><br><span class="line">            "restaurantId": 1,</span><br><span class="line">            "score": 4</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            "description": "종습니다.",</span><br><span class="line">            "id": 22,</span><br><span class="line">            "name": "이정인",</span><br><span class="line">            "restaurantId": 1,</span><br><span class="line">            "score": 3</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Study</category>
        <category>Spring Boot Project</category>
      </categories>
      <tags>
        <tag>spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title>56. 로그인 API 분리</title>
    <url>/2020/08/12/hexo_springboot_1_56/</url>
    <content><![CDATA[<h1 id="스프링-부트-프로젝트"><a href="#스프링-부트-프로젝트" class="headerlink" title="스프링 부트 프로젝트"></a>스프링 부트 프로젝트</h1><h3 id="레스토랑-예약-사이트-만들기"><a href="#레스토랑-예약-사이트-만들기" class="headerlink" title="레스토랑 예약 사이트 만들기"></a>레스토랑 예약 사이트 만들기</h3><h4 id="56-로그인-API-분리"><a href="#56-로그인-API-분리" class="headerlink" title="56. 로그인 API 분리"></a>56. 로그인 API 분리</h4><p>eatgo-login-api를 새로 만들어 로그인 처리를 할것이다.<br>이게 가능한 이유는 Stateless이기 때문인데<br>사용자의 로그인 등 활동에 대해서는 관리하지 않지만 JWT의 accessToken을 활용할 수 있다.  </p>
<p>eatgo-login-api<br>UserService에서 인증 부분만 login API로 옮겼다.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Service</span><br><span class="line">@Transactional</span><br><span class="line">public class UserService &#123;</span><br><span class="line"></span><br><span class="line">    private UserRepository userRepository;</span><br><span class="line">    private PasswordEncoder passwordEncoder;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    public UserService(UserRepository userRepository, PasswordEncoder passwordEncoder) &#123;</span><br><span class="line">        this.userRepository &#x3D; userRepository;</span><br><span class="line">        this.passwordEncoder &#x3D; passwordEncoder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public User authenticate(String email, String password) &#123;</span><br><span class="line">        User user &#x3D; userRepository.findByEmail(email)</span><br><span class="line">                .orElseThrow(() -&gt; new EmailNotExistedException(email));</span><br><span class="line"></span><br><span class="line">        if (!passwordEncoder.matches(password, user.getPassword())) &#123;</span><br><span class="line">            throw new PasswordWrongException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Session과 관련된 부분을 모두 login API로 Move하였다.<br>SessionController, SessionRequestDto, SessionResponseDto, SessionErrorAdvice  </p>
<p>일반 고객과 가게 주인의 계정 정보를 구분하기 위하여<br>User 객체의 restaurantId 속성을 만들어서 null이 아니면 가게 주인으로 인식되도록 하였고<br>setrestaurantId()를 실행하면 level이 자동으로 바뀌도록 하였다.</p>
<p>User Class</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private Long restaurantId;</span><br><span class="line"></span><br><span class="line">public void setRestaurantId(Long restaurantId) &#123;</span><br><span class="line">    this.level &#x3D; 50L;</span><br><span class="line">    this.restaurantId &#x3D; restaurantId;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public boolean isRestaurantOwner() &#123;</span><br><span class="line">    return level &#x3D;&#x3D; 50;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>로그인 할때 JWT token을 생성하는 부분에서<br>가게 주인일 경우에만 Claims에 restaurantId까지 추가하기 위해<br>JwtUtil, SessionController 수정  </p>
<p>JwtUtil.creation() 메서드 수정</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public String createToken(long userId, String name, Long restaurantId) &#123;</span><br><span class="line">    JwtBuilder builder &#x3D; Jwts.builder()</span><br><span class="line">            .claim(&quot;userId&quot;, userId)</span><br><span class="line">            .claim(&quot;name&quot;, name);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;restaurantId가 null이 아닌경우만 restaurantId를 claims에 추가</span><br><span class="line">    if (restaurantId !&#x3D; null) &#123;</span><br><span class="line">        builder.claim(&quot;restaurantId&quot;,restaurantId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String token &#x3D; builder</span><br><span class="line">            .signWith(key, SignatureAlgorithm.HS256)</span><br><span class="line">            .compact();</span><br><span class="line"></span><br><span class="line">    return token ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SessionController POST 메서드 수정</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@PostMapping(&quot;&#x2F;session&quot;)</span><br><span class="line">public ResponseEntity&lt;SessionResponseDto&gt; create(</span><br><span class="line">        @RequestBody SessionRequestDto resource</span><br><span class="line">) throws URISyntaxException &#123;</span><br><span class="line">    String email &#x3D; resource.getEmail();</span><br><span class="line">    String password &#x3D; resource.getPassword();</span><br><span class="line"></span><br><span class="line">    User user &#x3D; userService.authenticate(email,password);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;가게 주인인경우만 restaurantId를 보내고 아니면 null</span><br><span class="line">    String accessToken &#x3D; jwtUtil.createToken(</span><br><span class="line">            user.getId(),</span><br><span class="line">            user.getName(),</span><br><span class="line">            user.isRestaurantOwner() ? user.getRestaurantId(): null);</span><br><span class="line"></span><br><span class="line">    String url &#x3D; &quot;&#x2F;session&quot;;</span><br><span class="line">    return ResponseEntity.created(new URI(url)).body(</span><br><span class="line">            SessionResponseDto.builder()</span><br><span class="line">                    .accessToken(accessToken)</span><br><span class="line">                    .build());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Study</category>
        <category>Spring Boot Project</category>
      </categories>
      <tags>
        <tag>spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title>59. 테이블 예약 기능</title>
    <url>/2020/08/12/hexo_springboot_1_59/</url>
    <content><![CDATA[<h1 id="스프링-부트-프로젝트"><a href="#스프링-부트-프로젝트" class="headerlink" title="스프링 부트 프로젝트"></a>스프링 부트 프로젝트</h1><h3 id="레스토랑-예약-사이트-만들기"><a href="#레스토랑-예약-사이트-만들기" class="headerlink" title="레스토랑 예약 사이트 만들기"></a>레스토랑 예약 사이트 만들기</h3><h4 id="59-테이블-예약-기능"><a href="#59-테이블-예약-기능" class="headerlink" title="59. 테이블 예약 기능"></a>59. 테이블 예약 기능</h4><p>eatgo-restaurant-api 를 추가하여 가게 주인이 사용하는 부분 추가할 것이다.  </p>
<p>Reservation 도메인 모델을 추가 할 것이다.<br>속성 : userId, name, date, time, partySize…  </p>
<p>예약<br>POST /reservations  </p>
<p>예약 확인<br>GET /reservations  </p>
<p>eatgo-common-api<br>Reservation 모델 생성</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Entity</span><br><span class="line">@Getter</span><br><span class="line">@Builder</span><br><span class="line">@AllArgsConstructor</span><br><span class="line">@NoArgsConstructor</span><br><span class="line">public class Reservation &#123;</span><br><span class="line"></span><br><span class="line">    @Id</span><br><span class="line">    @GeneratedValue</span><br><span class="line">    private Long id;</span><br><span class="line"></span><br><span class="line">    private Long restaurantId;</span><br><span class="line"></span><br><span class="line">    private Long userId;</span><br><span class="line"></span><br><span class="line">    @Setter</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    @Setter</span><br><span class="line">    @NotEmpty</span><br><span class="line">    private String date;</span><br><span class="line"></span><br><span class="line">    @Setter</span><br><span class="line">    @NotEmpty</span><br><span class="line">    private String time;</span><br><span class="line"></span><br><span class="line">    @Setter</span><br><span class="line">    @NotNull</span><br><span class="line">    private Integer partySize;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Reservation Repository</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface ReservationRepository extends CrudRepository&lt;Reservation, Long&gt; &#123;</span><br><span class="line"></span><br><span class="line">    Reservation save(Reservation reservation);</span><br><span class="line"></span><br><span class="line">    List&lt;Reservation&gt; findAllByRestaurantId(Long restaurantId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>eatgo-customer-api<br>Reservation Controller</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class ReservationController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private ReservationService reservationService;</span><br><span class="line"></span><br><span class="line">    @PostMapping(&quot;&#x2F;restaurants&#x2F;&#123;restaurantId&#125;&#x2F;reservations&quot;)</span><br><span class="line">    public ResponseEntity&lt;?&gt; create(</span><br><span class="line">            Authentication authentication,</span><br><span class="line">            @RequestBody Reservation resource,</span><br><span class="line">            @Valid @PathVariable(&quot;restaurantId&quot;) Long restaurantId</span><br><span class="line">    ) throws URISyntaxException &#123;</span><br><span class="line">        Claims claims &#x3D; (Claims) authentication.getPrincipal();</span><br><span class="line"></span><br><span class="line">        Reservation reservation &#x3D; reservationService.addReservation(</span><br><span class="line">                restaurantId,</span><br><span class="line">                claims.get(&quot;userId&quot;, Long.class),</span><br><span class="line">                claims.get(&quot;name&quot;, String.class),</span><br><span class="line">                resource.getDate(),</span><br><span class="line">                resource.getTime(),</span><br><span class="line">                resource.getPartySize()</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        String url &#x3D; &quot;&#x2F;restaurants&#x2F;&quot;+restaurantId+&quot;&#x2F;reservations&quot;+reservation.getId();</span><br><span class="line"></span><br><span class="line">        return ResponseEntity.created(new URI(url)).body(&quot;&#123;&#125;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Reservation Service</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Service</span><br><span class="line">@Transactional</span><br><span class="line">public class ReservationService &#123;</span><br><span class="line"></span><br><span class="line">    private ReservationRepository reservationRepository;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    public ReservationService(ReservationRepository reservationRepository) &#123;</span><br><span class="line">        this.reservationRepository &#x3D; reservationRepository;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Reservation addReservation(</span><br><span class="line">            Long restaurantId,</span><br><span class="line">            Long userId,</span><br><span class="line">            String name,</span><br><span class="line">            String date,</span><br><span class="line">            String time,</span><br><span class="line">            Integer partySize) &#123;</span><br><span class="line"></span><br><span class="line">        Reservation reservation &#x3D; Reservation.builder()</span><br><span class="line">                        .restaurantId(restaurantId)</span><br><span class="line">                        .userId(userId)</span><br><span class="line">                        .name(name)</span><br><span class="line">                        .date(date)</span><br><span class="line">                        .time(time)</span><br><span class="line">                        .partySize(partySize)</span><br><span class="line">                        .build();</span><br><span class="line"></span><br><span class="line">        return reservationRepository.save(reservation);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>test(http) 예약</p>
<figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> http POST localhost:8080/restaurants/1/reservations date=2019-12-24 time=30:00 partySize=10 <span class="string">"Authorization:Bearer eyJhbGciOiJIUzI1NiJ9.eyJ1c2VySWQiOjEwMDQsIm5hbWUiOiLsnbTsoJXsnbgifQ.wKrAIT-cOCfQwBO_8UkhK_IOy4tl8uuIeBS4nppu_Vw"</span>         </span></span><br><span class="line">HTTP/1.1 201 </span><br><span class="line">Cache-Control: no-cache, no-store, max-age=0, must-revalidate</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Content-Length: 2</span><br><span class="line">Content-Type: application/json;charset=UTF-8</span><br><span class="line">Date: Fri, 03 Jul 2020 16:36:17 GMT</span><br><span class="line">Expires: 0</span><br><span class="line">Keep-Alive: timeout=60</span><br><span class="line">Location: /restaurants/1/reservations24</span><br><span class="line">Pragma: no-cache</span><br><span class="line">X-Content-Type-Options: nosniff</span><br><span class="line">X-XSS-Protection: 1; mode=block</span><br><span class="line"></span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>


<p>eatgo-restaurant-api에서 예약 확인용으로 사용될 Reservation Controller와 Service를 다르게 생성  </p>
<p>Reservation Service</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Service</span><br><span class="line">@Transactional</span><br><span class="line">public class ReservationService &#123;</span><br><span class="line"></span><br><span class="line">    private ReservationRepository reservationRepository;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    public ReservationService(ReservationRepository reservationRepository) &#123;</span><br><span class="line">        this.reservationRepository &#x3D; reservationRepository;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;Claim으로부터 얻은 restaurantId 기준으로 예약을 조회할것이다.</span><br><span class="line">    public List&lt;Reservation&gt; getReservations(Long restaurantId) &#123;</span><br><span class="line">        return reservationRepository.findAllByRestaurantId(restaurantId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Reservation Controller</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class ReservationController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private ReservationService reservationService;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;&#x2F;reservations&quot;)</span><br><span class="line">    public List&lt;Reservation&gt; list(</span><br><span class="line">            Authentication authentication</span><br><span class="line">    ) &#123;</span><br><span class="line">        Claims claims &#x3D; (Claims) authentication.getPrincipal();</span><br><span class="line"></span><br><span class="line">        Long restaurantId &#x3D; claims.get(&quot;restaurantId&quot;,Long.class);</span><br><span class="line">        return reservationService.getReservations(restaurantId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>test(http) 예약 확인  </p>
<figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> http localhost:8080/reservations <span class="string">"Authorization:Bearer eyJhbGciOiJIUzI1NiJ9.eyJ1c2VySWQiOjIsIm5hbWUiOiLqsIDqsozso7zsnbgiLCJyZXN0YXVyYW50SWQiOjF9.0mje-W_SREwyp6JLxkVPl-MsxwzAiQo4xVZcb-a7pFo"</span>                                              </span></span><br><span class="line">HTTP/1.1 200 </span><br><span class="line">Cache-Control: no-cache, no-store, max-age=0, must-revalidate</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Content-Type: application/json;charset=UTF-8</span><br><span class="line">Date: Fri, 03 Jul 2020 16:42:27 GMT</span><br><span class="line">Expires: 0</span><br><span class="line">Keep-Alive: timeout=60</span><br><span class="line">Pragma: no-cache</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">X-Content-Type-Options: nosniff</span><br><span class="line">X-XSS-Protection: 1; mode=block</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        "date": "2019-12-24",</span><br><span class="line">        "id": 24,</span><br><span class="line">        "name": "이정인",</span><br><span class="line">        "partySize": 10,</span><br><span class="line">        "restaurantId": 1,</span><br><span class="line">        "time": "30:00",</span><br><span class="line">        "userId": 1004</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Study</category>
        <category>Spring Boot Project</category>
      </categories>
      <tags>
        <tag>spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title>62. API 한번에 실행하기</title>
    <url>/2020/08/12/hexo_springboot_1_62/</url>
    <content><![CDATA[<h1 id="스프링-부트-프로젝트"><a href="#스프링-부트-프로젝트" class="headerlink" title="스프링 부트 프로젝트"></a>스프링 부트 프로젝트</h1><h3 id="레스토랑-예약-사이트-만들기"><a href="#레스토랑-예약-사이트-만들기" class="headerlink" title="레스토랑 예약 사이트 만들기"></a>레스토랑 예약 사이트 만들기</h3><h4 id="62-API-한번에-실행하기"><a href="#62-API-한번에-실행하기" class="headerlink" title="62. API 한번에 실행하기"></a>62. API 한번에 실행하기</h4><p>MySQL DB를 사용할것임<br>Container 기술을 활용하여 하나의 컴퓨터에서 가상화된 여러 개의 Container를 올려 여러 서버를 동시에 실행 (Docker)<br>Docker Compose를 활용  </p>
<p>build.gradle 의존성 추가</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">~</span><br><span class="line">	implementation &#39;mysql:mysql-connector-java&#39;</span><br><span class="line">~</span><br></pre></td></tr></table></figure>

<p>application.yml datasource 추가</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  profiles: mysql</span><br><span class="line">  datasource:</span><br><span class="line">    url: jdbc:mysql:&#x2F;&#x2F;$&#123;MYSQL_HOST&#125;:3306&#x2F;$&#123;MYSQL_DATABASE&#125;</span><br><span class="line">    username: $&#123;MYSQL_USER&#125;</span><br><span class="line">    password: $&#123;MYSQL_PASSWORD&#125;</span><br></pre></td></tr></table></figure>

<p>docker-compose.yml 생성<br>각 서비스 등록  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">version: &#39;3&#39;</span><br><span class="line">services:</span><br><span class="line">  mysql:</span><br><span class="line">    image: mariadb:10.4.7</span><br><span class="line">    env_file: .env</span><br><span class="line">    volumes:</span><br><span class="line">      - .&#x2F;data&#x2F;mariadb:&#x2F;var&#x2F;lib&#x2F;mysql</span><br><span class="line">    ports:</span><br><span class="line">      - 13306:3306</span><br><span class="line">    command: |</span><br><span class="line">      --character-set-server&#x3D;utf8mb4</span><br><span class="line">      --collation-server&#x3D;utf8mb4_unicode_ci</span><br><span class="line">    healthcheck:</span><br><span class="line">      test: [&quot;CMD&quot;, &quot;mysqladmin&quot; ,&quot;ping&quot;, &quot;-h&quot;, &quot;localhost&quot;]</span><br><span class="line">      timeout: 10s</span><br><span class="line">      retries: 10</span><br><span class="line">  login-api:</span><br><span class="line">    image: openjdk:11</span><br><span class="line">    env_file: .env</span><br><span class="line">    volumes:</span><br><span class="line">      - .&#x2F;run.sh:&#x2F;Users&#x2F;ijeong-in&#x2F;Git_repo&#x2F;eatgo&#x2F;run.sh</span><br><span class="line">      - .&#x2F;eatgo-login-api&#x2F;build&#x2F;libs:&#x2F;Users&#x2F;ijeong-in&#x2F;Git_repo&#x2F;eatgo&#x2F;libs</span><br><span class="line">    ports:</span><br><span class="line">      - 8001:8080</span><br><span class="line">    depends_on:</span><br><span class="line">      - mysql</span><br><span class="line">    command: bash -c &quot;cd &#x2F;Users&#x2F;ijeong-in&#x2F;Git_repo&#x2F;eatgo &amp;&amp; sh run.sh&quot;</span><br><span class="line">  admin-api:</span><br><span class="line">    image: openjdk:11</span><br><span class="line">    env_file: .env</span><br><span class="line">    volumes:</span><br><span class="line">      - .&#x2F;run.sh:&#x2F;Users&#x2F;ijeong-in&#x2F;Git_repo&#x2F;eatgo&#x2F;run.sh</span><br><span class="line">      - .&#x2F;eatgo-admin-api&#x2F;build&#x2F;libs:&#x2F;Users&#x2F;ijeong-in&#x2F;Git_repo&#x2F;eatgo&#x2F;libs</span><br><span class="line">    ports:</span><br><span class="line">      - 8002:8080</span><br><span class="line">    depends_on:</span><br><span class="line">      - mysql</span><br><span class="line">    command: bash -c &quot;cd &#x2F;Users&#x2F;ijeong-in&#x2F;Git_repo&#x2F;eatgo &amp;&amp; sh run.sh&quot;</span><br><span class="line">  customer-api:</span><br><span class="line">    image: openjdk:11</span><br><span class="line">    env_file: .env</span><br><span class="line">    volumes:</span><br><span class="line">      - .&#x2F;run.sh:&#x2F;Users&#x2F;ijeong-in&#x2F;Git_repo&#x2F;eatgo&#x2F;run.sh</span><br><span class="line">      - .&#x2F;eatgo-customer-api&#x2F;build&#x2F;libs:&#x2F;Users&#x2F;ijeong-in&#x2F;Git_repo&#x2F;eatgo&#x2F;libs</span><br><span class="line">    ports:</span><br><span class="line">      - 8003:8080</span><br><span class="line">    depends_on:</span><br><span class="line">      - mysql</span><br><span class="line">    command: bash -c &quot;cd &#x2F;Users&#x2F;ijeong-in&#x2F;Git_repo&#x2F;eatgo &amp;&amp; sh run.sh&quot;</span><br><span class="line">  restaurant-api:</span><br><span class="line">    image: openjdk:11</span><br><span class="line">    env_file: .env</span><br><span class="line">    volumes:</span><br><span class="line">      - .&#x2F;run.sh:&#x2F;Users&#x2F;ijeong-in&#x2F;Git_repo&#x2F;eatgo&#x2F;run.sh</span><br><span class="line">      - .&#x2F;eatgo-restaurant-api&#x2F;build&#x2F;libs:&#x2F;Users&#x2F;ijeong-in&#x2F;Git_repo&#x2F;eatgo&#x2F;libs</span><br><span class="line">    ports:</span><br><span class="line">      - 8004:8080</span><br><span class="line">    depends_on:</span><br><span class="line">      - mysql</span><br><span class="line">    command: bash -c &quot;cd &#x2F;Users&#x2F;ijeong-in&#x2F;Git_repo&#x2F;eatgo &amp;&amp; sh run.sh&quot;</span><br><span class="line">  admin-web:</span><br><span class="line">    image: node:10.16.3</span><br><span class="line">    volumes:</span><br><span class="line">      - .&#x2F;eatgo-admin-web:&#x2F;Users&#x2F;ijeong-in&#x2F;Git_repo&#x2F;eatgo</span><br><span class="line">    ports:</span><br><span class="line">      - 8082:3000</span><br><span class="line">    environment:</span><br><span class="line">      - VUE_APP_API_BASE_URL&#x3D;http:&#x2F;&#x2F;localhost:8002</span><br><span class="line">      - VUE_APP_LOGIN_API_BASE_URL&#x3D;http:&#x2F;&#x2F;localhost:8001</span><br><span class="line">    command: bash -c &quot;cd &#x2F;Users&#x2F;ijeong-in&#x2F;Git_repo&#x2F;eatgo &amp;&amp; npm run serve&quot;</span><br><span class="line">    healthcheck:</span><br><span class="line">      test: curl -sS http:&#x2F;&#x2F;localhost:8080 || exit 1</span><br><span class="line">      timeout: 10s</span><br><span class="line">      retries: 10</span><br><span class="line">  customer-web:</span><br><span class="line">    image: node:10.16.3</span><br><span class="line">    volumes:</span><br><span class="line">      - .&#x2F;eatgo-customer-web:&#x2F;Users&#x2F;ijeong-in&#x2F;Git_repo&#x2F;eatgo</span><br><span class="line">    ports:</span><br><span class="line">      - 8083:3000</span><br><span class="line">    environment:</span><br><span class="line">      - VUE_APP_API_BASE_URL&#x3D;http:&#x2F;&#x2F;localhost:8003</span><br><span class="line">      - VUE_APP_LOGIN_API_BASE_URL&#x3D;http:&#x2F;&#x2F;localhost:8001</span><br><span class="line">    command: bash -c &quot;cd &#x2F;Users&#x2F;ijeong-in&#x2F;Git_repo&#x2F;eatgo &amp;&amp; npm run serve&quot;</span><br><span class="line">    healthcheck:</span><br><span class="line">      test: curl -sS http:&#x2F;&#x2F;localhost:8080 || exit 1</span><br><span class="line">      timeout: 10s</span><br><span class="line">      retries: 10</span><br><span class="line">  restaurant-web:</span><br><span class="line">    image: node:10.16.3</span><br><span class="line">    volumes:</span><br><span class="line">      - .&#x2F;eatgo-restaurant-web:&#x2F;Users&#x2F;ijeong-in&#x2F;Git_repo&#x2F;eatgo</span><br><span class="line">    ports:</span><br><span class="line">      - 8084:3000</span><br><span class="line">    environment:</span><br><span class="line">      - VUE_APP_API_BASE_URL&#x3D;http:&#x2F;&#x2F;localhost:8004</span><br><span class="line">      - VUE_APP_LOGIN_API_BASE_URL&#x3D;http:&#x2F;&#x2F;localhost:8001</span><br><span class="line">    command: bash -c &quot;cd &#x2F;Users&#x2F;ijeong-in&#x2F;Git_repo&#x2F;eatgo &amp;&amp; npm run serve&quot;</span><br><span class="line">    healthcheck:</span><br><span class="line">      test: curl -sS http:&#x2F;&#x2F;localhost:8080 || exit 1</span><br><span class="line">      timeout: 10s</span><br><span class="line">      retries: 10</span><br></pre></td></tr></table></figure>

<p>DB 및 API 서비스 실행시 적용되는 환경설정 파일(.env)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MYSQL_ROOT_PASSWORD&#x3D;password</span><br><span class="line">MYSQL_USER&#x3D;root</span><br><span class="line">MYSQL_PASSWORD&#x3D;password</span><br><span class="line">MYSQL_DATABASE&#x3D;eatgo</span><br><span class="line">MYSQL_HOST&#x3D;mysql</span><br><span class="line"></span><br><span class="line">SPRING_PROFILES_ACTIVE&#x3D;mysql</span><br></pre></td></tr></table></figure>

<p>각 API 서비스에서 jar파일을 실행할 run.sh</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">until java -jar libs&#x2F;*.jar</span><br><span class="line">do</span><br><span class="line">  printf &quot;******************************************************************&quot;</span><br><span class="line">  sleep 5</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>docker-compose를 통하여 묶어서 단계적으로 실행</p>
<figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker-compose up</span></span><br></pre></td></tr></table></figure>

<p>Docker Container list 확인</p>
<figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker-compose ps</span></span><br><span class="line">         Name                       Command                State     Ports</span><br><span class="line">--------------------------------------------------------------------------</span><br><span class="line">eatgo_admin-api_1        bash -c cd /Users/ijeong-i ...   Exit 137        </span><br><span class="line">eatgo_admin-web_1        docker-entrypoint.sh bash  ...   Exit 0          </span><br><span class="line">eatgo_customer-api_1     bash -c cd /Users/ijeong-i ...   Exit 137        </span><br><span class="line">eatgo_customer-web_1     docker-entrypoint.sh bash  ...   Exit 0          </span><br><span class="line">eatgo_login-api_1        bash -c cd /Users/ijeong-i ...   Exit 137        </span><br><span class="line">eatgo_mysql_1            docker-entrypoint.sh --cha ...   Exit 0          </span><br><span class="line">eatgo_restaurant-api_1   bash -c cd /Users/ijeong-i ...   Exit 137        </span><br><span class="line">eatgo_restaurant-web_1   docker-entrypoint.sh bash  ...   Exit 0</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Study</category>
        <category>Spring Boot Project</category>
      </categories>
      <tags>
        <tag>spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title>05.HelloWorld</title>
    <url>/2020/08/12/hexo_springboot_2_05/</url>
    <content><![CDATA[<h1 id="스프링-부트-프로젝트"><a href="#스프링-부트-프로젝트" class="headerlink" title="스프링 부트 프로젝트"></a>스프링 부트 프로젝트</h1><h3 id="지인-정보-관리-시스템-만들기"><a href="#지인-정보-관리-시스템-만들기" class="headerlink" title="지인 정보 관리 시스템 만들기"></a>지인 정보 관리 시스템 만들기</h3><h4 id="05-HelloWorld"><a href="#05-HelloWorld" class="headerlink" title="05.HelloWorld"></a>05.HelloWorld</h4><ul>
<li>Junit5, MockMvc  </li>
</ul>
<p>@RestController 에는 @Controller와 @ResponseBody가 포함되어 있다.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class HelloWorldController &#123;</span><br><span class="line"></span><br><span class="line">    @GetMapping(value &#x3D; &quot;&#x2F;api&#x2F;helloWorld&quot;)</span><br><span class="line">    public String helloWorld() &#123;</span><br><span class="line">        return &quot;Hello World!&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>junit5에서는 junit4와 다르게 테스트 메서드가 public이 강제되지 않는다.<br>여기서는 public 대신 default 접근자를 사용하였다.<br>모의 http request와 response를 만들어서 테스트하는 것이 MockMvc test이다.  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@SpringBootTest &#x2F;&#x2F;Spring Boot Test임을 명</span><br><span class="line">class HelloWorldControllerTest &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private HelloWorldController helloWorldController;</span><br><span class="line"></span><br><span class="line">    private MockMvc mockMvc;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    void mockMvcTest() throws Exception &#123;</span><br><span class="line">        &#x2F;&#x2F;MockMvc setting </span><br><span class="line">        mockMvc &#x3D; MockMvcBuilders.standaloneSetup(helloWorldController).build();</span><br><span class="line"></span><br><span class="line">        mockMvc.perform(</span><br><span class="line">                MockMvcRequestBuilders.get(&quot;&#x2F;api&#x2F;helloWorld&quot;)</span><br><span class="line">        ).andDo(MockMvcResultHandlers.print()) &#x2F;&#x2F;request, response 상세 출력  </span><br><span class="line">        .andExpect(MockMvcResultMatchers.status().isOk()) &#x2F;&#x2F;status 200?  </span><br><span class="line">        .andExpect(MockMvcResultMatchers.content().string(&quot;Hello World!&quot;));  &#x2F;&#x2F;body 확인  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>JPA  </li>
</ul>
<p>JPA 및 H2 DB 의존성 추가  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    ~</span><br><span class="line">    implementation &#39;org.springframework.boot:spring-boot-starter-data-jpa&#39;</span><br><span class="line">    implementation &#39;com.h2database.h2&#39;</span><br><span class="line">    ~</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Entity, Repository 생성 및 테스트  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Entity</span><br><span class="line">@Builder</span><br><span class="line">@Setter</span><br><span class="line">@Getter</span><br><span class="line">@ToString&#x2F;&#x2F;toString 메서드 오버라이딩  </span><br><span class="line">@AllArgsConstructor</span><br><span class="line">@NoArgsConstructor</span><br><span class="line">@EqualsAndHashCode &#x2F;&#x2F;속성이 모두 동일하면 같은 객체로 인식하도록</span><br><span class="line">&#x2F;&#x2F;@RequiredArgsConstructor &#x2F;&#x2F;NonNull 어노테이션으로 정의된 속성으로만 생성자 정의  </span><br><span class="line">public class Person &#123;</span><br><span class="line"></span><br><span class="line">    @Id</span><br><span class="line">    @GeneratedValue</span><br><span class="line">    private long id;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;@NonNull</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;@NonNull</span><br><span class="line">    private int age;</span><br><span class="line"></span><br><span class="line">    private String hobby;</span><br><span class="line"></span><br><span class="line">    private String bloodType;</span><br><span class="line"></span><br><span class="line">    private String address;</span><br><span class="line"></span><br><span class="line">    private LocalDate birthDay;</span><br><span class="line"></span><br><span class="line">    private String job;</span><br><span class="line"></span><br><span class="line">    @ToString.Exclude &#x2F;&#x2F;toString 오버라이딩에서 제외  </span><br><span class="line">    private String phoneNumber;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface PersonRepository extends JpaRepository&lt;Person, Long&gt; &#123;</span><br><span class="line">&#x2F;&#x2F;Person을 Entity로 가지는 JPA Repository 생성, @Id의 타입은 Long  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JPA 실제 수행되는 SQL문 확인하기<br>application.yml</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  jpa:</span><br><span class="line">    show-sql: true</span><br></pre></td></tr></table></figure>

<p>Create / Read Test</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@SpringBootTest</span><br><span class="line">class PersonRepositoryTest &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private PersonRepository personRepository;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    void crud() &#123;</span><br><span class="line">        Person person &#x3D; Person.builder()</span><br><span class="line">                .name(&quot;robin&quot;)</span><br><span class="line">                .age(10)</span><br><span class="line">                .build();</span><br><span class="line">        personRepository.save(person);</span><br><span class="line"></span><br><span class="line">        List&lt;Person&gt; people &#x3D; personRepository.findAll();</span><br><span class="line">        assertThat(people.size()).isEqualTo(1);</span><br><span class="line">        assertThat(people.get(0).getName()).isEqualTo(&quot;robin&quot;);</span><br><span class="line">        assertThat(people.get(0).getAge()).isEqualTo(10);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Study</category>
        <category>Spring Boot Project</category>
      </categories>
      <tags>
        <tag>spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title>10. JPA Relation</title>
    <url>/2020/08/12/hexo_springboot_2_10/</url>
    <content><![CDATA[<h1 id="스프링-부트-프로젝트"><a href="#스프링-부트-프로젝트" class="headerlink" title="스프링 부트 프로젝트"></a>스프링 부트 프로젝트</h1><h3 id="지인-정보-관리-시스템-만들기"><a href="#지인-정보-관리-시스템-만들기" class="headerlink" title="지인 정보 관리 시스템 만들기"></a>지인 정보 관리 시스템 만들기</h3><h4 id="10-JPA-Relation"><a href="#10-JPA-Relation" class="headerlink" title="10. JPA Relation"></a>10. JPA Relation</h4><p>차단 사람을 구분하기 위한 Block Entity 생성  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Entity</span><br><span class="line">@NoArgsConstructor</span><br><span class="line">@Data</span><br><span class="line">@Builder</span><br><span class="line">@AllArgsConstructor</span><br><span class="line">@RequiredArgsConstructor</span><br><span class="line">public class Block &#123;</span><br><span class="line"></span><br><span class="line">    @Id</span><br><span class="line">    @GeneratedValue</span><br><span class="line">    private long id;</span><br><span class="line"></span><br><span class="line">    @NonNull</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    private String reason;</span><br><span class="line"></span><br><span class="line">    private LocalDate startDate;</span><br><span class="line"></span><br><span class="line">    private LocalDate endDate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Person Entity와 Relation 설정<br>Block의 유무만 판단할 것이므로 일대일 단방향<br>@JoinColumn 어노테이션이 없으면 @Id로 제약조건이 생성됨  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;CascadeType.PERSIST는 이 엔티티에서 Block에 대한 영속성을 관리하겠다는 의미이다.</span><br><span class="line">&#x2F;&#x2F;MERGE, REMOVE, REFRESH, DETACH 등은 엔티티의 변경에 있어서 보유된 엔티티(Block)의 해당 작업에 대해서도 변경하는 것이다.   </span><br><span class="line">&#x2F;&#x2F;ALL은 위의 5가지를 모두 적용하는 것이다.</span><br><span class="line">&#x2F;&#x2F;@OneToOne(cascade &#x3D; &#123;CascadeType.PERSIST, CascadeType.MERGE, CascadeType.REMOVE&#125;)</span><br><span class="line">&#x2F;&#x2F;orphanRemoval &#x3D; true는 해당 Block이 해제(setBlock(null))되는 순간 삭제시킨다. -&gt; 불필요 엔티티 관리  </span><br><span class="line">&#x2F;&#x2F;fetch type 은 EAGER(default)와 LAZY가 있는데 LAZY의 경우에는 이 엔티티를 호출(select)할때 Block을 호출하지 않고 필요할때 호출한다.  </span><br><span class="line">&#x2F;&#x2F;optional &#x3D; true(default), false인 경우는 이 속성이 null일 수 없게 된다.  </span><br><span class="line">@OneToOne(cascade &#x3D; CascadeType.ALL, orphanRemoval &#x3D; true, fetch &#x3D; FetchType.EAGER)</span><br><span class="line">private Block block;</span><br></pre></td></tr></table></figure>

<p>Person Service에서 차단된 사람을 제외하고 가져오는 메서드와 id로 조회하는 메서드 생성     </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Service</span><br><span class="line">@Slf4j</span><br><span class="line">public class PersonService &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private PersonRepository personRepository;</span><br><span class="line"></span><br><span class="line">    public List&lt;Person&gt; getPeopleExcludeBlocks() &#123;</span><br><span class="line">        List&lt;Person&gt; people &#x3D; personRepository.findAll();</span><br><span class="line"></span><br><span class="line">        return people.stream().filter(</span><br><span class="line">                person -&gt; person.getBlock() &#x3D;&#x3D; null</span><br><span class="line">        ).collect(Collectors.toList());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Person getPerson(Long id) &#123;</span><br><span class="line">        Person person &#x3D; personRepository.findById(id).get();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;System.out은 모든 로그를 출력하지만</span><br><span class="line">        &#x2F;&#x2F;log.info(Slf4j)는 로그백을 이용하여 로그 출력을 제한할 수 있다.  </span><br><span class="line">        &#x2F;&#x2F;System.out.println(&quot;person : &quot;+ person);</span><br><span class="line">        log.info(&quot;person : &#123;&#125;&quot;, person);</span><br><span class="line">        &#x2F;&#x2F;ex) 2020-07-17 17:01:52.918  INFO 2781 --- [    Test worker] c.f.j.p.mycontact.service.PersonService  : person : Person(id&#x3D;3, name&#x3D;Dennis, age&#x3D;7, hobby&#x3D;null, bloodType&#x3D;O, address&#x3D;null, birthDay&#x3D;null, job&#x3D;null, block&#x3D;Block(id&#x3D;4, name&#x3D;Dennis, reason&#x3D;null, startDate&#x3D;null, endDate&#x3D;null))</span><br><span class="line">        &#x2F;&#x2F;이때 로그를 출력하는 중에 사용되는 SQL이 fetch type에 따라 다른데</span><br><span class="line">        &#x2F;&#x2F;EAGER에서는 모든 Block을 Person이 호출될때(toString(person)에서) 호출한다. (left join을 사용한 1개 select문)</span><br><span class="line">        &#x2F;&#x2F;이때 optional &#x3D; false 인 경우에 inner join을 사용하게 된다.</span><br><span class="line">        &#x2F;&#x2F;LAZY에서는 Person 먼저 호출하고 그 후 해당되는 id의 Block을 따로 호출한다. (2개 select문)</span><br><span class="line">        &#x2F;&#x2F;또한 LAZY인 경우에 Block 속성에 @ToString.Exclude 처리를 하면 toString에서 빠지게 되므로 block에 대한 호출은 없어진다.   </span><br><span class="line">        &#x2F;&#x2F;LAZY는 간단하지 않지만 불필요한 쿼리 호출을 줄여 성능을 개선할 수 있다는 장점이 있다.  </span><br><span class="line"></span><br><span class="line">        return person;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Study</category>
        <category>Spring Boot Project</category>
      </categories>
      <tags>
        <tag>spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title>13. JPA Query Method</title>
    <url>/2020/08/12/hexo_springboot_2_13/</url>
    <content><![CDATA[<h1 id="스프링-부트-프로젝트"><a href="#스프링-부트-프로젝트" class="headerlink" title="스프링 부트 프로젝트"></a>스프링 부트 프로젝트</h1><h3 id="지인-정보-관리-시스템-만들기"><a href="#지인-정보-관리-시스템-만들기" class="headerlink" title="지인 정보 관리 시스템 만들기"></a>지인 정보 관리 시스템 만들기</h3><h4 id="13-JPA-Query-Method"><a href="#13-JPA-Query-Method" class="headerlink" title="13. JPA Query Method"></a>13. JPA Query Method</h4><p>일반적으로 우리가 테스트에서 자주 사용하는 JPA의 findall()은 실제 운영에서는 사용하지 않는다.<br>그 대신 where절이 걸려있는 sql을 원하게 되는데 이때 JPA Query Method를 사용하여 쿼리를 만들어 쓸 수 있다.<br>find : select<br>By : where<br>And : and<br>Or : or<br>Between : between A and B<br>LessThan : tab.col &lt; val<br>LessThanEqual : tab.col &lt;= val<br>GreaterThan : tab.col &gt; val<br>GreaterThanEqual : tab.col &gt;= val<br>After : tab.date &gt; val(date)<br>Before : tab.date &lt; val(date)<br>IsNull : is null, = null<br>(Is)NotNull : not null, != null<br>Like : like %val%<br>NotLike : not like %val%<br>StartingWith : like val%<br>EndingWith : like %val<br>Containing : like %val%<br>OrderBy : order by<br>Not : &lt;&gt;<br>In : in ()<br>NotIn : not in ()<br>True : = true<br>False : = false<br>IgnoreCase : UPPER(tab.col) / UPPER(val)</p>
<p>ex)<br>만약 무조건 1 row만 리턴하는 쿼리라면 리턴타입을 Person으로 해도 되지만 2 rows 이상 리턴할 때 에러가 발생한다.  </p>
<p>이름으로 찾기 : List<Person> findByName(String name)<br>이름 포함 : List<Person> findByNameContaining(String name) / List<Person> findByNameLike(String name)<br>차단되지 않은 사람 : List<Person> findByBlockIsNull()<br>특정 기간동안에 생일이 있는 사람 : List<Person> findByBirthDayBetween(LocalDate startDate, LocalDate endDate);</p>
<p>만약 이번달에 생일인 사람을 찾는 기능을 추가하고 싶을때<br>LocalDate에서 월만 분류하면 성능적으로 바람직하지 못함.<br>그렇기 때문에 BirthDay라는 Entity를 추가하여 생일의 연월일을 나눈다.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.fastcampus.javaallinone.project3.mycontact.domain.dto;</span><br><span class="line"></span><br><span class="line">import lombok.AllArgsConstructor;</span><br><span class="line">import lombok.Data;</span><br><span class="line">import lombok.NoArgsConstructor;</span><br><span class="line"></span><br><span class="line">import javax.persistence.Embeddable;</span><br><span class="line"></span><br><span class="line">@Embeddable &#x2F;&#x2F;Entity에 속할 DTO라는것을 명시</span><br><span class="line">@Data</span><br><span class="line">@NoArgsConstructor</span><br><span class="line">public class Birthday &#123;</span><br><span class="line">    private int yearOfBirthday;</span><br><span class="line"></span><br><span class="line">    @Min(1)</span><br><span class="line">    @Max(12)</span><br><span class="line">    private int monthOfBirthday;</span><br><span class="line"></span><br><span class="line">    @Min(1)</span><br><span class="line">    @Max(31)</span><br><span class="line">    private int DayOfBirthday;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;여기서 생성자를 따로 만들었는데 LocalDate 타입을 사용해서 날짜 제한을 두기 위함임.</span><br><span class="line">    public Birthday(LocalDate birthday) &#123;</span><br><span class="line">        this.yearOfBirthDay &#x3D; birthday.getYear();</span><br><span class="line">        this.monthOfBirthDay &#x3D; birthday.getMonthValue();</span><br><span class="line">        this.dayOfBirthday &#x3D; birthday.getDayOfMonth();</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Person의 BitrhDay 속성 변경</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">~</span><br><span class="line">    @Valid</span><br><span class="line">    @Embedded &#x2F;&#x2F;Embeddable DTO 사용</span><br><span class="line">    private BirthDay birthDay;</span><br><span class="line">~</span><br></pre></td></tr></table></figure>

<p>Person Repository에 기능 추가<br>@Query는 JPQL이라는 Entity기반으로 쿼리를 실행하는 로직을 이용할 어노테이션이다.<br>아래에서 사용하지 않으면 Person에는 monthOfBirthDay라는 속성이 없으므로 에러가 발생한다.<br>아래 JPQL문의 ?1은 메서드의 첫번째 인자를 의미한다.   </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Query(value &#x3D; &quot;select person from Person person where person.birthDay.monthOfBirthday &#x3D; ?1&quot;)</span><br><span class="line">List&lt;Person&gt; findByMonthOfBirthday(int monthOfBirthday);</span><br></pre></td></tr></table></figure>

<p>명시적인 파라미터를 사용하고 싶다면 아래와 같이 사용할 수 있다.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Query(value &#x3D; &quot;select person from Person person where person.birthDay.monthOfBirthday &#x3D; :monthOfBirthDay and person.birthDay.dayOfBirthday &#x3D; :dayOfBirthday&quot;)</span><br><span class="line">List&lt;Person&gt; findByMonthOfBirthday(@Param(&quot;monthOfBirthday&quot;) int monthOfBirthday,@Param(&quot;dayOfBirthday&quot;) int dayOfBirthday);</span><br></pre></td></tr></table></figure>

<p>실제 DB에서 수행될 SQL문 그대로를 만들고 싶을때는 nativeQuery 옵션을 사용할 수 있다.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Query(value &#x3D; &quot;select * from person where month_of_birthday &#x3D; :monthOfBirthday and day_of_birthday &#x3D; :dayOfBirthday&quot;, nativeQuery &#x3D; true)</span><br><span class="line">List&lt;Person&gt; findByMonthOfBirthday(@Param(&quot;monthOfBirthday&quot;) int monthOfBirthday,@Param(&quot;dayOfBirthday&quot;) int dayOfBirthday);</span><br></pre></td></tr></table></figure>

<p>test 디렉토리에 resources 디렉토리 생성 후 data.sql 파일 생성</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">insert into person(&#96;id&#96;, &#96;name&#96;, &#96;age&#96;, &#96;blood_type&#96;, &#96;year_of_birthday&#96;, &#96;month_of_birthday&#96;, &#96;day_of_birthday&#96;) values (1,&#39;martin&#39;,10,&#39;A&#39;,1992,1,30);</span><br><span class="line">insert into person(&#96;id&#96;, &#96;name&#96;, &#96;age&#96;, &#96;blood_type&#96;, &#96;year_of_birthday&#96;, &#96;month_of_birthday&#96;, &#96;day_of_birthday&#96;) values (2,&#39;david&#39;,9,&#39;B&#39;,1994,3,24);</span><br><span class="line">insert into person(&#96;id&#96;, &#96;name&#96;, &#96;age&#96;, &#96;blood_type&#96;, &#96;year_of_birthday&#96;, &#96;month_of_birthday&#96;, &#96;day_of_birthday&#96;) values (3,&#39;dennis&#39;,8,&#39;AB&#39;,2000,12,24);</span><br><span class="line">insert into person(&#96;id&#96;, &#96;name&#96;, &#96;age&#96;, &#96;blood_type&#96;, &#96;year_of_birthday&#96;, &#96;month_of_birthday&#96;, &#96;day_of_birthday&#96;) values (4,&#39;sophia&#39;,7,&#39;O&#39;,1999,8,15);</span><br><span class="line">insert into person(&#96;id&#96;, &#96;name&#96;, &#96;age&#96;, &#96;blood_type&#96;, &#96;year_of_birthday&#96;, &#96;month_of_birthday&#96;, &#96;day_of_birthday&#96;) values (5,&#39;benny&#39;,6,&#39;A&#39;,2001,2,24);</span><br><span class="line"></span><br><span class="line">insert into block(&#96;id&#96;, &#96;name&#96;) values (1, &#39;dennis&#39;);</span><br><span class="line">insert into block(&#96;id&#96;, &#96;name&#96;) values (2, &#39;sophia&#39;);</span><br><span class="line"></span><br><span class="line">update person set block_id &#x3D; 1 where id &#x3D; 3;</span><br><span class="line">update person set block_id &#x3D; 2 where id &#x3D; 4;</span><br></pre></td></tr></table></figure>
<p>테스트 진행 시 위의 SQL문을 먼저 실행한 뒤 테스트가 진행된다.  </p>
]]></content>
      <categories>
        <category>Study</category>
        <category>Spring Boot Project</category>
      </categories>
      <tags>
        <tag>spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title>16. Controller HTTP Method</title>
    <url>/2020/08/12/hexo_springboot_2_16/</url>
    <content><![CDATA[<h1 id="스프링-부트-프로젝트"><a href="#스프링-부트-프로젝트" class="headerlink" title="스프링 부트 프로젝트"></a>스프링 부트 프로젝트</h1><h3 id="지인-정보-관리-시스템-만들기"><a href="#지인-정보-관리-시스템-만들기" class="headerlink" title="지인 정보 관리 시스템 만들기"></a>지인 정보 관리 시스템 만들기</h3><h4 id="16-Controller-HTTP-Method"><a href="#16-Controller-HTTP-Method" class="headerlink" title="16. Controller HTTP Method"></a>16. Controller HTTP Method</h4><p>Controller에 각 HTTP 메서드를 이용한 기능 생성  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@Slf4j</span><br><span class="line">@RequestMapping(value &#x3D; &quot;&#x2F;api&#x2F;person&quot;)</span><br><span class="line">public class PersonController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private PersonService personService;</span><br><span class="line">    @Autowired</span><br><span class="line">    private PersonRepository personRepository;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;&#x2F;&#123;id&#125;&quot;)</span><br><span class="line">    public Person getPerson(@PathVariable Long id) &#123;</span><br><span class="line">        return personService.getPerson(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;회원 정보 변경에서 받을 용도로 PersonDto Class를 만들었다.  </span><br><span class="line">    @PostMapping</span><br><span class="line">    public ResponseEntity&lt;?&gt; postPerson(@RequestBody Person resource) throws URISyntaxException &#123;</span><br><span class="line">        Person person &#x3D; personService.put(resource);</span><br><span class="line"></span><br><span class="line">        log.info(&quot;person -&gt; &#123;&#125;&quot;,personRepository.findAll());</span><br><span class="line"></span><br><span class="line">        String url &#x3D; &quot;&#x2F;api&#x2F;person&#x2F;&quot;+person.getId();</span><br><span class="line">        return ResponseEntity.created(new URI(url)).body(&quot;&#123;&#125;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @PutMapping(&quot;&#x2F;&#123;id&#125;&quot;)</span><br><span class="line">    public void modifyPerson(@PathVariable Long id,@RequestBody PersonDto personDto) &#123;</span><br><span class="line">        personService.modify(id, personDto);</span><br><span class="line"></span><br><span class="line">        log.info(&quot;person -&gt; &#123;&#125;&quot;,personRepository.findAll());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @PatchMapping(&quot;&#x2F;&#123;id&#125;&quot;)</span><br><span class="line">    public void modifyPerson(@PathVariable Long id,String name) &#123;</span><br><span class="line">        personService.modify(id, name);</span><br><span class="line"></span><br><span class="line">        log.info(&quot;person -&gt; &#123;&#125;&quot;,personRepository.findAll());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @DeleteMapping(&quot;&#x2F;&#123;id&#125;&quot;)</span><br><span class="line">    public void deletePerson(@PathVariable Long id) &#123;</span><br><span class="line">        personService.delete(id);</span><br><span class="line"></span><br><span class="line">        log.info(&quot;person -&gt; &#123;&#125;&quot;,personRepository.findAll());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>회원 정보 변경에서 받을 용도로 PersonDto Class를 만들었다.  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Data</span><br><span class="line">public class PersonDto &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    private String hobby;</span><br><span class="line">    private String address;</span><br><span class="line">    private String bloodType;</span><br><span class="line">    private String job;</span><br><span class="line">    private String phoneNumber;</span><br><span class="line">    private LocalDate Birthday;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>personService.modify 메서드 오버로딩을 통해 회원 정보 변경과 이름 변경을 따로 구현하였다.  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Service</span><br><span class="line">@Slf4j</span><br><span class="line">public class PersonService &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private PersonRepository personRepository;</span><br><span class="line"></span><br><span class="line">    public List&lt;Person&gt; getPeopleExcludeBlocks() &#123;</span><br><span class="line">        return personRepository.findByBlockIsNull();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Transactional(readOnly &#x3D; true)</span><br><span class="line">    public Person getPerson(Long id) &#123;</span><br><span class="line">        Person person &#x3D; personRepository.findById(id).orElse(null);</span><br><span class="line"></span><br><span class="line">        log.info(&quot;person : &#123;&#125;&quot;, person);</span><br><span class="line"></span><br><span class="line">        return person;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public List&lt;Person&gt; getPeopleByName(String name) &#123;</span><br><span class="line">        return personRepository.findByName(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public List&lt;Person&gt; getPeopleNameContaining(String name) &#123;</span><br><span class="line">        return personRepository.findByNameLike(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Transactional</span><br><span class="line">    public Person put(Person person) &#123;</span><br><span class="line">        return personRepository.save(person);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void modify(Long id, PersonDto personDto) &#123;</span><br><span class="line">        Person personAtDb &#x3D;  personRepository.findById(id)</span><br><span class="line">                .orElseThrow(() -&gt; new RuntimeException(&quot;아이디가 존재하지 않습니다.&quot;));</span><br><span class="line"></span><br><span class="line">        if (!personAtDb.getName().equals(personDto.getName())) &#123;</span><br><span class="line">            throw new RuntimeException(&quot;이름이 다릅니다.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;Person 클래스에 정보 변경을 위한 set 메서드를 만들었다.  </span><br><span class="line">        personAtDb.set(personDto);</span><br><span class="line"></span><br><span class="line">        personRepository.save(personAtDb);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;오버로딩(이름만 변경)</span><br><span class="line">    public void modify(Long id, String name) &#123;</span><br><span class="line">        Person person &#x3D; personRepository.findById(id)</span><br><span class="line">                .orElseThrow(() -&gt; new RuntimeException(&quot;아이디가 존재하지 않습니다.&quot;));</span><br><span class="line"></span><br><span class="line">        person.setName(name);</span><br><span class="line">        personRepository.save(person);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;DB에서 delete하는 대신 flag(deleted)를 사용하였다.  </span><br><span class="line">    public void delete(Long id) &#123;</span><br><span class="line">        Person person &#x3D; personRepository.findById(id)</span><br><span class="line">                .orElseThrow(() -&gt; new RuntimeException(&quot;아이디가 존재하지 않습니다.&quot;));</span><br><span class="line"></span><br><span class="line">        person.setDeleted(true);</span><br><span class="line">        personRepository.save(person);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Person Class  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">~</span><br><span class="line">&#x2F;&#x2F; 모든 JPA 작업에서 아래 조건이 자동으로 추가된다.</span><br><span class="line">@Where(clause &#x3D; &quot;deleted &#x3D; false&quot;)</span><br><span class="line">public class Person &#123;</span><br><span class="line"></span><br><span class="line">    ~</span><br><span class="line">    &#x2F;&#x2F;디폴트값은 false로 설정</span><br><span class="line">    @ColumnDefault(&quot;0&quot;)</span><br><span class="line">    private boolean deleted;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;정보 변경을 위한 메서드 구현, 빈값이면 변경하지 않도록  </span><br><span class="line">    public void set(PersonDto personDto) &#123;</span><br><span class="line">        if (personDto.getAge() !&#x3D; 0) &#123;</span><br><span class="line">            this.setAge(personDto.getAge());</span><br><span class="line">        &#125;</span><br><span class="line">        if (!StringUtils.isEmpty(personDto.getAddress())) &#123;</span><br><span class="line">            this.setAddress(personDto.getAddress());</span><br><span class="line">        &#125;</span><br><span class="line">        if (!StringUtils.isEmpty(personDto.getAge())) &#123;</span><br><span class="line">            this.setAge(personDto.getAge());</span><br><span class="line">        &#125;</span><br><span class="line">        if (!StringUtils.isEmpty(personDto.getHobby())) &#123;</span><br><span class="line">            this.setHobby(personDto.getHobby());</span><br><span class="line">        &#125;</span><br><span class="line">        if (!StringUtils.isEmpty(personDto.getBloodType())) &#123;</span><br><span class="line">            this.setBloodType(personDto.getBloodType());</span><br><span class="line">        &#125;</span><br><span class="line">        if (!StringUtils.isEmpty(personDto.getJob())) &#123;</span><br><span class="line">            this.setJob(personDto.getJob());</span><br><span class="line">        &#125;</span><br><span class="line">        if (!StringUtils.isEmpty(personDto.getPhoneNumber())) &#123;</span><br><span class="line">            this.setPhoneNumber(personDto.getPhoneNumber());</span><br><span class="line">        &#125;</span><br><span class="line">        if (personDto.getBirthday() !&#x3D; null) &#123;</span><br><span class="line">            this.setBirthday(new Birthday(personDto.getBirthday()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@Where(clause = “deleted = false”) 를 걸어두었기 때문에<br>만약, deleted = true인 값을 조회하고 싶을땐 nativeQuery를 사용하여야 한다.  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Query(value &#x3D; &quot;select * from person where deleted &#x3D; true&quot;, nativeQuery &#x3D; true)</span><br><span class="line">List&lt;Person&gt; findPeopleDeleted();</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Study</category>
        <category>Spring Boot Project</category>
      </categories>
      <tags>
        <tag>spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title>20. 리팩토링 도메인코드</title>
    <url>/2020/08/12/hexo_springboot_2_20/</url>
    <content><![CDATA[<h1 id="스프링-부트-프로젝트"><a href="#스프링-부트-프로젝트" class="headerlink" title="스프링 부트 프로젝트"></a>스프링 부트 프로젝트</h1><h3 id="지인-정보-관리-시스템-만들기"><a href="#지인-정보-관리-시스템-만들기" class="headerlink" title="지인 정보 관리 시스템 만들기"></a>지인 정보 관리 시스템 만들기</h3><h4 id="20-리팩토링-도메인코드"><a href="#20-리팩토링-도메인코드" class="headerlink" title="20. 리팩토링 도메인코드"></a>20. 리팩토링 도메인코드</h4><p>bloodType 속성 제거<br>block 속성 제거<br>age 속성은 제거하고 birthday를 통해 나이를 계산하는 getAge 메서드 추가<br>오늘이 생일인지 확인하는 기능 추가 (isBirthdayToday)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Entity</span><br><span class="line">@Setter</span><br><span class="line">@Getter</span><br><span class="line">@ToString</span><br><span class="line">@NoArgsConstructor</span><br><span class="line">@EqualsAndHashCode</span><br><span class="line">@RequiredArgsConstructor</span><br><span class="line">@AllArgsConstructor</span><br><span class="line">@Where(clause &#x3D; &quot;deleted &#x3D; false&quot;)</span><br><span class="line">public class Person &#123;</span><br><span class="line"></span><br><span class="line">    @Id</span><br><span class="line">    @GeneratedValue(strategy &#x3D; GenerationType.IDENTITY)</span><br><span class="line">    private long id;</span><br><span class="line"></span><br><span class="line">    @NonNull</span><br><span class="line">    @NotEmpty</span><br><span class="line">    @Column(nullable &#x3D; false)</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    private String hobby;</span><br><span class="line"></span><br><span class="line">    private String address;</span><br><span class="line"></span><br><span class="line">    @Valid</span><br><span class="line">    @Embedded</span><br><span class="line">    private Birthday birthday;</span><br><span class="line"></span><br><span class="line">    private String job;</span><br><span class="line"></span><br><span class="line">    private String phoneNumber;</span><br><span class="line"></span><br><span class="line">    @ColumnDefault(&quot;0&quot;)</span><br><span class="line">    private boolean deleted;</span><br><span class="line"></span><br><span class="line">    public Integer getAge() &#123;</span><br><span class="line">        if (this.birthday !&#x3D; null) &#123;</span><br><span class="line">            return LocalDate.now().getYear() - this.birthday.getYearOfBirthday() + 1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean isBirthdayToday() &#123;</span><br><span class="line">        return LocalDate.now().equals(LocalDate.of(</span><br><span class="line">                this.birthday.getYearOfBirthday(),this.birthday.getMonthOfBirthday(),this.birthday.getDayOfBirthday()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void set(PersonDto personDto) &#123;</span><br><span class="line">        if (!StringUtils.isEmpty(personDto.getAddress())) &#123;</span><br><span class="line">            this.setAddress(personDto.getAddress());</span><br><span class="line">        &#125;</span><br><span class="line">        if (!StringUtils.isEmpty(personDto.getHobby())) &#123;</span><br><span class="line">            this.setHobby(personDto.getHobby());</span><br><span class="line">        &#125;</span><br><span class="line">        if (!StringUtils.isEmpty(personDto.getJob())) &#123;</span><br><span class="line">            this.setJob(personDto.getJob());</span><br><span class="line">        &#125;</span><br><span class="line">        if (!StringUtils.isEmpty(personDto.getPhoneNumber())) &#123;</span><br><span class="line">            this.setPhoneNumber(personDto.getPhoneNumber());</span><br><span class="line">        &#125;</span><br><span class="line">        if (personDto.getBirthday() !&#x3D; null) &#123;</span><br><span class="line">            this.setBirthday(Birthday.of(personDto.getBirthday()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>Birthday 속성 출력 변경을 위하여 Configuration 생성 및 JsonSerializer 사용  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class BirthdaySerializer extends JsonSerializer&lt;Birthday&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void serialize(Birthday value, JsonGenerator gen, SerializerProvider serializers)</span><br><span class="line">            throws IOException &#123;</span><br><span class="line">        if (value !&#x3D; null) &#123;</span><br><span class="line">            gen.writeObject(</span><br><span class="line">                    LocalDate.of(value.getYearOfBirthday(), value.getMonthOfBirthday(), value.getDayOfBirthday()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class JsonConfig &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public MappingJackson2HttpMessageConverter mappingJackson2HttpMessageConverter(ObjectMapper objectMapper) &#123;</span><br><span class="line">        MappingJackson2HttpMessageConverter converter &#x3D; new MappingJackson2HttpMessageConverter();</span><br><span class="line">        converter.setObjectMapper(objectMapper);</span><br><span class="line"></span><br><span class="line">        return converter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public ObjectMapper objectMapper() &#123;</span><br><span class="line">        ObjectMapper objectMapper &#x3D; new ObjectMapper();</span><br><span class="line">        objectMapper.registerModule(new BirthdayModule());</span><br><span class="line">        objectMapper.registerModule(new JavaTimeModule());</span><br><span class="line"></span><br><span class="line">        objectMapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false);</span><br><span class="line"></span><br><span class="line">        return objectMapper;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class BirthdayModule extends SimpleModule &#123;</span><br><span class="line">        BirthdayModule() &#123;</span><br><span class="line">            super();</span><br><span class="line">            addSerializer(Birthday.class, new BirthdaySerializer());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Controller 테스트 구체화</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@SpringBootTest</span><br><span class="line">@Transactional</span><br><span class="line">class PersonControllerTest &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private PersonController personController;</span><br><span class="line">    @Autowired</span><br><span class="line">    private PersonRepository personRepository;</span><br><span class="line">    @Autowired</span><br><span class="line">    private ObjectMapper objectMapper;</span><br><span class="line">    @Autowired</span><br><span class="line">    private MappingJackson2HttpMessageConverter messageConverter;</span><br><span class="line"></span><br><span class="line">    private MockMvc mockMvc;</span><br><span class="line"></span><br><span class="line">    @BeforeEach</span><br><span class="line">    void beforeEach() &#123;</span><br><span class="line">        mockMvc &#x3D; MockMvcBuilders.standaloneSetup(personController).setMessageConverters(messageConverter).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    void getPerson() throws Exception &#123;</span><br><span class="line">        mockMvc.perform(MockMvcRequestBuilders.get(&quot;&#x2F;api&#x2F;person&#x2F;1&quot;))</span><br><span class="line">                .andDo(print())</span><br><span class="line">                .andExpect(status().isOk())</span><br><span class="line">                .andExpect(jsonPath(&quot;$.name&quot;).value(&quot;martin&quot;))</span><br><span class="line">                .andExpect(jsonPath(&quot;$.hobby&quot;).isEmpty())</span><br><span class="line">                .andExpect(jsonPath(&quot;$.address&quot;).isEmpty())</span><br><span class="line">                &#x2F;&#x2F;아래처럼 birthday를 체이닝할 필요 없이 serializing된 값을 사용  </span><br><span class="line">                .andExpect(jsonPath(&quot;$.birthday&quot;).value(&quot;1992-01-30&quot;))</span><br><span class="line">                &#x2F;&#x2F;.andExpect(jsonPath(&quot;$.birthday.yearOfBirthday&quot;).value(1992))</span><br><span class="line">                &#x2F;&#x2F;.andExpect(jsonPath(&quot;$.birthday.monthOfBirthday&quot;).value(1))</span><br><span class="line">                &#x2F;&#x2F;.andExpect(jsonPath(&quot;$.birthday.dayOfBirthday&quot;).value(30))</span><br><span class="line">                .andExpect(jsonPath(&quot;$.job&quot;).isEmpty())</span><br><span class="line">                .andExpect(jsonPath(&quot;$.phoneNumber&quot;).isEmpty())</span><br><span class="line">                .andExpect(jsonPath(&quot;$.deleted&quot;).value(false))</span><br><span class="line">                &#x2F;&#x2F;age나 birthdayToday는 시간에 따라 바뀌므로 타입만 검증  </span><br><span class="line">                .andExpect(jsonPath(&quot;$.age&quot;).isNumber())</span><br><span class="line">                .andExpect(jsonPath(&quot;$.birthdayToday&quot;).isBoolean());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    void postPerson() throws Exception &#123;</span><br><span class="line">        PersonDto personDto &#x3D; PersonDto.of(&quot;martin&quot;,</span><br><span class="line">                &quot;programming&quot;,</span><br><span class="line">                &quot;판교&quot;,</span><br><span class="line">                &quot;programmer&quot;,</span><br><span class="line">                &quot;010-1111-1111&quot;,</span><br><span class="line">                LocalDate.now());</span><br><span class="line"></span><br><span class="line">        mockMvc.perform(MockMvcRequestBuilders.post(&quot;&#x2F;api&#x2F;person&quot;)</span><br><span class="line">                .contentType(MediaType.APPLICATION_JSON)</span><br><span class="line">                .content(toJsonString(personDto)))</span><br><span class="line">                .andDo(print())</span><br><span class="line">                .andExpect(status().isCreated())</span><br><span class="line">                .andExpect(content().string(&quot;\&quot;&#123;&#125;\&quot;&quot;));</span><br><span class="line"></span><br><span class="line">        Person result &#x3D; personRepository.findAll(Sort.by(Direction.DESC, &quot;id&quot;)).get(0);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;assertAll에 속한 모든 테스트를 모두 실행한다.</span><br><span class="line">        &#x2F;&#x2F;assertAll이 아니면 순차적으로 실행하며 실패할 시 다음 테스트를 진행하지 않는다. </span><br><span class="line">        assertAll(</span><br><span class="line">                () -&gt; assertThat(result.getName()).isEqualTo(&quot;martin&quot;),</span><br><span class="line">                () -&gt; assertThat(result.getHobby()).isEqualTo(&quot;programming&quot;),</span><br><span class="line">                () -&gt; assertThat(result.getAddress()).isEqualTo(&quot;판교&quot;),</span><br><span class="line">                () -&gt; assertThat(result.getJob()).isEqualTo(&quot;programmer&quot;),</span><br><span class="line">                () -&gt; assertThat(result.getPhoneNumber()).isEqualTo(&quot;010-1111-1111&quot;),</span><br><span class="line">                () -&gt; assertThat(result.getBirthday()).isEqualTo(Birthday.of(LocalDate.now()))</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    void modifyPerson() throws Exception &#123;</span><br><span class="line">        PersonDto personDto &#x3D; PersonDto.of(&quot;martin&quot;,</span><br><span class="line">                &quot;programming&quot;,</span><br><span class="line">                &quot;판교&quot;,</span><br><span class="line">                &quot;programmer&quot;,</span><br><span class="line">                &quot;010-1111-1111&quot;,</span><br><span class="line">                LocalDate.now());</span><br><span class="line"></span><br><span class="line">        mockMvc.perform(MockMvcRequestBuilders.put(&quot;&#x2F;api&#x2F;person&#x2F;1&quot;)</span><br><span class="line">                .contentType(MediaType.APPLICATION_JSON)</span><br><span class="line">                .content(toJsonString(personDto)))</span><br><span class="line">                .andDo(print())</span><br><span class="line">                .andExpect(status().isOk());</span><br><span class="line"></span><br><span class="line">        Person result &#x3D; personRepository.findById(1L).get();</span><br><span class="line"></span><br><span class="line">        assertAll(</span><br><span class="line">                () -&gt; assertThat(result.getName()).isEqualTo(&quot;martin&quot;),</span><br><span class="line">                () -&gt; assertThat(result.getHobby()).isEqualTo(&quot;programming&quot;),</span><br><span class="line">                () -&gt; assertThat(result.getAddress()).isEqualTo(&quot;판교&quot;),</span><br><span class="line">                () -&gt; assertThat(result.getJob()).isEqualTo(&quot;programmer&quot;),</span><br><span class="line">                () -&gt; assertThat(result.getPhoneNumber()).isEqualTo(&quot;010-1111-1111&quot;),</span><br><span class="line">                () -&gt; assertThat(result.getBirthday()).isEqualTo(Birthday.of(LocalDate.now()))</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    void modifyPersonIfNameIsDifferent() throws Exception &#123;</span><br><span class="line">        PersonDto personDto &#x3D; PersonDto.of(&quot;martin&quot;,</span><br><span class="line">                &quot;programming&quot;,</span><br><span class="line">                &quot;판교&quot;,</span><br><span class="line">                &quot;programmer&quot;,</span><br><span class="line">                &quot;010-1111-1111&quot;,</span><br><span class="line">                LocalDate.now());</span><br><span class="line"></span><br><span class="line">        assertThrows(NestedServletException.class, () -&gt;</span><br><span class="line">                mockMvc.perform(MockMvcRequestBuilders.put(&quot;&#x2F;api&#x2F;person&#x2F;1&quot;)</span><br><span class="line">                    .contentType(MediaType.APPLICATION_JSON)</span><br><span class="line">                    .content(toJsonString(personDto)))</span><br><span class="line">                .andDo(print())</span><br><span class="line">                .andExpect(status().isOk()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    void modifyName() throws Exception &#123;</span><br><span class="line">        mockMvc.perform(MockMvcRequestBuilders.patch(&quot;&#x2F;api&#x2F;person&#x2F;1&quot;)</span><br><span class="line">                .param(&quot;name&quot;,&quot;martinModified&quot;))</span><br><span class="line">                .andDo(print())</span><br><span class="line">                .andExpect(status().isOk());</span><br><span class="line"></span><br><span class="line">        assertThat(personRepository.findById(1L).get().getName()).isEqualTo(&quot;martinModified&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    void deletePerson() throws Exception &#123;</span><br><span class="line">        mockMvc.perform(MockMvcRequestBuilders.delete(&quot;&#x2F;api&#x2F;person&#x2F;1&quot;))</span><br><span class="line">                .andDo(print())</span><br><span class="line">                .andExpect(status().isOk());</span><br><span class="line"></span><br><span class="line">        assertTrue(personRepository.findPeopleDeleted().stream().anyMatch(person -&gt; person.getId().equals(1L)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;PersonDto를 json으로 변환해주는 메서드를 생성하여 사용한다.  </span><br><span class="line">    private String toJsonString(PersonDto personDto) throws JsonProcessingException &#123;</span><br><span class="line">        return objectMapper.writeValueAsString(personDto);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Study</category>
        <category>Spring Boot Project</category>
      </categories>
      <tags>
        <tag>spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title>30. Exception Handling</title>
    <url>/2020/08/12/hexo_springboot_2_30/</url>
    <content><![CDATA[<h1 id="스프링-부트-프로젝트"><a href="#스프링-부트-프로젝트" class="headerlink" title="스프링 부트 프로젝트"></a>스프링 부트 프로젝트</h1><h3 id="지인-정보-관리-시스템-만들기"><a href="#지인-정보-관리-시스템-만들기" class="headerlink" title="지인 정보 관리 시스템 만들기"></a>지인 정보 관리 시스템 만들기</h3><h4 id="30-Exception-Handling"><a href="#30-Exception-Handling" class="headerlink" title="30. Exception Handling"></a>30. Exception Handling</h4><p>Custom Exception 활용하기<br>프로젝트 내에서 의도적으로 발생시키는 예외는 별도의 Custom Exception으로 처리하는것이 좋다.  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">public class PersonNotFoundException extends RuntimeException&#123;</span><br><span class="line"></span><br><span class="line">    private static final String MESSAGE &#x3D; &quot;Person Entity가 존재하지 않습니다.&quot;;</span><br><span class="line">    public PersonNotFoundException() &#123;</span><br><span class="line">        super(MESSAGE);</span><br><span class="line">        log.error(MESSAGE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">public class RenameNotPermittedException extends RuntimeException&#123;</span><br><span class="line">    private static final String MESSAGE &#x3D; &quot;이름 변경이 허용되지 않았습니다.&quot;;</span><br><span class="line">    public RenameNotPermittedException() &#123;</span><br><span class="line">        super(MESSAGE);</span><br><span class="line">        log.error(MESSAGE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Exception의 정보 전달을 위한 DTO 생성</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Data</span><br><span class="line">@AllArgsConstructor(access &#x3D; AccessLevel.PRIVATE)</span><br><span class="line">public class ErrorResponse &#123;</span><br><span class="line">    private int code;</span><br><span class="line">    private String message;</span><br><span class="line"></span><br><span class="line">    public static ErrorResponse of(HttpStatus httpStatus, String message) &#123;</span><br><span class="line">        return new ErrorResponse(httpStatus.value(), message);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    public static ErrorResponse of(HttpStatus httpStatus, FieldError fieldError) &#123;</span><br><span class="line">        if (fieldError &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return new ErrorResponse(httpStatus.value(), &quot;invalid params&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return new ErrorResponse(httpStatus.value(), fieldError.getDefaultMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>Custom Exception이 아니더라도 응답은 일관성있게 나가는 것이 좋다.<br>=&gt; Exception Handler 사용<br>특정 클래스에서만 사용하지 않고 API 전역적으로 사용하려고 한다.<br>=&gt; RestControllerAdvice</p>
<p>서버의 오류메세지를 클라이언트로 보내는것은 보안적으로 위험하다.<br>=&gt; 실제 error 메세지 대신 일반적인 문구를 사용</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">@RestControllerAdvice</span><br><span class="line">public class GlobalExceptionHandler &#123;</span><br><span class="line"></span><br><span class="line">    @ExceptionHandler(RenameNotPermittedException.class)</span><br><span class="line">    @ResponseStatus(HttpStatus.BAD_REQUEST)</span><br><span class="line">    public ErrorResponse handleRenameNotPermittedException(RenameNotPermittedException ex) &#123;</span><br><span class="line">        return ErrorResponse.of(HttpStatus.BAD_REQUEST,ex.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @ExceptionHandler(PersonNotFoundException.class)</span><br><span class="line">    @ResponseStatus(HttpStatus.BAD_REQUEST)</span><br><span class="line">    public ErrorResponse handlePersonNotFoundException(PersonNotFoundException ex) &#123;</span><br><span class="line">        return ErrorResponse.of(HttpStatus.BAD_REQUEST,ex.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @ExceptionHandler(MethodArgumentNotValidException.class)</span><br><span class="line">    @ResponseStatus(HttpStatus.BAD_REQUEST)</span><br><span class="line">    public ErrorResponse handleMethodArgumentNotValidException(MethodArgumentNotValidException ex) &#123;</span><br><span class="line">        return ErrorResponse.of(HttpStatus.BAD_REQUEST,ex.getBindingResult().getFieldError());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @ExceptionHandler(RuntimeException.class)</span><br><span class="line">    @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)</span><br><span class="line">    public ErrorResponse handleRuntimeException(RuntimeException ex) &#123;</span><br><span class="line">        log.error(&quot;서버 오류 : &#123;&#125;&quot;, ex.getMessage(), ex);</span><br><span class="line">        return ErrorResponse.of(HttpStatus.INTERNAL_SERVER_ERROR,&quot;알 수 없는 서버 오류가 발생하였습니다.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Parameter Validator</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class PersonDto &#123;</span><br><span class="line">    &#x2F;&#x2F;null, empty, blank 예외처리, 디폴트 메시지 설정</span><br><span class="line">    @NotBlank(message &#x3D; &quot;이름은 필수값입니다.&quot;)</span><br><span class="line">    private String name;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Study</category>
        <category>Spring Boot Project</category>
      </categories>
      <tags>
        <tag>spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title>34. getAll() 추가 및 Paging</title>
    <url>/2020/08/12/hexo_springboot_2_34/</url>
    <content><![CDATA[<h1 id="스프링-부트-프로젝트"><a href="#스프링-부트-프로젝트" class="headerlink" title="스프링 부트 프로젝트"></a>스프링 부트 프로젝트</h1><h3 id="지인-정보-관리-시스템-만들기"><a href="#지인-정보-관리-시스템-만들기" class="headerlink" title="지인 정보 관리 시스템 만들기"></a>지인 정보 관리 시스템 만들기</h3><h4 id="34-getAll-추가-및-Paging"><a href="#34-getAll-추가-및-Paging" class="headerlink" title="34. getAll() 추가 및 Paging"></a>34. getAll() 추가 및 Paging</h4><p>Controller</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@GetMapping()</span><br><span class="line">public Page&lt;Person&gt; getAll(@PageableDefault Pageable pageable) &#123;</span><br><span class="line">    return personService.getAll(pageable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Service</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public Page&lt;Person&gt; getAll(Pageable pageable) &#123;</span><br><span class="line">    return personRepository.findAll(pageable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Controller Test</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">void getAll() throws Exception &#123;</span><br><span class="line">    mockMvc.perform(</span><br><span class="line">            MockMvcRequestBuilders.get(&quot;&#x2F;api&#x2F;person&quot;)</span><br><span class="line">                &#x2F;&#x2F;default 대신 사용</span><br><span class="line">                .param(&quot;page&quot;,&quot;1&quot;) &#x2F;&#x2F;2번째 페이지</span><br><span class="line">                .param(&quot;size&quot;,&quot;2&quot;)) &#x2F;&#x2F;페이지 별 사이즈</span><br><span class="line">            .andExpect(status().isOk())</span><br><span class="line">            .andExpect(jsonPath(&quot;$.totalPages&quot;).value(3)) &#x2F;&#x2F;페이지 수</span><br><span class="line">            .andExpect(jsonPath(&quot;$.totalElements&quot;).value(6)) &#x2F;&#x2F;총 요소 수</span><br><span class="line">            .andExpect(jsonPath(&quot;$.numberOfElements&quot;).value(2)) &#x2F;&#x2F;페이지의 요소 수 </span><br><span class="line">            .andExpect(jsonPath(&quot;$.content.[0].name&quot;).value(&quot;dennis&quot;))</span><br><span class="line">            .andExpect(jsonPath(&quot;$.content.[1].name&quot;).value(&quot;sophia&quot;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Study</category>
        <category>Spring Boot Project</category>
      </categories>
      <tags>
        <tag>spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title>sample</title>
    <url>/2020/08/12/sample/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Resource / Validation</title>
    <url>/2020/08/15/hexo_spring_project_5/</url>
    <content><![CDATA[<h2 id="Resource-Validation"><a href="#Resource-Validation" class="headerlink" title="Resource / Validation"></a>Resource / Validation</h2><h4 id="Resource-추상화"><a href="#Resource-추상화" class="headerlink" title="Resource 추상화"></a>Resource 추상화</h4><p>Spring에서는 java.net.URL을 추상화한 Resource 가 있다.  </p>
<p>추상화한 이유…<br>Resource는 classpath 기준으로 읽어올 수 있다.<br>ServletContext를 기준으로 읽어올 수 없다.<br>구현이 복잡하고 편의성 메소드가 부족하다.  </p>
<p>구현체…<br>UrlResource<br>ClassPathResource (classpath: 접두어 지원)<br>FileSystemResource<br>ServletContextResource : 웹 어플리케이션 루트에서 상대 경로로 리소스를 찾는다.  </p>
<p>Resource의 타입은 ApplicationContext의 타입에 따라 결정된다.<br>ex)</p>
<ul>
<li>ClassPathXmlApplicationContext -&gt; ClassPathResource</li>
<li>FileSystemXmlApplicationContext -&gt; FileSystemResource</li>
<li>WebXmlApplicationContext -&gt; ServletContextResource</li>
</ul>
<p>ApplicationContext 타입과 무관하게 Resource 타입을 정하려면<br>java.net.URL 접두어를 사용한다. (classpath:, file:)</p>
<p>접두어가 있으면 가시성이 좋아지기 때문에 접두어를 쓰는 것이 좋다.<br>(ApplicationContext 타입을 모르면 복잡해지기 때문에)</p>
<h4 id="Validation-추상화"><a href="#Validation-추상화" class="headerlink" title="Validation 추상화"></a>Validation 추상화</h4><p>애플리케이션에서 사용하는 객체들을 검증할때 사용하는 인터페이스.  </p>
<p>Validation 인터페이스는 두개의 메소드를 구현해야 한다.<br>boolean supports(Class clazz) : 검증할 Class가 Validator가 지원하는지 확인하는 메소드<br>void validate(Object target, Errors errors) : 실제 검증 로직을 구현 (ValidationUtils를 사용)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class EventValidator implements Validator &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean supports(Class&lt;?&gt; clazz) &#123;</span><br><span class="line">        return Event.class.equals(clazz);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void validate(Object target, Errors errors) &#123;</span><br><span class="line">        ValidationUtils.rejectIfEmptyOrWhitespace</span><br><span class="line">            (errors, &quot;title&quot;, &quot;NotEmpty&quot;, &quot;Empty title is not allowed.&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>한편, 스프링 부트에서는 간단한 검증은 Validator를 따로 작성하지 않아도<br>LocalValidatorFactoryBean이 빈으로 등록되어 있다.</p>
]]></content>
      <categories>
        <category>Study</category>
        <category>Spring Framework</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>데이터 바인딩</title>
    <url>/2020/08/15/hexo_spring_project_6/</url>
    <content><![CDATA[<h2 id="데이터-바인딩"><a href="#데이터-바인딩" class="headerlink" title="데이터 바인딩"></a>데이터 바인딩</h2><p>프로퍼티 값을 타겟 객체에 설정하는 기능.<br>즉, 사용자 입력값(문자열)을 객체가 가지고 있는 int, Date, Boolean 또는 도메인 타입 등으로 변환해 넣어주는 기능이다.  </p>
<h4 id="PropertyEditor"><a href="#PropertyEditor" class="headerlink" title="PropertyEditor"></a>PropertyEditor</h4><p>DataBinder가 변환 작업에 사용하는 인터페이스.  </p>
<p>문자열을 객체로 변환하는 Editor 만들기</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class EventEditor extends PropertyEditorSupport &#123;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public String setAsText(String text) throws IllegalArgumentException &#123;</span><br><span class="line">        setValue(new Event(Integer.parseInt(text)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PropertyEditorSupport는 PropertyEditor의 구현체이다.<br>참고로 PropertyEditor는 쓰레드 세이프 하지 않기 때문에 절대로 싱글톤 빈으로 등록하지 않는다.<br>그리고 Object / String 간 변환만 지원한다.<br>사용할 때는 @InitBinder로 사용할 PropertyEditor를 등록할 수 있다.  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@InitBinder</span><br><span class="line">public void init(WebDataBinder webDataBinder) &#123;</span><br><span class="line">    webDataBinder.registerCustomEditor(Event.class, new EventEditor());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Converter와-Formatter"><a href="#Converter와-Formatter" class="headerlink" title="Converter와 Formatter"></a>Converter와 Formatter</h4><h5 id="Converter"><a href="#Converter" class="headerlink" title="Converter"></a>Converter</h5><p>Source 타입을 Target 타입으로 변환, 상태 정보가 없기 때문에(stateless) 쓰레드 세이프하다.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class StringToEventConverter implements Converter&lt;String, Event&gt; &#123;</span><br><span class="line">        </span><br><span class="line">    @Override</span><br><span class="line">    public Event convert(String source) &#123;</span><br><span class="line">        return new Event(Integer.parseInt(source));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>WebMvcConfigurer 에서 설정, ConverterRegistry에 등록하여 사용한다.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class WebConfig implements WebMvcConfigurer &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void addFormatters(FormatterRegistry registry) &#123;</span><br><span class="line">        registry.addConverter(new StringToEventConverter());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Formatter"><a href="#Formatter" class="headerlink" title="Formatter"></a>Formatter</h5><p>보다 Web에 특화된 인터페이스<br>String과 Object 변환, Locale에 따른 i18n 기능.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class EventFormatter implements Formatter&lt;Event&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Event parse(String text, Locale locale) throws ParseException &#123;</span><br><span class="line">        return new Event(Integer.parseInt(text));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public Event print(Event object, Locale locale) &#123;</span><br><span class="line">        return object.getId().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>WebMvcConfigurer 에서 설정, FormatterRegistry에 등록하여 사용한다.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class WebConfig implements WebMvcConfigurer &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void addFormatters(FormatterRegistry registry) &#123;</span><br><span class="line">        registry.addFormatter(new EventFormatter());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="ConversionService"><a href="#ConversionService" class="headerlink" title="ConversionService"></a>ConversionService</h5><p>Converter/Formatter는 DataBinder 대신에 ConversionService에서 쓰레드 세이프하게 실제 변환 작업이 수행된다.<br>스프링 MVC, 빈(value) 설정, SpEL에서 사용한다.<br>DefaultFormattingConversionService<br> : ConversionService와 FormatterRegistry를 구현하고 그 외 여러 기본 컨버터와 포매터가 등록되어 있다.  </p>
<p>conversionService를 toString()으로 확인하면 등록된 모든 Converter, Formatter를 확인할 수 있다.  </p>
<p>참고로 스프링 부트에서는 DefaultFormattingConversionService를 상속받는 WebConversionService가 빈으로 등록되고<br>WebMvcConfigurer 설정 없이 Formatter와 Converter 빈을 찾아서 자동으로 등록해준다.  </p>
]]></content>
      <categories>
        <category>Study</category>
        <category>Spring Framework</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>SpEL (스프링 Expression Language)</title>
    <url>/2020/08/15/hexo_spring_project_7/</url>
    <content><![CDATA[<h2 id="SpEL-스프링-Expression-Language"><a href="#SpEL-스프링-Expression-Language" class="headerlink" title="SpEL (스프링 Expression Language)"></a>SpEL (스프링 Expression Language)</h2><h4 id="스프링-EL이란-upto-spring3-0"><a href="#스프링-EL이란-upto-spring3-0" class="headerlink" title="스프링 EL이란? (upto spring3.0)"></a>스프링 EL이란? (upto spring3.0)</h4><ol>
<li>객체 그래프를 조회하고 조작하는 기능 제공</li>
<li>Unified EL과 비슷하지만, 메소드 호출이나 문자열 템플릿 기능을 지원한다.</li>
<li>OGNL, MVEL, JBoss EL 등 여러 EL이 있지만 SpEL은 모든 스프링 프로젝트 전반에 걸쳐 사용하도록 만들어져있다.</li>
</ol>
<h4 id="문법"><a href="#문법" class="headerlink" title="문법"></a>문법</h4><p>#{“표현식”}  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Value(&quot;#&#123;100 + 100&#125;&quot;)</span><br><span class="line">int value;</span><br></pre></td></tr></table></figure>
<p>${“프로퍼티”}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Value(&quot;$&#123;my.value&#125;&quot;)</span><br><span class="line">int value;</span><br></pre></td></tr></table></figure>
<p>참고로 표현식 내부에 프로퍼티를 사용할 수 있지만 반대는 안된다.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Value(&quot;#&#123;$&#123;my.value&#125; eq 100&#125;&quot;)</span><br><span class="line">boolean isValue100;</span><br></pre></td></tr></table></figure>
<p>Sample Bean 참조</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Value(#&#123;sample.data&#125;)</span><br><span class="line">int value;</span><br></pre></td></tr></table></figure>

<p>SpEL의 해석은 SpelExpressionParser에 의해 이루어진다.  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ExpressionParser parser &#x3D; new SpelExpressionParser();</span><br><span class="line">Expression expression &#x3D; parser.parseExpression(&quot;2 + 100&quot;);</span><br><span class="line">Integer value &#x3D; expression.getValue(Integer.class);</span><br></pre></td></tr></table></figure>

<h4 id="SpEL이-사용되는-곳"><a href="#SpEL이-사용되는-곳" class="headerlink" title="SpEL이 사용되는 곳"></a>SpEL이 사용되는 곳</h4><p>@Value<br>@ConditionalOnExpression (EL을 이용하여 선별적으로 Bean 등록)<br>스프링 시큐리티<br>스프링 데이터 @Query<br>Thymeleaf  </p>
]]></content>
      <categories>
        <category>Study</category>
        <category>Spring Framework</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Null-safety</title>
    <url>/2020/08/15/hexo_spring_project_8/</url>
    <content><![CDATA[<h2 id="Null-safety"><a href="#Null-safety" class="headerlink" title="Null-safety"></a>Null-safety</h2><p>Spring 5부터 추가된 Null 관련 어노테이션.<br>org.springframework.lang</p>
<p>컴파일 시점에 최대한 NullPointerException을 방지할 수 있다.  </p>
<p>@NonNull : IntelliJ에서 null이면 미리 경고받을 수 있다.  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@NonNull &#x2F;&#x2F;return이 Null인지 확인</span><br><span class="line">public String greeting(@NonNull String name) &#123; &#x2F;&#x2F;매개변수가 Null인지 확인</span><br><span class="line">    return &quot;Hi! &quot;+name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>@Nullable  </p>
<p>패키지 레벨 설정 (설정된 패키지 이하로 모두 설정)<br>@NonNullApi<br>@NonNullFields   </p>
]]></content>
      <categories>
        <category>Study</category>
        <category>Spring Framework</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring MVC 동작 원리</title>
    <url>/2020/08/27/hexo_spring_project_9/</url>
    <content><![CDATA[<img src="/img/Spring-MVC.png" class="img_class" width="430" height="270" title="spring-mvc">
<h2 id="Spring-MVC-동작-원리"><a href="#Spring-MVC-동작-원리" class="headerlink" title="Spring MVC 동작 원리"></a>Spring MVC 동작 원리</h2><h3 id="Spring-웹-MVC"><a href="#Spring-웹-MVC" class="headerlink" title="Spring 웹 MVC"></a>Spring 웹 MVC</h3><p>서블릿 기반의 웹 애플리케이션에서 MVC 패턴을 사용하기 쉽게끔 도와주는 프레임워크  </p>
<p>M : 모델, 평범한 자바 POJO 객체(도메인 객체 또는 DTO), 전달하거나 전달받을 데이터를 담은 객체<br>V : 뷰, 데이터를 보여주는 역할, HTML, JSP, 타임리프, …<br>C : 컨트롤러, 사용자의 입력을 받아 모델의 데이터를 변경하거나 뷰에 전달하는 역할  </p>
<h4 id="MVC-패턴의-장점"><a href="#MVC-패턴의-장점" class="headerlink" title="MVC 패턴의 장점"></a>MVC 패턴의 장점</h4><ul>
<li>동시 다발적 개발 : 백엔드와 프론트엔드에서 독립적으로 개발할 수 있다.  </li>
<li>높은 결합도 : 관련있는 기능을 하나의 컨트롤러로 묶거나 뷰를 그룹화 할 수 있다.  </li>
<li>낮의 의존도 : 모델, 뷰, 컨트롤러는 서로 독립적이다.  </li>
<li>개발 용이성 : 책임이 구분되어 있어서 코드 수정이 편리하다.  </li>
<li>한 모델에 대한 여러 형태의 뷰를 가질 수 있다.  </li>
</ul>
<h4 id="MVC-패턴의-단점"><a href="#MVC-패턴의-단점" class="headerlink" title="MVC 패턴의 단점"></a>MVC 패턴의 단점</h4><ul>
<li>코드 네비게이션의 복잡함</li>
<li>코드 일관성 유지에 노력이 필요하다. </li>
<li>높은 학습 곡선</li>
</ul>
<h3 id="서블릿-애플리케이션"><a href="#서블릿-애플리케이션" class="headerlink" title="서블릿 애플리케이션"></a>서블릿 애플리케이션</h3><h4 id="서블릿-Servlet"><a href="#서블릿-Servlet" class="headerlink" title="서블릿(Servlet)"></a>서블릿(Servlet)</h4><p>JAVA EE 웹 애플리케이션 개발용 스팩과 API 제공한다.<br>요청 당 쓰레드를 사용한다. (요청 당 프로세스에 비해 빠르다.)<br>JAVA 기반이기 때문에 플랫폼에 대해 독립적이고 이식성이 좋다. 또한 JAVA가 제공하는 보안 기술을 사용할 수 있다.  </p>
<p>서블릿 클래스 생성</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class SimpleServlet extends HttpServlet &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;</span><br><span class="line">        PrintWriter writer &#x3D; resp.getWriter();</span><br><span class="line">        writer.println(&quot;Hello World!!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>기본적으로 서블릿 애플리케이션의 실행 및 종료는 서블릿 컨테이너에 의해 이루어진다. </p>
<p>서블릿 엔진 또는 서블릿 컨테이너의 역할(톰캣, 제티, 언더토, …)<br> : 서블릿 라이프 사이클 관리, 세션 관리, 네트워크 서비스, MIME기반 메시지 인코딩 디코딩, …</p>
<p>서블릿 라이프 사이클 (서블릿 컨테이너가 관리)</p>
<ol>
<li>서블릿 인스턴스(HttpServlet을 상속받은 클래스)의 init() 메소드 호출&amp;초기화, 최초 요청 후부터 이 과정을 생략</li>
<li>클라이언트로부터의 요청 처리, 각 요청마다 별도의 쓰레드로 처리되며 서블릿 인스턴스의 service() 메소드 호출<br>이 과정에서 보통 Http Method에 따라 doGet(), doPost() 등의 메소드를 구현하여 처리를 위임한다.  </li>
<li>서블릿 컨테이너의 판단에 따라 해당 서블릿을 메모리에서 내려야 할 시점에 destroy() 호출  </li>
</ol>
<p>서블릿은 web.xml에 등록된다.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;servlet&gt;</span><br><span class="line">    &lt;servlet-name&gt;simple&lt;&#x2F;servlet-name&gt;</span><br><span class="line">    &lt;servlet-class&gt;kr.co.myapp.web.SimpleServlet&lt;&#x2F;servlet-class&gt;</span><br><span class="line">&lt;&#x2F;servlet&gt;</span><br><span class="line">&lt;servlet-mapping&gt;</span><br><span class="line">    &lt;servlet-name&gt;simple&lt;&#x2F;servlet-name&gt;</span><br><span class="line">    &lt;url-pattern&gt;&#x2F;simple&lt;&#x2F;url-pattern&gt;</span><br><span class="line">&lt;&#x2F;servlet-mapping&gt;</span><br></pre></td></tr></table></figure>


<h4 id="서블릿-리스너와-서블릿-필터"><a href="#서블릿-리스너와-서블릿-필터" class="headerlink" title="서블릿 리스너와 서블릿 필터"></a>서블릿 리스너와 서블릿 필터</h4><ul>
<li>서블릿 리스너<br>: 웹 애플리케이션에서 발생하는 주요 이벤트를 감지하고 각 이벤트에 특별한 작업이 필요한 경우 사용할 수 있다.<ul>
<li>서블릿 컨텍스트 수준의 이벤트<br>: 컨텍스트 라이프 사이클, 애트리뷰트 변경 이벤트</li>
<li>세션 수준의 이벤트<br>: 세션 라이프 사이클, 애트리뷰트 변경 이벤트</li>
</ul>
</li>
</ul>
<p>서블릿 컨텍스트 : 서블릿들이 공용으로 사용할 자원의 저장소  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MyListener implements ServletContextListener &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void contextInitialized(ServletContextEvent sce) &#123;</span><br><span class="line">        System.out.println(&quot;Context Initialized&quot;);</span><br><span class="line">        sce.getServletContext().setAttribute(&quot;name&quot;,&quot;jilee&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void contextDestroyed(ServletContextEvent sce) &#123;</span><br><span class="line">        System.out.println(&quot;Context Destroied&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>서블릿 필터<br>: 들어온 요청을 서블릿으로 보내기 전, 또는 서블릿이 작성한 응답을 클라이언트로 보내기 전에 특별한 작업이 필요한 경우 사용할 수 있다.<br>서블릿 필터는 체인 형태의 구조를 가지고 있다.  </li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MyFilter implements Filter &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void init(FilterConfig filterConfig) throws ServletException &#123;</span><br><span class="line">        System.out.println(&quot;Filter init&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;</span><br><span class="line">        System.out.println(&quot;Filter&quot;);</span><br><span class="line">        &#x2F;&#x2F;doFilter에서는 Chainning을 해줘야한다.</span><br><span class="line">        filterChain.doFilter(servletRequest,servletResponse);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void destroy() &#123;</span><br><span class="line">        System.out.println(&quot;Filter destroy&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>리스너와 필터도 서블릿과 마찬가지로 web.xml에 등록되어야 한다.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;listener&gt;</span><br><span class="line">    &lt;listener-class&gt;kr.co.myapp.web.MyListener&lt;&#x2F;listener-class&gt;</span><br><span class="line">&lt;&#x2F;listener&gt;</span><br><span class="line"></span><br><span class="line">&lt;filter&gt;</span><br><span class="line">    &lt;filter-name&gt;myFilter&lt;&#x2F;filter-name&gt;</span><br><span class="line">    &lt;filter-class&gt;kr.co.myapp.web.MyFilter&lt;&#x2F;filter-class&gt;</span><br><span class="line">&lt;&#x2F;filter&gt;</span><br><span class="line"></span><br><span class="line">&lt;filter-mapping&gt;</span><br><span class="line">    &lt;filter-name&gt;myFilter&lt;&#x2F;filter-name&gt;</span><br><span class="line">    &lt;servlet-name&gt;simple&lt;&#x2F;servlet-name&gt;</span><br><span class="line">&lt;&#x2F;filter-mapping&gt;</span><br></pre></td></tr></table></figure>

<h3 id="서블릿-애플리케이션에서-Spring-연동"><a href="#서블릿-애플리케이션에서-Spring-연동" class="headerlink" title="서블릿 애플리케이션에서 Spring 연동"></a>서블릿 애플리케이션에서 Spring 연동</h3><h4 id="IoC-컨테이너를-활용하는-방법"><a href="#IoC-컨테이너를-활용하는-방법" class="headerlink" title="IoC 컨테이너를 활용하는 방법"></a>IoC 컨테이너를 활용하는 방법</h4><p>Spring 웹 MVC 의존성 추가</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-webmvc&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.2.7.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<p>ContextLoaderListener<br> : Spring이 제공하는 서블릿 리스너, ApplicationContext를 생성하고 서블릿 컨텍스트에 등록해준다.<br> 서블릿 컨텍스트의 라이프 사이클에 맞춰서 Spring이 제공하는 ApplicationContext를 사용할 수 있도록 연동해서 서블릿이 ApplicationContext를 사용할 수 있도록 해준다.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;listener&gt;</span><br><span class="line">    &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;&#x2F;listener-class&gt;</span><br><span class="line">&lt;&#x2F;listener&gt;</span><br></pre></td></tr></table></figure>

<p>ApplicationContext가 있어야 하기 때문에 xml 또는 java를 이용한 Spring 설정 파일이 필요하다.  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;생성할 ApplicationContext 타입 설정</span><br><span class="line">&lt;context-param&gt;</span><br><span class="line">    &lt;param-name&gt;contextClass&lt;&#x2F;param-name&gt;</span><br><span class="line">    &lt;param-value&gt;org.springframework.web.context.support.AnnotationConfigWebApplicationContext&lt;&#x2F;param-value&gt;</span><br><span class="line">&lt;&#x2F;context-param&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;참조할 ApplicationContext java 설정 파일 등록</span><br><span class="line">&lt;context-param&gt;</span><br><span class="line">    &lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt;</span><br><span class="line">    &lt;param-value&gt;kr.co.myapp.web.AppConfig&lt;&#x2F;param-value&gt;</span><br><span class="line">&lt;&#x2F;context-param&gt;</span><br></pre></td></tr></table></figure>


<h4 id="DispatcherServlet을-활용하는-방법"><a href="#DispatcherServlet을-활용하는-방법" class="headerlink" title="DispatcherServlet을 활용하는 방법"></a>DispatcherServlet을 활용하는 방법</h4><p>DispatcherServlet은 스프링이 제공하는 스프링 MVC의 핵심적인 클래스이며 Front Controller 역할을 한다.  </p>
<p>Front Controller : 다른 Controller로 요청을 Dispatch 해주는 역할을 하는 Controller</p>
<p>DispatcherServlet의 특징은 ApplicationContext를 추가로 생성하며 계층구조를 가지게 되는데,<br>이때 기존에 서블릿 컨택스트에 있던 ApplicationContext는 “Root WebApplicationContext”,<br>DispatcherServlet으로 인해 추가로 생성되어 Root WebApplication을 부모로 가지는 ApplicationContext를 “Servlet WebApplicationContext” 라고 한다.  </p>
<p>Root WebApplicationContext : 다른 서블릿들도 공용으로 사용할 수 있는 부분, 웹과 관련된 빈들을 등록하지 않는다.<br>주로 Serivce / Repository가 등록됨.</p>
<p>Servlet WebApplicationContext : 해당 DispatcherServlet에서만 한정적으로 사용할 수 있는 부분, 웹 관련 빈들이 등록된다.<br>주로 Controller / View resolver 가 등록됨 </p>
<p>DispatcherServlet 등록, Servlet WebApplicationContext용 Config 파일이 필요하다.<br>(Root 용으로는 웹관련 빈이 제외하도록하고 DispatcherServlet 용으로는 웹관련 빈이 등록되게 하는 등 작업필요)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;servlet&gt;</span><br><span class="line">    &lt;servlet-name&gt;app&lt;&#x2F;servlet-name&gt;</span><br><span class="line">    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;&#x2F;servlet-class&gt;</span><br><span class="line">    &lt;init-param&gt;</span><br><span class="line">        &lt;param-name&gt;contextClass&lt;&#x2F;param-name&gt;</span><br><span class="line">        &lt;param-value&gt;org.springframework.web.context.support.AnnotationConfigWebApplicationContext&lt;&#x2F;param-value&gt;</span><br><span class="line">        &lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt;</span><br><span class="line">        &lt;param-value&gt;kr.co.myapp.web.WebConfig&lt;&#x2F;param-value&gt;</span><br><span class="line">    &lt;&#x2F;init-param&gt;</span><br><span class="line">&lt;&#x2F;servlet&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; &#x2F;app밑으로의 모든 요청은 DispatcherServlet을 통하도록</span><br><span class="line">&lt;servlet-mapping&gt;</span><br><span class="line">    &lt;servlet-name&gt;app&lt;&#x2F;servlet-name&gt;</span><br><span class="line">    &lt;url-pattern&gt;&#x2F;app&#x2F;*&lt;&#x2F;url-pattern&gt;</span><br><span class="line">&lt;&#x2F;servlet-mapping&gt;</span><br></pre></td></tr></table></figure>

<p>또는 WebApplicationInitializer 인터페이스를 통해 Java 코드로 등록할 수 있다.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class WebApplication implements WebApplicationInitializer &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onStartup(ServletContext servletContext) throws ServletException &#123;</span><br><span class="line">        AnnotationConfigWebApplicationContext context &#x3D; new AnnotationConfigWebApplicationContext();</span><br><span class="line">        context.register(WebConfig.class);</span><br><span class="line">        context.refresh();</span><br><span class="line"></span><br><span class="line">        DispatcherServlet dispatcherServlet &#x3D; new DispatcherServlet(context);</span><br><span class="line">        ServletRegistration.Dynamic app &#x3D; servletContext.addServlet(&quot;app&quot;, dispatcherServlet);</span><br><span class="line">        app.addMapping(&quot;&#x2F;app&#x2F;*&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DispatcherServlet을 하나만 사용할 경우는 계층구조를 하지 않아도 된다.<br>(Servlet WebApplicationContext에 모든 빈을 등록하면 된다.)</p>
<p>참고로 스프링 부트에서는 구조가 완전히 다른데,<br>보통 서블릿 컨테이너에 등록되는 웹 애플리케이션에 Spring을 연동하는 반면,<br>스프링 부트는 스프링 부트 자바 애플리케이션이 먼저 뜨고 그 안에 내장되어 있는 톰캣이 뜨게된다.  </p>
<h3 id="DispatcherServlet-동작-원리"><a href="#DispatcherServlet-동작-원리" class="headerlink" title="DispatcherServlet 동작 원리"></a>DispatcherServlet 동작 원리</h3><h4 id="DispatcherServlet-초기화"><a href="#DispatcherServlet-초기화" class="headerlink" title="DispatcherServlet 초기화"></a>DispatcherServlet 초기화</h4><ul>
<li>특별한 타입의 빈들을 찾거나 기본 전력에 해당하는 빈들을 등록한다.</li>
<li>HandlerMapping : 핸들러를 찾아주는 인터페이스</li>
<li>HandlerAdapter : 핸들러를 실행하는 인터페이스</li>
<li>HandlerExceptionResolver : 예외 처리 인터페이스</li>
<li>ViewResolver : 뷰를 찾아주는 인터페이스</li>
<li>…  </li>
</ul>
<h4 id="DispatcherServlet-동작-순서"><a href="#DispatcherServlet-동작-순서" class="headerlink" title="DispatcherServlet 동작 순서"></a>DispatcherServlet 동작 순서</h4><ol>
<li>요청 분석 (Locale, 테마, 멀티파트 등)</li>
<li>HandlerMapping에 위임하여 요청을 처리할 핸들러를 찾는다.<br>(기본적인 HandlerMapping : BeanNameUrlHandlerMapping, RequestMappingHandlerMapping)</li>
<li>찾아진 핸들러를 실행할 수 있는 HandlerAdapter를 찾는다.</li>
<li>찾아낸 HandlerAdapter를 이용해서 핸들러의 응답을 처리한다.<ul>
<li>핸들러의 리턴값을 보고 어떻게 처리할지 판단한다.<ul>
<li>리턴값의 뷰 이름에 해당하는 뷰를 찾아서(ViewResolver) 모델 데이터를 랜더링한다.</li>
<li>@ResponseBody가 있다면 Converter를 사용해서 응답 본문을 만들고(리턴 String을 본문에 넣는 등) ModelAndView는 null이 된다.</li>
</ul>
</li>
</ul>
</li>
<li>만약 예외가 발생했다면 HandlerExceptionResolver에 요청 처리를 위임한다. </li>
<li>최종적으로 응답을 보낸다.</li>
</ol>
<h4 id="커스텀-ViewResolver"><a href="#커스텀-ViewResolver" class="headerlink" title="커스텀 ViewResolver"></a>커스텀 ViewResolver</h4><p>DispatcherServlet이 사용하는 여러가지 멀티파트 전략들이 구성될때,<br>만약 ApplicationContext에 커스텀하게 특정 전략 타입의 빈으로 등록되어 있다면 해당 전략을 사용하고,<br>ApplicationContext에 그런 빈이 없다면 기본적으로 제공되는 전략(defaultStrategies : DispatcherServlet.properties)을 사용하게 된다.  </p>
<p>/WEB-INF 에서 .jsp로 끝나는 뷰를 찾아주는 커스텀 ViewResolver</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public ViewResolver viewResolver() &#123;</span><br><span class="line">    InternalResourceViewResolver viewResolver &#x3D; new InternalResourceViewResolver();</span><br><span class="line">    viewResolver.setPrefix(&quot;&#x2F;WEB-INF&#x2F;&quot;);</span><br><span class="line">    viewResolver.setSuffix(&quot;.jsp&quot;);</span><br><span class="line">    return viewResolver;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>=&gt; 커스텀을 사용하면 기본 ViewResolver는 추가되지 않는다.</p>
<p>참고로 Strategy interface의 구현체들을 찾아내고 빈으로 등록하는 일련의 과정들은 DispatcherServlet이 초기화될 때의 한번만 일어나기 때문에 이 후 요청에서는 생략된다.<br>(서블릿의 라이프 사이클에서 init()이 한번만 수행되는 것과 동일함)</p>
<h3 id="스프링-MVC-구성-요소"><a href="#스프링-MVC-구성-요소" class="headerlink" title="스프링 MVC 구성 요소"></a>스프링 MVC 구성 요소</h3><h4 id="MultipartResolver"><a href="#MultipartResolver" class="headerlink" title="MultipartResolver"></a>MultipartResolver</h4><p>파일 업로드 요청 처리에 필요한 인터페이스<br>HttpServletRequest를 MultipartHttpServletRequest로 변환해주어 요청이 담고있는 File을 꺼낼 수 있는 API제공  </p>
<p>Spring의 DispatcherServlet에서는 default로 null인데, Spring Boot에서는 StandardServletMultipartResolver가 등록된다.  </p>
<h4 id="LocaleResolver"><a href="#LocaleResolver" class="headerlink" title="LocaleResolver"></a>LocaleResolver</h4><p>클라이언트의 위치 정보를 파악하는 인터페이스 (요청 분석 단계)<br>기본 전략은 요청의 accept-language를 보고 판단한다.  (AcceptHeaderLocaleResolver)</p>
<h4 id="ThemeResolver"><a href="#ThemeResolver" class="headerlink" title="ThemeResolver"></a>ThemeResolver</h4><p>애플리케이션에 설정된 테마를 파악하고 변경할 수 있는 인터페이스<br>Spring MVC의 Theme switch 기능을 담당한다.<br>(theme 값에 따라 다른 css를 사용하는 등의 기능 처리)</p>
<h4 id="HandlerMapping"><a href="#HandlerMapping" class="headerlink" title="HandlerMapping"></a>HandlerMapping</h4><p>요청을 처리할 핸들러를 찾는 인터페이스<br>주로 RequestMappingHandlerMapping(annotation 기반)이 사용됨</p>
<h4 id="HandlerAdapter"><a href="#HandlerAdapter" class="headerlink" title="HandlerAdapter"></a>HandlerAdapter</h4><p>HandlerMapping이 찾아낸 핸들러를 처리하는 인터페이스<br>핸들러를 개발자들이 원하는대로 만들 수 있게 해주는 스프링 MVC 확장력의 핵심이다.<br>주로 RequestMappingHandlerAdapter(annotation 기반)가 사용됨</p>
<h4 id="HandlerExceptionResolver"><a href="#HandlerExceptionResolver" class="headerlink" title="HandlerExceptionResolver"></a>HandlerExceptionResolver</h4><p>요청 처리 중 발생한 에러를 처리하는 인터페이스<br>주로 ExceptionHandlerExceptionResolver(@ExceptionHandler annotation 기반)가 사용됨</p>
<h4 id="RequestToViewNameTranslator"><a href="#RequestToViewNameTranslator" class="headerlink" title="RequestToViewNameTranslator"></a>RequestToViewNameTranslator</h4><p>핸들러에서 뷰 이름을 명시적으로 리턴하지 않은 경우, 요청을 기반으로 뷰 이름을 판단하는 인터페이스  </p>
<h4 id="ViewResolver"><a href="#ViewResolver" class="headerlink" title="ViewResolver"></a>ViewResolver</h4><p>뷰 이름에 해당하는 뷰를 찾아내는 인터페이스  </p>
<h4 id="FlashMapManager"><a href="#FlashMapManager" class="headerlink" title="FlashMapManager"></a>FlashMapManager</h4><p>FlashMap 인스턴스를 가져오고 저장하는 인터페이스<br>FlashMap은 주로 리다이렉션을 사용할 때 요청 매개변수를 사용하지 않고 데이터를 전달하고 정리할 때 사용한다.<br>폼서브미션을 방지하기 위한 일종의 패턴  </p>
]]></content>
      <categories>
        <category>Study</category>
        <category>Spring Framework</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Spring MVC</tag>
        <tag>Servlet</tag>
      </tags>
  </entry>
  <entry>
    <title>스프링 부트에서 JSP 사용하기</title>
    <url>/2020/09/15/hexo_spring_project_11/</url>
    <content><![CDATA[<h2 id="스프링-부트에서-JSP-사용하기"><a href="#스프링-부트에서-JSP-사용하기" class="headerlink" title="스프링 부트에서 JSP 사용하기"></a>스프링 부트에서 JSP 사용하기</h2><h3 id="의존성-추가-maven"><a href="#의존성-추가-maven" class="headerlink" title="의존성 추가 (maven)"></a>의존성 추가 (maven)</h3><p>jstl, jsp 사용을 위한 의존성 추가가 필요하다.  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;javax.servlet&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jstl&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.tomcat.embed&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;tomcat-embed-jasper&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;scope&gt;provided&lt;&#x2F;scope&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<h3 id="WAR-프로젝트"><a href="#WAR-프로젝트" class="headerlink" title="WAR 프로젝트"></a>WAR 프로젝트</h3><p>스프링 부트 프로젝트에서 jsp를 사용하려면 WAR 패키지 설정으로 생성해야 한다.<br>WAR 패키지 설정의 스프링 부트 프로젝트의 특징은 @SpringBootApplication 클래스 외에<br>WebApplicationInitializer를 구현한 ServletInitializer 클래스가 웹서버 배포를 위해 추가로 생성된다.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ServletInitializer extends SpringBootServletInitializer &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected SpringApplicationBuilder configure(SpringApplicationBuilder application) &#123;</span><br><span class="line">        return application.sources(DemoJspApplication.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Controller-생성"><a href="#Controller-생성" class="headerlink" title="Controller 생성"></a>Controller 생성</h3><p>메서드의 리턴(String)으로 jsp view를 찾을 수 있도록 생성</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class EventController &#123;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;&#x2F;events&quot;)</span><br><span class="line">    public String getEvents(Model model) &#123;</span><br><span class="line">        Event event1 &#x3D; new Event();</span><br><span class="line">        event1.setName(&quot;study 1&quot;);</span><br><span class="line">        event1.setStart(LocalDate.of(2020,10,10));</span><br><span class="line">        Event event2 &#x3D; new Event();</span><br><span class="line">        event2.setName(&quot;study 2&quot;);</span><br><span class="line">        event2.setStart(LocalDate.of(2020,10,20));</span><br><span class="line"></span><br><span class="line">        List&lt;Event&gt; events &#x3D; List.of(event1,event2);</span><br><span class="line"></span><br><span class="line">        model.addAttribute(&quot;events&quot;,events);</span><br><span class="line">        model.addAttribute(&quot;message&quot;,&quot;Study Harder&quot;);</span><br><span class="line"></span><br><span class="line">        return &quot;events&#x2F;list&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="jsp-view-생성"><a href="#jsp-view-생성" class="headerlink" title="jsp view 생성"></a>jsp view 생성</h3><p>jsp view는 webapp 디렉토리에 있어야하며 스프링 부트가 이 디렉토리를 미리 만들어주지 않기 때문에 직접 생성해야 한다.<br>webapp/WEB-INF/jsp/events/list.jsp<br>태그 선언을 통해 core 라이브러리 사용</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType&#x3D;&quot;text&#x2F;html;charset&#x3D;UTF-8&quot; language&#x3D;&quot;java&quot; %&gt;</span><br><span class="line">&lt;%@ taglib prefix&#x3D;&quot;c&quot; uri&#x3D;&quot;http:&#x2F;&#x2F;java.sun.com&#x2F;jsp&#x2F;jstl&#x2F;core&quot;%&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Events&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h1&gt;이벤트 목록&lt;&#x2F;h1&gt;</span><br><span class="line">    &lt;h2&gt;$&#123;message&#125;&lt;&#x2F;h2&gt;</span><br><span class="line">    &lt;table&gt;</span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">            &lt;th&gt;이름&lt;&#x2F;th&gt;</span><br><span class="line">            &lt;th&gt;시작&lt;&#x2F;th&gt;</span><br><span class="line">        &lt;&#x2F;tr&gt;</span><br><span class="line">        &lt;c:forEach items&#x3D;&quot;$&#123;events&#125;&quot; var&#x3D;&quot;event&quot;&gt;</span><br><span class="line">            &lt;tr&gt;</span><br><span class="line">                &lt;td&gt;$&#123;event.name&#125;&lt;&#x2F;td&gt;</span><br><span class="line">                &lt;td&gt;$&#123;event.start&#125;&lt;&#x2F;td&gt;</span><br><span class="line">            &lt;&#x2F;tr&gt;</span><br><span class="line">        &lt;&#x2F;c:forEach&gt;</span><br><span class="line">    &lt;&#x2F;table&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>

<h3 id="application-properties-설정"><a href="#application-properties-설정" class="headerlink" title="application.properties 설정"></a>application.properties 설정</h3><p>viewResolver가 view를 찾을 수 있도록 prefix/suffix 설정</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring.mvc.view.prefix&#x3D;&#x2F;WEB-INF&#x2F;jsp&#x2F;</span><br><span class="line">spring.mvc.view.suffix&#x3D;.jsp</span><br></pre></td></tr></table></figure>

<h3 id="패키징"><a href="#패키징" class="headerlink" title="패키징"></a>패키징</h3><p>스프링 부트 애플리케이션은 Maven이 따로 설치되어있지 않더라도 mvnw 명령을 통해<br>Maven으로 빌드할 수 있다.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;mvnw package</span><br></pre></td></tr></table></figure>

<p>빌드가 완료되면 WAR 파일이 생성된다. (target/???-0.0.1-SNAPSHOT.war)</p>
<h3 id="실행"><a href="#실행" class="headerlink" title="실행"></a>실행</h3><h4 id="java-jar"><a href="#java-jar" class="headerlink" title="java -jar"></a>java -jar</h4><p>WAR파일도 java -jar 를 통해 독립적으로 실행할 수 있다.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -jar target&#x2F;*-0.0.1-SNAPSHOT.war</span><br></pre></td></tr></table></figure>
<p>@SpringBootApplication 클래스의 SpringApplication.run 이 사용되며,<br>스프링 부트 애플리케이션의 내장 톰캣이 사용된다.</p>
<h4 id="서블릿-컨테이너에-배포하는-경우"><a href="#서블릿-컨테이너에-배포하는-경우" class="headerlink" title="서블릿 컨테이너에 배포하는 경우"></a>서블릿 컨테이너에 배포하는 경우</h4><p>ServletInitializer 클래스가 있기 때문에 톰캣 등 웹서버에 배포할 수 있다.<br>SpringBootServletInitializer를 사용하여 실행된다.<br>내장 톰캣을 사용하는게 아니고 별개의 웹서버에 서블릿을 등록하여 실행된다.</p>
<p>참고로, 스프링 부트는 몇가지 제약 사항때문에 jsp 사용을 피하길 권고한다.</p>
<ul>
<li>JAR 프로젝트로 만들 수 없다.</li>
<li>WAR는 java -jar로 실행할 수는 있지만, “실행가능한 jar 파일”은 지원하지 않는다.</li>
<li>언더토우 서블릿 컨테이너는 jsp를 지원하지 않는다.</li>
<li>Whitelabel 에러 페이지를 error.jsp로 오버라이딩할 수 없다.</li>
</ul>
]]></content>
      <categories>
        <category>Study</category>
        <category>Spring Framework</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>JSP</tag>
      </tags>
  </entry>
  <entry>
    <title>도메인 클래스 컨버터 자동 등록</title>
    <url>/2020/09/15/hexo_spring_project_12/</url>
    <content><![CDATA[<h2 id="도메인-클래스-컨버터-자동-등록"><a href="#도메인-클래스-컨버터-자동-등록" class="headerlink" title="도메인 클래스 컨버터 자동 등록"></a>도메인 클래스 컨버터 자동 등록</h2><p>스프링 데이터 JPA는 도메인 클래스 컨버터를 제공한다.  </p>
<ul>
<li>도메인 클래스 컨버터<br>: 스프링 데이터 JPA의 Repository를 사용해서 ID에 해당하는 엔티티를 읽어온다.</li>
</ul>
<h3 id="스프링-데이터-JPA-및-h2DB-의존성-설정"><a href="#스프링-데이터-JPA-및-h2DB-의존성-설정" class="headerlink" title="스프링 데이터 JPA 및 h2DB 의존성 설정"></a>스프링 데이터 JPA 및 h2DB 의존성 설정</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.h2database&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;h2&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<h3 id="Repository-추가"><a href="#Repository-추가" class="headerlink" title="Repository 추가"></a>Repository 추가</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface PersonRepository extends JpaRepository&lt;Person, Long&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="엔티티-맵핑"><a href="#엔티티-맵핑" class="headerlink" title="엔티티 맵핑"></a>엔티티 맵핑</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Entity</span><br><span class="line">public class Person &#123;</span><br><span class="line"></span><br><span class="line">    @Id</span><br><span class="line">    @GeneratedValue</span><br><span class="line">    private Long id;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    public Long getId() &#123;</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setId(Long id) &#123;</span><br><span class="line">        this.id &#x3D; id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="도메인-클래스-컨버터"><a href="#도메인-클래스-컨버터" class="headerlink" title="도메인 클래스 컨버터"></a>도메인 클래스 컨버터</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@GetMapping(&quot;&#x2F;hello&quot;)</span><br><span class="line">public String hello(@RequestParam(&quot;id&quot;) Person person) &#123;</span><br><span class="line">    return &quot;hello&quot; + person.getName();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>get 메서드는 ID를 파라미터로 받는데, 받은 파라미터가 문자열이더라도<br>자동으로 등록된 도메인 클래스 컨버터에 의해 Person 객체로 변환될 수 있다.    </p>
<h4 id="테스트"><a href="#테스트" class="headerlink" title="테스트"></a>테스트</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void hello() throws Exception &#123;</span><br><span class="line">    Person person &#x3D; new Person();</span><br><span class="line">    person.setName(&quot;이정인&quot;);</span><br><span class="line">    Person savedPerson &#x3D; personRepository.save(person);</span><br><span class="line"></span><br><span class="line">    mockMvc.perform(MockMvcRequestBuilders.get(&quot;&#x2F;hello&quot;)</span><br><span class="line">            .param(&quot;id&quot;,savedPerson.getId().toString()))</span><br><span class="line">            .andDo(print())</span><br><span class="line">            .andExpect(content().string(&quot;hello이정인&quot;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Study</category>
        <category>Spring Framework</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>DomainClassConverter</tag>
      </tags>
  </entry>
  <entry>
    <title>스프링 MVC 핵심 기술</title>
    <url>/2020/09/15/hexo_spring_project_13/</url>
    <content><![CDATA[<h2 id="스프링-MVC-핵심-기술"><a href="#스프링-MVC-핵심-기술" class="headerlink" title="스프링 MVC 핵심 기술"></a>스프링 MVC 핵심 기술</h2><h3 id="HTTP-요청-맵핑하기"><a href="#HTTP-요청-맵핑하기" class="headerlink" title="HTTP 요청 맵핑하기"></a>HTTP 요청 맵핑하기</h3><h4 id="HTTP-Method"><a href="#HTTP-Method" class="headerlink" title="HTTP Method"></a>HTTP Method</h4><ul>
<li><p>GET 요청</p>
<ul>
<li>클라이언트가 서버의 리소스를 요청할 떄 사용</li>
<li>캐싱 가능 (조건적 GET 가능)</li>
<li>브라우저의 기록에 남고 북마크가 가능</li>
<li>URL이 다 보이므로 민감한 데이터에는 맞지 않음</li>
<li>idempotent</li>
</ul>
</li>
<li><p>POST 요청</p>
<ul>
<li>클라이언트가 서버의 리소스를 수정하거나 새로만들 떄 사용</li>
<li>서버에 보내는 데이터를 POST 요청 본문에 담는다</li>
<li>캐싱 불가능</li>
<li>브라우저 기록에 남지 않고 북마크가 불가능</li>
<li>데이터 길이 제한이 없다</li>
</ul>
</li>
<li><p>PUT 요청</p>
<ul>
<li>URI에 해당하는 데이터를 새로 만들거나 수정할 떄 사용</li>
<li>POST와 다른 점은 “URI”에 대한 의미에 있다<ul>
<li>POST의 URI는 보내는 데이터를 처리할 리소스</li>
<li>PUT의 URI는 보내는 데이터에 해당하는 리소스</li>
</ul>
</li>
<li>idempotent</li>
</ul>
</li>
<li><p>PATCH 요청</p>
<ul>
<li>PUT과 비슷하지만, 기존 엔티티와 새 엔티티의 차이점만 보낸다는 차이가 있다.</li>
<li>idempotent</li>
</ul>
</li>
<li><p>DELETE 요청</p>
<ul>
<li>URI에 해당하는 리소스를 삭제할 떄 사용</li>
<li>idempotent</li>
</ul>
</li>
</ul>
<h4 id="스프링-웹-MVC에서-HTTP-Method-맵핑하기"><a href="#스프링-웹-MVC에서-HTTP-Method-맵핑하기" class="headerlink" title="스프링 웹 MVC에서 HTTP Method 맵핑하기"></a>스프링 웹 MVC에서 HTTP Method 맵핑하기</h4><p>@RequestMapping : http 요청 맵핑 어노테이션, 메서드 종류를 지정하지 않으면 기본적으로 모든 메서드를 허용하게 된다.<br>즉, 메서드 종류를 지정한다는 것은 허용하는 요청의 종류를 제한하는 것과 같다.<br>@ResponseBody : 리턴을 응답 본문으로 전달하는 어노테이션<br>@GetMapping : @RequestMapping(method=RequestMethod.GET)  </p>
<h4 id="URI-패턴-맵핑"><a href="#URI-패턴-맵핑" class="headerlink" title="URI 패턴 맵핑"></a>URI 패턴 맵핑</h4><p>@RequestMapping에서 지원하는 패턴  </p>
<ul>
<li>? : 한 글자  </li>
<li>* : 여러 글자  </li>
<li>** : 여러 패스</li>
<li>정규표현식 가능 (ex: “/{name: [a-z]+}”)  </li>
</ul>
<p>만약 패턴이 중복되는 경우, 가장 구체적으로 맵핑되는 핸들러가 선택됨</p>
<h4 id="컨텐츠-타입-맵핑"><a href="#컨텐츠-타입-맵핑" class="headerlink" title="컨텐츠 타입 맵핑"></a>컨텐츠 타입 맵핑</h4><ul>
<li><p>특정 타입의 데이터를 담고있는 요청만 처리하도록 핸들러 설정<br>@RequestMapping(consumes=MediaType.APPLICATION_JSON_UTF8_VALUE)<br>Content-Type 헤더로 필터링</p>
</li>
<li><p>특정 타입의 응답을 만드는 핸들러 설정<br>@RequestMapping(produces=MediaType.APPLICATION_JSON_UTF8_VALUE)<br>Accept 헤더로 필터링, 만약 요청 헤더에 accept가 비워진 경우에는 그냥 처리해줌</p>
</li>
</ul>
<p>consumes/produces를 클래스의 @RequestMapping 어노테이션에서도 설정할 수 있는데,<br>이때 메서드(핸들러)의 @RequestMapping의 consumes/produces가 설정되면 클래스의 것은 무시된다.</p>
<h4 id="헤더와-파라미터-맵핑"><a href="#헤더와-파라미터-맵핑" class="headerlink" title="헤더와 파라미터 맵핑"></a>헤더와 파라미터 맵핑</h4><ul>
<li>@RequestMapping(headers = “key”) : 특정 헤더가 있는 요청만 처리</li>
<li>@RequestMapping(headers = “!key”) : 특정 헤더가 없는 요청만 처리</li>
<li>@RequestMapping(headers = “key=value”) : 특정 헤더/키 쌍이 있는 요청만 처리</li>
<li>@RequestMapping(params = “a”) : 특정 요청 매개변수 키를 가지고 있는 요청만 처리</li>
<li>@RequestMapping(params = “!a”) : 특정 요청 매개변수가 없는 요청만 처리</li>
<li>@RequestMapping(params = “a=b”) : 특정 요청 매개변수 키/값 쌍을 가지고 있는 요청만 처리</li>
</ul>
<h4 id="HEAD와-OPTIONS-요청-처리"><a href="#HEAD와-OPTIONS-요청-처리" class="headerlink" title="HEAD와 OPTIONS 요청 처리"></a>HEAD와 OPTIONS 요청 처리</h4><p>HEAD와 OPTIONS http method는 스프링 웹 MVC가 기본으로 제공해주는 기능이다.  </p>
<ul>
<li>HEAD : GET 요청과 동일하지만 응답 본문을 받아오지 않고 응답 헤더만 받아온다.</li>
<li>OPTIONS : 응답 헤더 ALLOW로 사용할 수 있는 HTTP Method 목록을 받아온다.</li>
</ul>
<h4 id="커스텀-애노테이션"><a href="#커스텀-애노테이션" class="headerlink" title="커스텀 애노테이션"></a>커스텀 애노테이션</h4><ul>
<li><p>메타 애노테이션<br>애노테이션에 사용할 수 있는 애노테이션<br>스프링이 제공하는 대부분의 애노테이션은 메타 애노테이션으로 사용할 수 있다</p>
</li>
<li><p>조합 애노테이션<br>한개 혹은 여러개의 메타 애노테이션을 조합해서 만든 애노테이션<br>코드를 간결하게 줄일 수 있다<br>보다 구체적인 의미를 부여할 수 있다</p>
</li>
<li><p>@Retantion<br>해당 애노테이션 정보를 언제까지 유지할 것인가 결정</p>
<ul>
<li>Source : 소스 코드까지만 유지, 컴파일하면 해당 애노테이션 정보는 사라짐</li>
<li>Class : 컴파일 한 .class 파일에도 유지, 런타임시 클래스를 메모리로 읽어오면 해당 정보는 사라짐 (default)</li>
<li>Runtime : 클래스를 메모리로 읽어왔을때까지 유지, 코드에서 이 정보를 바탕으로 특정 로직을 실행할 수 있다</li>
</ul>
</li>
<li><p>@Target<br>해당 애노테이션을 어디에 사용할 수 있는지 결정</p>
</li>
<li><p>@Documented<br>해당 애노테이션을 사용한 코드의 문서에 그 애노테이션에 대한 정보를 표기할 지 결정</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RequestMapping(method &#x3D; RequestMethod.GET, value &#x3D; &quot;&#x2F;hello&quot;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(ElementType.METHOD)</span><br><span class="line">public @interface GetHelloMapping &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="핸들러-메소드"><a href="#핸들러-메소드" class="headerlink" title="핸들러 메소드"></a>핸들러 메소드</h3><h4 id="핸들러-메소드-아규먼트와-리턴-타입"><a href="#핸들러-메소드-아규먼트와-리턴-타입" class="headerlink" title="핸들러 메소드 아규먼트와 리턴 타입"></a>핸들러 메소드 아규먼트와 리턴 타입</h4><ul>
<li>핸들러 메소드 아규먼트<br>: 주로 요청 그 자체 또는 요청에 들어있는 정보를 받아오는데 사용</li>
</ul>
<p>WebRequest, NativeWebRequest, ServletRequest, HttpServletRequest : 요청 또는 응답 자체에 접근 가능한 API</p>
<p>InputStream, Reader, OutputStream, Writer : 요청 본문을 읽어오거나, 응답 본문을 쓸 때 사용할 수 있는 API</p>
<p>PushBuilder : HTTP/2 리소스 푸쉬에 사용 (스프링 5)</p>
<p>HttpMethod : 요청의 Http 메서드에 대한 정보</p>
<p>Locale, TimeZone, ZoneId : LocaleResolver가 분석한 요청의 Locale 정보</p>
<p>@PathVariable : URL 템플릿 변수 읽을 때 사용</p>
<p>@MatrixVariable : URL 경로 중에 키/값 쌍을 읽어올 때 사용</p>
<p>@RequestParam : 서블릿 요청 매게변수 값을 선언한 메소드 아규먼트 타입으로 변환, 단순 타입에서는 생략 가능</p>
<p>@RequestHeader : 요청 해더 값을 선언한 메소드 아규먼트 타입으로 변환 </p>
<p>@RequestBody : 요청 본문을 HttpMessageConverter를 사용해 특정 타입으로 변환</p>
<ul>
<li>핸들러 메소드 리턴<br>: 주로 응답 또는 모델을 렌더링할 뷰에 대한 정보를 제공하는데 사용</li>
</ul>
<p>@ResponseBody : 리턴 값을 HttpMessageConverter를 사용해 응답 본문으로 사용한다.</p>
<p>HttpEntity, ResponseEntity : 응답 본문 뿐 아니라 헤더 정보까지 전체 응답을 만들 때 사용한다.</p>
<p>String : ViewResolver를 사용해서 뷰를 찾을 떄 사용할 뷰 이름</p>
<p>View : 암묵적인 모델 정보를 랜더링할 뷰 인스턴스</p>
<p>Map, Model : 암묵적으로 판단한 뷰를 랜더링할 때 사용할 모델 정보</p>
<p>@ModelAttribute : 암묵적으로 판단한 뷰를 랜더링할 때 사용할 모델 정보에 추가한다.</p>
<h4 id="URI-패턴을-아규먼트로"><a href="#URI-패턴을-아규먼트로" class="headerlink" title="URI 패턴을 아규먼트로"></a>URI 패턴을 아규먼트로</h4><ul>
<li><p>@PathVariable<br>요청 URL 패턴의 일부를 핸들러 메소드 아규먼트로 받는 방법<br>타입 변환 지원<br>값이 반드시 있어야 한다.<br>Optional 지원  </p>
</li>
<li><p>@MatrixVariable<br>@PathVariable과 유사하나 아규먼트로 키/값쌍을 받는다.<br>별도의 활성화가 필요하다.</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class WebConfig implements WebMvcConfigurer &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void configurePathMatch(PathMatchConfigurer configurer) &#123;</span><br><span class="line">        UrlPathHelper urlPathHelper &#x3D; new UrlPathHelper();</span><br><span class="line">        &#x2F;&#x2F;세미콜론을 제거하지 않도록 설정</span><br><span class="line">        urlPathHelper.setRemoveSemicolonContent(false);</span><br><span class="line">        </span><br><span class="line">        configurer.setUrlPathHelper(urlPathHelper);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@GetMapping(&quot;&#x2F;events&#x2F;&#123;id&#125;&quot;)</span><br><span class="line">@ResponseBody</span><br><span class="line">public Event getEvent(@PathVariable(&quot;id&quot;) Long id, @MatrixVariable String name) &#123;</span><br><span class="line">    &#x2F;&#x2F;key &#x3D; &quot;name&quot;, value &#x3D; ?  </span><br><span class="line">    Event event &#x3D; new Event();</span><br><span class="line">    event.setId(id);</span><br><span class="line">    event.setName(name);</span><br><span class="line">    return event;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="요청-매개변수를-아규먼트로"><a href="#요청-매개변수를-아규먼트로" class="headerlink" title="요청 매개변수를 아규먼트로"></a>요청 매개변수를 아규먼트로</h4><ul>
<li>@RequestParam<br>요청 매개변수에 있는 단순 타입 데이터를 메서드 아규먼트로 받을 수 있다. (“/events?id=20” 또는 폼 데이터)<br>값이 반드시 있어야 한다. (또는 required=false, Optional 사용하여 기본값 설정 등)<br>String이 아닌 값들은 타입 변환을 지원한다.<br>Map을 사용하여 모든 매개변수를 받아올 수 있다.  </li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@GetMapping(&quot;&#x2F;events&quot;)</span><br><span class="line">@ResponseBody</span><br><span class="line">public Event getEvent(@RequestParam(&quot;id&quot;) Long id) &#123;</span><br><span class="line">    Event event &#x3D; new Event();</span><br><span class="line">    event.setId(id);</span><br><span class="line">    return event;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ModelAttribute"><a href="#ModelAttribute" class="headerlink" title="@ModelAttribute"></a>@ModelAttribute</h4><p>여러 곳에 있는 단순 타입 데이터를 복합 타입 객체로 받아오거나 해당 객채를 새로 만들 때 사용  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@GetMapping(&quot;&#x2F;events&quot;)</span><br><span class="line">@ResponseBody</span><br><span class="line">public Event getEvents(@ModelAttribute Event event) &#123;</span><br><span class="line">    return event;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>복합 타입 객체의 각 데이터를 바인딩 하는 방법은 URL, 요청 매개변수, 세션 등이 있다.</p>
<p>값을 바인딩할 수 없는 경우 400 에러가 발생하는데,<br>이 에러를 직접 다루고 싶은 경우 BindingResult 타입의 아규먼트를 추가한다.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@GetMapping(&quot;&#x2F;events&quot;)</span><br><span class="line">@ResponseBody</span><br><span class="line">public Event getEvents(@ModelAttribute Event event, BindingResult bindingResult) &#123;</span><br><span class="line">    if(bindingResult.hasErrors()) &#123;</span><br><span class="line">        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);</span><br><span class="line">        bindingResult.getAllErrors().forEach(c -&gt; &#123;</span><br><span class="line">            System.out.println(c);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    return event;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>에러 발생 없이 에러정보는 BindingResult에 들어가고, 바인딩 되지 않은 값은 null이 된다.</p>
<p>만약 바인딩 이후에 추가적인 검증작업이 필요한 경우 @Valid 또는 @Validated 애노테이션 사용<br>(ex) Event 객체의 limit 속성은 항상 1이상이어야 한다.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Min(1)</span><br><span class="line">private Integer limit;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@GetMapping(&quot;&#x2F;events&quot;)</span><br><span class="line">@ResponseBody</span><br><span class="line">public Event getEvents(@Valid @ModelAttribute Event event, BindingResult bindingResult) &#123;</span><br><span class="line">    if(bindingResult.hasErrors()) &#123;</span><br><span class="line">        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);</span><br><span class="line">        bindingResult.getAllErrors().forEach(c -&gt; &#123;</span><br><span class="line">            System.out.println(c);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    return event;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>이때 @Valid 검증에 의해 bindingResult에 에러가 들어감에도 불구하고<br>해당 값은 바인딩 됨에 유의.</p>
<h4 id="Validated"><a href="#Validated" class="headerlink" title="@Validated"></a>@Validated</h4><p>@Valid와는 다르게 validation group이라는 힌트를 사용하여 그룹 클래스를 지정할 수 있다.<br>그룹을 지정하지 않은 경우 @Valid와 동일하게 동작한다.</p>
<p>두개의 validation group 생성</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface ValidateLimit &#123;&#125;</span><br><span class="line">interface ValidateName &#123;&#125;</span><br><span class="line"></span><br><span class="line">private Long id;</span><br><span class="line"></span><br><span class="line">@NotBlank(groups &#x3D; ValidateName.class)</span><br><span class="line">private String name;</span><br><span class="line"></span><br><span class="line">@Min(value &#x3D; 1,groups &#x3D; ValidateLimit.class)</span><br><span class="line">private Integer limit;</span><br></pre></td></tr></table></figure>

<p>특정 그룹만 검증하기</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@GetMapping(&quot;&#x2F;events&quot;)</span><br><span class="line">@ResponseBody</span><br><span class="line">public Event getEvents(@Validated(Event.ValidateName.class) @ModelAttribute Event event, BindingResult bindingResult) &#123;</span><br><span class="line">    if(bindingResult.hasErrors()) &#123;</span><br><span class="line">        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);</span><br><span class="line">        bindingResult.getAllErrors().forEach(c -&gt; &#123;</span><br><span class="line">            System.out.println(c.toString());</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    return event;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="SessionAttributes"><a href="#SessionAttributes" class="headerlink" title="@SessionAttributes"></a>@SessionAttributes</h4><p>모델 정보를 HTTP 세션에 저장해주는 애노테이션<br>HttpSession을 직접 사용할 수도 있지만 @SessionAttributes를 사용하면<br>설정한 이름에 해당하는 모델 정보를 자동으로 세션에 저장해준다.<br>여러 화면 또는 요청에서 사용되는 객체를 공유할 때 사용한다.  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Controller</span><br><span class="line">@SessionAttributes(&quot;event&quot;)</span><br><span class="line">public class EventController &#123;</span><br></pre></td></tr></table></figure>

<p>SessionStatus를 사용해서 특정 폼 처리 완료 후에 세션 데이터를 비우도록 할 수 있다.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@PostMapping(&quot;&#x2F;events&quot;)</span><br><span class="line">public String createEvent(@Validated @ModelAttribute Event event,</span><br><span class="line">                          BindingResult bindingResult,</span><br><span class="line">                          SessionStatus sessionStatus) &#123;</span><br><span class="line">    if(bindingResult.hasErrors()) &#123;</span><br><span class="line">       return &quot;&#x2F;events&#x2F;form&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;todo save</span><br><span class="line">    sessionStatus.setComplete();</span><br><span class="line">    return &quot;redirect:&#x2F;events&#x2F;list&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="SessionAttribute"><a href="#SessionAttribute" class="headerlink" title="@SessionAttribute"></a>@SessionAttribute</h4><p>HTTP 세션에 들어있는 데이터를 참조할 떄 사용한다.<br>타입 컨버전을 지원, 데이터 수정을 위해서는 HttpSession 사용  </p>
<p>@SessionAttributes는 해당 컨트롤러 내에서만 특정 모델 객체를 공유할때 사용하는 한편,<br>@SessionAttribute는 컨트롤러 밖(인터셉터 또는 필터 등)에서 만들어준 세션 데이터에 접근할 때 사용한다.  </p>
<p>접속 시간을 기록하여 Session에 저장하는 인터셉트를 생성하고 (등록 필요)<br>핸들러 메서드에서 사용하기</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class VisitTimeInterceptor implements HandlerInterceptor &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;</span><br><span class="line">        HttpSession session &#x3D; request.getSession();</span><br><span class="line">        if (session.getAttribute(&quot;visitTime&quot;) &#x3D;&#x3D; null) &#123;</span><br><span class="line">            session.setAttribute(&quot;visitTime&quot;, LocalDateTime.now());</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void addInterceptors(InterceptorRegistry registry) &#123;</span><br><span class="line">    registry.addInterceptor(new VisitTimeInterceptor());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@GetMapping(&quot;&#x2F;events&#x2F;list&quot;)</span><br><span class="line">public String getEvents(@ModelAttribute Event event,</span><br><span class="line">                        Model model,</span><br><span class="line">                        SessionStatus sessionStatus,</span><br><span class="line">                        @SessionAttribute LocalDateTime visitTime) &#123;</span><br><span class="line">    System.out.println(visitTime);</span><br><span class="line">    List&lt;Event&gt; eventList &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    eventList.add(event);</span><br><span class="line"></span><br><span class="line">    model.addAttribute(&quot;eventList&quot;,eventList);</span><br><span class="line">    sessionStatus.setComplete();</span><br><span class="line">    return &quot;&#x2F;events&#x2F;list&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="RedirectAttributes"><a href="#RedirectAttributes" class="headerlink" title="RedirectAttributes"></a>RedirectAttributes</h4><p>리다이렉트 할 때는 Model에 들어있는 primitive type 데이터가 URI 쿼리 매개변수에 추가된다.<br>(ex localhost:8080/events/list?name=mvc&amp;limit=50)    </p>
<p>스프링부트에서 기능 활성화를 위해서는 Ignore-default-model-on-redirect 프로퍼티를 사용해야 한다.  </p>
<p>application.properties</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring.mvc.ignore-default-model-on-redirect&#x3D;false</span><br></pre></td></tr></table></figure>

<p>리다이렉트할 때 원하는 데이터만 전달하고 싶을 때는 RedirectAttributes에 명시적으로 추가하여 사용할 수 있다.  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@PostMapping(&quot;&#x2F;events&#x2F;form&#x2F;limit&quot;)</span><br><span class="line">public String eventsFormLimitSubmit(@Validated @ModelAttribute Event event,</span><br><span class="line">                                    BindingResult bindingResult,</span><br><span class="line">                                    SessionStatus sessionStatus,</span><br><span class="line">                                    RedirectAttributes attributes) &#123;</span><br><span class="line">    if(bindingResult.hasErrors()) &#123;</span><br><span class="line">        return &quot;&#x2F;events&#x2F;form-limit&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;todo save</span><br><span class="line">    attributes.addAttribute(&quot;name&quot;, event.getName());</span><br><span class="line">    attributes.addAttribute(&quot;limit&quot;, event.getLimit());</span><br><span class="line">    sessionStatus.setComplete();</span><br><span class="line">    return &quot;redirect:&#x2F;events&#x2F;list&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>리다이렉트 요청을 처리하는 곳에서 쿼리 매개변수를 @RequestParam 또는 @ModelAttribute로 받을 수 있다.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@GetMapping(&quot;&#x2F;events&#x2F;list&quot;)</span><br><span class="line">public String getEvents(@ModelAttribute(&quot;newEvent&quot;) Event event,</span><br><span class="line">                        Model model,</span><br><span class="line">                        @SessionAttribute LocalDateTime visitTime) &#123;</span><br><span class="line">    System.out.println(visitTime);</span><br><span class="line"></span><br><span class="line">    List&lt;Event&gt; eventList &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    eventList.add(event);</span><br><span class="line"></span><br><span class="line">    model.addAttribute(&quot;eventList&quot;,eventList);</span><br><span class="line">    return &quot;&#x2F;events&#x2F;list&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>요청 매개변수를 복합객체로 받기 위해 @ModelAttribute를 사용할 때,<br>@SessionAttributes에서 세션에 저장한 이름과 동일하게 받는다면<br>우선적으로 객체를 세션에서 찾게 되기 때문에 에러가 발생할 수 있다.<br>그러므로 SessionAttributes와는 다른 이름으로 받아야 요청 매개변수를 통해 객체로 바인딩할 수 있다.  </p>
<h4 id="Flash-Attributes"><a href="#Flash-Attributes" class="headerlink" title="Flash Attributes"></a>Flash Attributes</h4><p>주로 리다이렉트 중에 데이터를 전달하는 목적으로 사용한다.<br>데이터가 URI에 노출되지 않고 임의의 객체를 사용할 수 있다.  </p>
<p>RedirectAttributes의 addFlashAttribute 메서드를 사용하여 객체를 HTTP 세션에 저장하여 넘겨준다.<br>리다이렉트 요청을 처리 한 다음 세션에서 제거된다.  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@PostMapping(&quot;&#x2F;events&#x2F;form&#x2F;limit&quot;)</span><br><span class="line">public String eventsFormLimitSubmit(@Validated @ModelAttribute Event event,</span><br><span class="line">                                    BindingResult bindingResult,</span><br><span class="line">                                    SessionStatus sessionStatus,</span><br><span class="line">                                    RedirectAttributes attributes) &#123;</span><br><span class="line">    if(bindingResult.hasErrors()) &#123;</span><br><span class="line">        return &quot;&#x2F;events&#x2F;form-limit&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;todo save</span><br><span class="line">    attributes.addFlashAttribute(&quot;newEvent&quot;,event);</span><br><span class="line">    sessionStatus.setComplete();</span><br><span class="line">    return &quot;redirect:&#x2F;events&#x2F;list&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>넘겨받은 객체는 Model에 자동으로 들어가기 때문에<br>리다이렉트 요청을 처리하는 곳에서는 @ModelAttribute로 선언하여 객체를 받을 필요 없이<br>Model에서 꺼내어 쓰면 된다.  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@GetMapping(&quot;&#x2F;events&#x2F;list&quot;)</span><br><span class="line">public String getEvents(Model model,</span><br><span class="line">                        @SessionAttribute LocalDateTime visitTime) &#123;</span><br><span class="line">    System.out.println(visitTime);</span><br><span class="line"></span><br><span class="line">    List&lt;Event&gt; eventList &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    eventList.add((Event) model.asMap().get(&quot;newEvent&quot;));</span><br><span class="line"></span><br><span class="line">    model.addAttribute(&quot;eventList&quot;,eventList);</span><br><span class="line">    return &quot;&#x2F;events&#x2F;list&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="MultipartFile"><a href="#MultipartFile" class="headerlink" title="MultipartFile"></a>MultipartFile</h4><p>파일 업로드에 사용하는 메소드 아규먼트<br>MultipartResolver 빈이 설정되어 있어야 사용할 수 있다.<br>(스프링부트에서는 MultipartAutoConfiguration에 의해 자동으로 설정된다.)<br>POST mulripart/form-data 요청이 들어있는 파일을 참조할 수 있다.<br>List<MultipartFile> 아규먼트로 여러 파일을 참조할 수 있다.  </p>
<p>파일 업로드 폼 예시</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div th:if&#x3D;&quot;$&#123;message&#125;&quot;&gt;</span><br><span class="line">    &lt;h2 th:text&#x3D;&quot;$&#123;message&#125;&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;form method&#x3D;&quot;POST&quot; enctype&#x3D;&quot;multipart&#x2F;form-data&quot; action&#x3D;&quot;#&quot; th:action&#x3D;&quot;@&#123;&#x2F;file&#125;&quot;&gt;</span><br><span class="line">    File : &lt;input type&#x3D;&quot;file&quot; name&#x3D;&quot;file&quot;&#x2F;&gt;</span><br><span class="line">    &lt;input type&#x3D;&quot;submit&quot; name&#x3D;&quot;Upload&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;form&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@GetMapping(&quot;&#x2F;file&quot;)</span><br><span class="line">public String fileUploadForm(Model model) &#123;</span><br><span class="line">    return &quot;files&#x2F;index&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@PostMapping(&quot;&#x2F;file&quot;)</span><br><span class="line">public String fileUpload(@RequestParam MultipartFile file,</span><br><span class="line">                         RedirectAttributes attributes) &#123;</span><br><span class="line">    &#x2F;&#x2F;todo file storage service</span><br><span class="line">    String message &#x3D; file.getOriginalFilename() + &quot; is uploaded.&quot;;</span><br><span class="line"></span><br><span class="line">    attributes.addFlashAttribute(&quot;message&quot;,message);</span><br><span class="line">    return &quot;redirect:&#x2F;file&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="File-Download"><a href="#File-Download" class="headerlink" title="File Download"></a>File Download</h4><p>스프링 ResourceLoader 사용  </p>
<ul>
<li>ResouceLoader<br>: 리소스를 읽어오는 기능을 제공하는 인터페이스<br>Resource getResource(String location);</li>
</ul>
<p>파일 다운로드 응답 헤더에 설정 할 내용</p>
<ul>
<li>CONTENT_DISPOSITION : 사용자가 파일을 받을 때 사용할 파일 이름</li>
<li>CONTENT_TYPE : 파일의 미디어 타입</li>
<li>CONTENT_LENGTH : 파일의 크기</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">private ResourceLoader resourceLoader;    </span><br><span class="line"></span><br><span class="line">@GetMapping(&quot;&#x2F;file&#x2F;&#123;filename&#125;&quot;)</span><br><span class="line">public ResponseEntity&lt;Resource&gt; fileDownload(@PathVariable String fileName) throws IOException &#123;</span><br><span class="line">    Resource resource &#x3D; resourceLoader.getResource(&quot;classpath:&quot;+fileName);</span><br><span class="line"></span><br><span class="line">    File file &#x3D; resource.getFile();</span><br><span class="line"></span><br><span class="line">    Tika tika &#x3D; new Tika();</span><br><span class="line">    String mediaType &#x3D; tika.detect(file);</span><br><span class="line"></span><br><span class="line">    return ResponseEntity.ok()</span><br><span class="line">            .header(HttpHeaders.CONTENT_DISPOSITION, &quot;attachment; filename&#x3D;\&quot;&quot;+resource.getFilename()+&quot;\&quot;&quot;)</span><br><span class="line">            .header(HttpHeaders.CONTENT_TYPE, mediaType)</span><br><span class="line">            .header(HttpHeaders.CONTENT_LENGTH, file.length()+&quot;&quot;)</span><br><span class="line">            .body(resource);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>리턴 타입 ResponseEntity : 응답 본문, 응답 헤더, 응답 상태 코드를 설정할 수 있는 리턴 타입이다. &lt;&gt;에는 응답 본문의 타입을 넣어준다.  </li>
<li>Tika : File의 미디어 타입을 알아낼 수 있다.<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.tika&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;tika-core&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.20&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="RequestBody-amp-HttpEntity"><a href="#RequestBody-amp-HttpEntity" class="headerlink" title="@RequestBody &amp; HttpEntity"></a>@RequestBody &amp; HttpEntity</h4><ul>
<li>@RequestBody<br>요청 본문에 들어있는 데이터를 HttpMessageConverter를 통해 변환한 객체로 받을 수 있다.<br>@Valid 또는 @Validated와 같이 사용하여 검증을 진행할 수 있다.<br>BindingResult 아규먼트를 사용해 코드로 바인딩 또는 검증 에러를 확인할 수 있다.  </li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;&#x2F;api&#x2F;events&quot;)</span><br><span class="line">public class EventApi &#123;</span><br><span class="line"></span><br><span class="line">    @PostMapping</span><br><span class="line">    public Event createEvent(@RequestBody Event event) &#123;</span><br><span class="line">        return event;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>HttpEntity<br>@RequestBody와 비슷하지만 추가적으로 요청 헤더 정보를 사용할 수 있다.  </li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;&#x2F;api&#x2F;events&quot;)</span><br><span class="line">public class EventApi &#123;</span><br><span class="line"></span><br><span class="line">    @PostMapping</span><br><span class="line">    public Event createEvent(HttpEntity&lt;Event&gt; request) &#123;</span><br><span class="line">        System.out.println(request.getHeaders().getContentType());</span><br><span class="line">        return request.getBody();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ResponseBody-amp-ResponseEntity"><a href="#ResponseBody-amp-ResponseEntity" class="headerlink" title="@ResponseBody &amp; ResponseEntity"></a>@ResponseBody &amp; ResponseEntity</h4><ul>
<li>@ResponseBody<br>핸들러 메서드의 리턴 데이터를 HttpMessageConverter를 통해 변환 후에 응답 본문 메시지로 보낼때 사용<br>@RestController를 사용하면 모든 핸들러 메서드에 적용된다.  </li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@PostMapping</span><br><span class="line">@ResponseBody</span><br><span class="line">public Event createEvent(@RequestBody @Valid Event event) &#123;</span><br><span class="line">    return event;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>ResponseEntity<br>응답 헤더 상태 코드 본문을 직접 다루고 싶은 경우에 사용한다.  </li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@PostMapping</span><br><span class="line">public ResponseEntity&lt;Event&gt; createEvent(@RequestBody @Valid Event event,</span><br><span class="line">                                         BindingResult bindingResult) &#123;</span><br><span class="line">    if (bindingResult.hasErrors()) &#123;</span><br><span class="line">        return ResponseEntity.badRequest().build();</span><br><span class="line">    &#125;</span><br><span class="line">    return ResponseEntity.ok(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Controller-설정"><a href="#Controller-설정" class="headerlink" title="Controller 설정"></a>Controller 설정</h3><h4 id="ModelAttribute의-다른-사용법"><a href="#ModelAttribute의-다른-사용법" class="headerlink" title="@ModelAttribute의 다른 사용법"></a>@ModelAttribute의 다른 사용법</h4><ul>
<li>해당 컨트롤러의 모든 요청에서 공통적으로 사용하는 모델 초기화하기  </li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@ModelAttribute</span><br><span class="line">public void categories(Model model) &#123;</span><br><span class="line">    model.addAttribute(&quot;categories&quot;,List.of(&quot;study&quot;, &quot;seminar&quot;, &quot;hobby&quot;, &quot;social&quot;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>메서드에 붙이면 리턴하는 객체를 모델에 넣어준다.<br>이 때는 RequestToViewNameTranslator에 의해 URL 이름으로 view 선택</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@GetMapping(&quot;&#x2F;events&#x2F;form-name&quot;)</span><br><span class="line">@ModelAttribute</span><br><span class="line">public Event newEvent() &#123;</span><br><span class="line">    return new Event();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="DataBinder-InitBinder"><a href="#DataBinder-InitBinder" class="headerlink" title="DataBinder : @InitBinder"></a>DataBinder : @InitBinder</h4><p>특정 컨트롤러에서 바인딩 또는 검증 설정을 변경하고 싶을 때 사용  </p>
<p>바인딩 설정<br>webDataBinder.setDisallowedFields();</p>
<p>포매터 설정<br>webDataBinder.addCustomFormatter();</p>
<p>Validator 설정<br>webDataBinder.addValidators();</p>
<p>또는 특정 이름의 모델 객체에만 바인딩 또는 검증 설정 적용</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@InitBinder(&quot;event&quot;)</span><br></pre></td></tr></table></figure>

<p>이벤트에 대한 데이터를 바인딩할때 id를 바인딩하지 않도록 설정</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@InitBinder(&quot;event&quot;)</span><br><span class="line">public void initEventBinder(WebDataBinder webDataBinder) &#123;</span><br><span class="line">    webDataBinder.setDisallowedFields(&quot;id&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="예외-처리-핸들러-ExceptionHandler"><a href="#예외-처리-핸들러-ExceptionHandler" class="headerlink" title="예외 처리 핸들러 : @ExceptionHandler"></a>예외 처리 핸들러 : @ExceptionHandler</h4><p>특정 예외가 발생한 요청을 처리하는 핸들러를 정의한다.<br>일반적인 핸들러 메서드와 비슷하게 작성할 수 있다.  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@ExceptionHandler</span><br><span class="line">public String eventErrorHandler(EventException exception, Model model) &#123;</span><br><span class="line">    model.addAttribute(&quot;message&quot;, &quot;event error&quot;);</span><br><span class="line">    return &quot;error&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Rest API의 경우 보통 ResponseEntity를 사용하여 예외에 대한 정보를 응답 본문으로 전달한다.  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@ExceptionHandler</span><br><span class="line">public ResponseEntity errorHandler(EventException exception) &#123;</span><br><span class="line">    return ResponseEntity.badRequest().body(&quot;can&#39;t create event.&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="전역-컨트롤러-ControllerAdvice"><a href="#전역-컨트롤러-ControllerAdvice" class="headerlink" title="전역 컨트롤러 : @ControllerAdvice"></a>전역 컨트롤러 : @ControllerAdvice</h4><p>@InitBinder, @ExceptionHandler, @ModelAttribute 를 모든 컨트롤러에서 사용하고 싶을 때 사용</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@ControllerAdvice</span><br><span class="line">public class GlobalController &#123;</span><br><span class="line">    @ExceptionHandler</span><br><span class="line">    public String eventErrorHandler(EventException exception, Model model) &#123;</span><br><span class="line">        model.addAttribute(&quot;message&quot;, &quot;event error&quot;);</span><br><span class="line">        return &quot;error&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @InitBinder</span><br><span class="line">    public void initEventBinder(WebDataBinder webDataBinder) &#123;</span><br><span class="line">        webDataBinder.setDisallowedFields(&quot;id&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @ModelAttribute</span><br><span class="line">    public void categories(Model model) &#123;</span><br><span class="line">        model.addAttribute(&quot;categories&quot;, List.of(&quot;study&quot;, &quot;seminar&quot;, &quot;hobby&quot;, &quot;social&quot;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>적용할 범위를 지정할 수 있다.  </p>
<ul>
<li>특정 애노테이션이 걸려있는 컨트롤러에만 적용<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@ControllerAdvice(annotations &#x3D; RestController.class)</span><br></pre></td></tr></table></figure></li>
<li>특정 패키지 이하의 컨트롤러에만 적용<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@ControllerAdvice(&quot;me.rockintuna.demowebmvc&quot;)</span><br></pre></td></tr></table></figure></li>
<li>특정 클래스 타입에만 적용 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@ControllerAdvice(assignableTypes &#x3D; &#123;EventController.class, EventApi.class&#125;)</span><br></pre></td></tr></table></figure>

</li>
</ul>
]]></content>
      <categories>
        <category>Study</category>
        <category>Spring Framework</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Spring MVC</tag>
        <tag>HTTP Method</tag>
        <tag>Handler Method</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring MVC 설정</title>
    <url>/2020/09/15/hexo_spring_project_10/</url>
    <content><![CDATA[<h2 id="Spring-MVC-설정"><a href="#Spring-MVC-설정" class="headerlink" title="Spring MVC 설정"></a>Spring MVC 설정</h2><h3 id="Spring-MVC-Bean-설정"><a href="#Spring-MVC-Bean-설정" class="headerlink" title="Spring MVC Bean 설정"></a>Spring MVC Bean 설정</h3><p>DispatcherServlet의 기본 전략에만 의존하기에는 확장성이 저하될 수 있기 때문에 추가적으로 설정할 수 있어야 한다.  </p>
<p>@Configuration을 사용한 자바 파일에 스프링 MVC 구성요소를 직접 빈으로 등록할 수 있다.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class WebConfig &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public ViewResolver viewResolver() &#123;</span><br><span class="line">        InternalResourceViewResolver viewResolver &#x3D; new InternalResourceViewResolver();</span><br><span class="line">        viewResolver.setPrefix(&quot;&#x2F;WEB-INF&#x2F;&quot;);</span><br><span class="line">        viewResolver.setSuffix(&quot;.jsp&quot;);</span><br><span class="line">        return viewResolver;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="EnableWebMvc"><a href="#EnableWebMvc" class="headerlink" title="@EnableWebMvc"></a>@EnableWebMvc</h3><p>애노테이션 기반 스프링 MVC를 사용할 때 편리한 웹 MVC 기본 설정<br>@EnableWebMvc를 사용하면 DelegatingWebMvcConfiguration.class를 import하여<br>애노테이션 기반 스프링 MVC 환경에 적합한 여러가지 설정 및 전략들을 추가하고 변경한다.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableWebMvc</span><br><span class="line">public class WebConfig &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@EnableWebMvc를 사용할 때는 ApplicationContext에 Servlet Context가 등록되어야 한다.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class WebApplication implements WebApplicationInitializer &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onStartup(ServletContext servletContext) throws ServletException &#123;</span><br><span class="line">        AnnotationConfigWebApplicationContext context &#x3D; new AnnotationConfigWebApplicationContext();</span><br><span class="line">        context.setServletContext(servletContext);</span><br><span class="line">        context.register(WebConfig.class);</span><br><span class="line">        context.refresh();</span><br><span class="line"></span><br><span class="line">        DispatcherServlet dispatcherServlet &#x3D; new DispatcherServlet(context);</span><br><span class="line">        ServletRegistration.Dynamic app &#x3D; servletContext.addServlet(&quot;app&quot;, dispatcherServlet);</span><br><span class="line">        app.addMapping(&quot;&#x2F;app&#x2F;*&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="WebMvcConfigurer-설정"><a href="#WebMvcConfigurer-설정" class="headerlink" title="WebMvcConfigurer 설정"></a>WebMvcConfigurer 설정</h3><p>특히, DelegatingWebMvcConfiguration을 사용하면 Formatter나 Interceptor를 추가하는 등 추가적인 설정이 더 쉬워진다는 장점도 있다.<br>WebMvcConfigurer는 @EnableWebMvc가 제공하는 빈을 커스터마이징할 수 있는 기능을 제공하는 인터페이스이다.  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableWebMvc</span><br><span class="line">public class WebConfig implements WebMvcConfigurer &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void configureViewResolvers(ViewResolverRegistry registry) &#123;</span><br><span class="line">        registry.jsp(&quot;&#x2F;WEB-INF&quot;,&quot;.jsp&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>새로운 빈을 추가할 필요 없이 @EnableWebMvc가 제공하는 빈에 추가 설정을 한다는 장점이 있다.  </p>
<h4 id="포매터-설정"><a href="#포매터-설정" class="headerlink" title="포매터 설정"></a>포매터 설정</h4><p>Formatter를 통해 문자열을 객체로 또는 객체를 문자열로 변환할 수 있다.  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@GetMapping(&quot;&#x2F;hello&#x2F;&#123;name&#125;&quot;)</span><br><span class="line">public String hello(@PathVariable(&quot;name&quot;) Person person) &#123;</span><br><span class="line">    return &quot;hello&quot; + person.getName();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>예를들어 위와 같은 get 메서드에서 url의 name 문자열을 Person이라는 객체로 받고 싶을 때 포매터를 사용한다.  </p>
<p>Formatter 인터페이스는 사실 Printer 인터페이스와 Parser 인터페이스를 합친것이다.<br>Printer : 객체를 문자열로 어떻게 보여줄 것인가<br>Parser : 문자열을 객체로 어떻게 변환할 것인가<br>각각에 해당하는 메서드를 구현해주면 된다. (print(), parse())</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class PersonFormatter implements Formatter&lt;Person&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Person parse(String s, Locale locale) throws ParseException &#123;</span><br><span class="line">        Person person &#x3D; new Person();</span><br><span class="line">        person.setName(s);</span><br><span class="line">        return person;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String print(Person person, Locale locale) &#123;</span><br><span class="line">        return person.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>포매터를 등록하는 방법</p>
<ul>
<li><p>WebMvcConfigurer의 addFormatters 메서드 정의</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class WebConfig implements WebMvcConfigurer &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void addFormatters(FormatterRegistry registry) &#123;</span><br><span class="line">        registry.addFormatter(new PersonFormatter());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>포매터를 빈으로 등록(스프링 부트에서만 가능) </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class PersonFormatter implements Formatter&lt;Person&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Person parse(String s, Locale locale) throws ParseException &#123;</span><br><span class="line">        Person person &#x3D; new Person();</span><br><span class="line">        person.setName(s);</span><br><span class="line">        return person;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String print(Person person, Locale locale) &#123;</span><br><span class="line">        return person.getName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="핸들러-인터셉터"><a href="#핸들러-인터셉터" class="headerlink" title="핸들러 인터셉터"></a>핸들러 인터셉터</h4><p>HandlerInterceptor<br> : 핸들러 맵핑에 설정할 수 있는 인터셉터<br> 핸들러 실행 전후와 완료(랜더링까지)시점에 부가 작업을 하고싶은 경우 사용하거나<br> 여러 핸들러에서 반복적으로 사용되는 코드를 줄이고 싶을 때 사용한다.</p>
<p>순서 </p>
<ul>
<li>preHandle(request, response, handler)<br>: 핸들러가 실행되기 전에 호출 됨, 핸들러에 대한 정보를 사용할 수 있기 때문에 서블릿 필터보다 더 세밀한 로직을 구현할 수 있다.<br>boolean을 return하는데, 다음 인터셉터나 핸들러로 전달할지 아니면 끝인지를 알린다.  </li>
<li>요청 처리</li>
<li>postHandle(request, response, modelAndView)<br>: 핸들러 실행이 끝나고 아직 뷰를 랜더링 하기 전에 호출 됨, 뷰에 전달할 추가적이거나 여러 핸들러에 공통적인 모델 정보를 담는데 사용할 수 있다.<br>여러 핸들러 인터셉터들이 있으면 역순으로 호출된다.<br>비동기적인 요청 처리 시에는 호출되지 않는다.</li>
<li>뷰 랜더링</li>
<li>afterCompletion(request, response, handler, ex)<br>: preHandle에서 true를 리턴 한 경우, 요청 처리가 완전히 끝난 뒤(뷰 랜더링 이후) 호출됨<br>여러 핸들러 인터셉터들이 있으면 역순으로 호출된다.<br>비동기적인 요청 처리 시에는 호출되지 않는다.</li>
</ul>
<p>핸들러 인터셉터 구현하기</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class GreetingInterceptor implements HandlerInterceptor &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;preHandle 1&quot;);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;postHandle 1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;afterCompletion 1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>핸들러 인터셉터 등록하기</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class WebConfig implements WebMvcConfigurer &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void addInterceptors(InterceptorRegistry registry) &#123;</span><br><span class="line">        registry.addInterceptor(new GreetingInterceptor());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="리소스-핸들러"><a href="#리소스-핸들러" class="headerlink" title="리소스 핸들러"></a>리소스 핸들러</h4><p>이미지, 자바스크립트, css, html 등 정적인 리소스를 처리하는 핸들러 등록 방법</p>
<p>디폴트(Default) 서블릿<br> : 서블릿 컨테이너가 기본으로 제공하는 서블릿으로 정적인 리소스 처리에 사용  </p>
<p>스프링 MVC 리소스 핸들러를 맵핑 등록 할때<br> : 가장 낮은 우선순위로 등록, DefaultServletHandlerConfigurer </p>
<p>리소스 핸들러 설정</p>
<ul>
<li>어떤 요청 패턴을 지원할 것인가</li>
<li>어디서 리소스를 찾을 것인가</li>
<li>캐싱</li>
<li>ResourceResolver : 요청에 해당하는 리소스를 찾는 전략.<br>캐싱, 인코딩, WebJar, …</li>
<li>ResourceTransformer : 응답으로 보낼 리소스를 수정하는 전략.<br>캐싱, CSS 링크, HTML 5 AppCache, …<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void addResourceHandlers(ResourceHandlerRegistry registry) &#123;</span><br><span class="line">    registry.addResourceHandler(&quot;&#x2F;mobile&#x2F;**&quot;)</span><br><span class="line">            .addResourceLocations(&quot;classpath:&#x2F;mobile&#x2F;&quot;)</span><br><span class="line">            .setCacheControl(CacheControl.maxAge(10, TimeUnit.MINUTES));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
스프링 부트에서는 기본적으로 정적 리소스 핸들러와 캐싱을 제공한다.(resources/static)  </li>
</ul>
<h4 id="HTTP-메시지-컨버터"><a href="#HTTP-메시지-컨버터" class="headerlink" title="HTTP 메시지 컨버터"></a>HTTP 메시지 컨버터</h4><p>요청 본문에서 메시지를 읽어들이거나(@RequestBody), 응답 본문에 메시지를 작성(@ResponseBody)할 때 사용한다.  </p>
<p>HTTP 메서드에서 @RequestBody 어노테이션을 통해 json 등 contentType을 특정 타입이나 객체로 받을 수 있게 해준다.  </p>
<p>메시지 컨버터 설정 방법  </p>
<ul>
<li><p>configureMessageConverters 메서드 사용</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void configureMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>이렇게 컨버터를 추가하면 기본으로 제공되는 메시지 컨버터들이 무시된다.</p>
</li>
<li><p>extendMessageConverters 메서드 사용</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void extendMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) &#123;</span><br><span class="line">            </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>기본으로 제공되는 메시지 컨버터들에 더해 새로운 컨버터가 추가된다.  </p>
</li>
<li><p>의존성 추가로 컨버터 등록<br>메이븐 또는 그래들 설정에서 의존성을 추가하면 WebMvcConfigurationSupport 클래스에 의해 그에 맞는 컨버터가 자동으로 등록된다.</p>
</li>
</ul>
<p>메시지 컨버터 등록하기</p>
<ul>
<li><p>Json 용 메시지컨버터</p>
<ul>
<li>스프링 부트를 사용하지 않는 경우<br>사용하고 싶은 Json 라이브러리를 의존성으로 추가</li>
<li>스프링 부트를 사용하는 경우<br>기본적으로 Jackson2JSON이 의존성에 들어있다.<br>즉, Json 용 HTTP 메시지 컨버터가 기본으로 등록되어 있다.  </li>
</ul>
</li>
<li><p>XML 용 메시지컨버터<br> OXM 라이브러리 중 스프링이 지원하는 의존성 추가(JacksonXML, JAXB)<br> 스프링 부트를 사용하더라도 기본적으로 XML 의존성을 추가해주지 않는다.  </p>
</li>
</ul>
<p>JAXB 의존성 추가</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;javax.xml.bind&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jaxb-api&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.glassfish.jaxb&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jaxb-runtime&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-oxm&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;$&#123;spring-framework.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<p>Marshaller 빈 추가<br>XmlRootElement를 스캔할 수 있도록 setPackagesToScan 설정 필요</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public Jaxb2Marshaller jaxb2Marshaller() &#123;</span><br><span class="line">    Jaxb2Marshaller jaxb2Marshaller &#x3D; new Jaxb2Marshaller();</span><br><span class="line">    jaxb2Marshaller.setPackagesToScan(Person.class.getPackageName());</span><br><span class="line">    return jaxb2Marshaller;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>객체를 Json String으로 만들기</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">ObjectMapper objectmapper;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void jsonString() throws JsonProcessingException &#123;</span><br><span class="line">    Person person &#x3D; new Person();</span><br><span class="line">    person.setId(99L);</span><br><span class="line">    person.setName(&quot;이정인&quot;);</span><br><span class="line"></span><br><span class="line">    String jsonString &#x3D; objectMapper.writeValueAsString(person);</span><br><span class="line"></span><br><span class="line">    ~</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>객체를 XML String으로 만들기</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">Marshaller marshaller;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void xmlString() throws JAXBException &#123;</span><br><span class="line">    Person person &#x3D; new Person();</span><br><span class="line">    person.setId(99L);</span><br><span class="line">    person.setName(&quot;이정인&quot;);</span><br><span class="line"></span><br><span class="line">    StringWriter stringWriter &#x3D; new StringWriter();</span><br><span class="line">    Result result &#x3D; new StreamResult(stringWriter);</span><br><span class="line">    marshaller.marshal(person, result);</span><br><span class="line">    String xmlString &#x3D; stringWriter.toString();</span><br><span class="line">   </span><br><span class="line">    ~</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>테스트에서는 jsonPath 또는 xPath로 응답 본문을 체크할 수 있다.</p>
<h4 id="기타-설정"><a href="#기타-설정" class="headerlink" title="기타 설정"></a>기타 설정</h4><ul>
<li>기본 제공 외의 ReturnValueHandler 추가 </li>
<li>기본 제공 외의 ArgumentResolver 추가</li>
<li>뷰 컨트롤러 설정, 단순하게 요청 URL을 특정 뷰로 연결하고 싶을 때 사용</li>
<li>비동기 설정, 비동기 요청 처리에 사용할 타임아웃이나 TaskExecutor 설정</li>
<li>Content Negotiation 설정, 요청 본문 또는 응답 본문을 어떤 타입으로 보내야 하는지의 전략 설정</li>
<li>CORS 설정, Cross Origin 요청 처리 설정, 같은 도메인에서 온 요청이 아니더라도 처리를 허용하고 싶을 때</li>
<li>뷰 리졸버 설정, 핸들러에서 리턴하는 뷰 이름에 해당하는 문자열을 View 인스턴스로 바꿔줄 뷰 리졸버 설정 </li>
</ul>
<h3 id="스프링-부트의-스프링-MVC-설정"><a href="#스프링-부트의-스프링-MVC-설정" class="headerlink" title="스프링 부트의 스프링 MVC 설정"></a>스프링 부트의 스프링 MVC 설정</h3><p>추가적인 전략이 자동으로 DispatcherServlet에 추가된다.  </p>
<ul>
<li><p>handlerMapping  </p>
<ul>
<li>resourceHandlerMapping(SimpleUrlHandlerMapping) 추가, 정적 resource 지원, 캐싱관련 정보가 응답 헤더에 추가됨</li>
<li>welcomePageHandlerMapping(WelcomePageHandlerMapping) 추가, 인덱스 페이지 지원  </li>
</ul>
</li>
<li><p>viewResolver  </p>
<ul>
<li>ContentNegotiatingViewResolver, 다른 viewResolver에 작업 위임하는 역할  </li>
</ul>
</li>
</ul>
<p>스프링 부트에서는 spring-boot-autoconfigure jar의 META-INF/spring-factories 파일에서 다양한 자동 설정을 확인할 수 있고<br>그 중 DispatcherServletAutoConfiguration은 DispatcherServlet을 자동으로 만드는 코드,<br>WebMvcAutoConfiguration은 Spring MVC를 자동으로 설정하는 코드이다.  </p>
<h4 id="스프링-부트의-프로퍼티-변경"><a href="#스프링-부트의-프로퍼티-변경" class="headerlink" title="스프링 부트의 프로퍼티 변경"></a>스프링 부트의 프로퍼티 변경</h4><p>application.properties</p>
<h4 id="스프링-부트가-지원하는-스프링-MVC-설정을-사용하면서-추가-설정을-원하는-경우"><a href="#스프링-부트가-지원하는-스프링-MVC-설정을-사용하면서-추가-설정을-원하는-경우" class="headerlink" title="스프링 부트가 지원하는 스프링 MVC 설정을 사용하면서 추가 설정을 원하는 경우"></a>스프링 부트가 지원하는 스프링 MVC 설정을 사용하면서 추가 설정을 원하는 경우</h4><p>@Configuration + implements WebMvcConfigurer</p>
<h4 id="스프링-부트가-지원하는-스프링-MVC-설정을-사용하고-싶지-않은-경우"><a href="#스프링-부트가-지원하는-스프링-MVC-설정을-사용하고-싶지-않은-경우" class="headerlink" title="스프링 부트가 지원하는 스프링 MVC 설정을 사용하고 싶지 않은 경우"></a>스프링 부트가 지원하는 스프링 MVC 설정을 사용하고 싶지 않은 경우</h4><p>@Configuration + @EnableWebMvc  </p>
<p>@EnableWebMvc에서 사용하는 DelegatingWebMvcConfiguration.class는 WebMvcConfigurationSupport.class를 상속받는데,<br>스프링 부트는 WebMvcConfigurationSupport.class 타입의 빈이 있으면 스프링 MVC 자동 설정을 스킵하기 때문이다.<br>(추가로 커스터마이징까지 하려면 @Configuration + implements WebMvcConfigurer + @EnableWebMvc)</p>
<p>참고로 스프링 부트에서는 Formatter나 Converter를 추가할 때 빈으로만 등록하면 알아서 추가해준다.  </p>
]]></content>
      <categories>
        <category>Study</category>
        <category>Spring Framework</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Spring MVC</tag>
      </tags>
  </entry>
  <entry>
    <title>스프링 부트의 원리</title>
    <url>/2020/09/22/hexo_springboot_project_01/</url>
    <content><![CDATA[<img src="/img/springboot.png" class="img_class" width="400" height="200" title="spring-boot">
<h2 id="스프링-부트의-원리"><a href="#스프링-부트의-원리" class="headerlink" title="스프링 부트의 원리"></a>스프링 부트의 원리</h2><h3 id="의존성-관리"><a href="#의존성-관리" class="headerlink" title="의존성 관리"></a>의존성 관리</h3><p>spring-boot-parent POM의 부모인 spring-boot-dependencies에는<br>dependencyManagement로 여러 의존성에 대한 버전을 정해주고 있다.<br>이를 통해서 의존성을 추가할 때 버전에 정보를 직접 기입하지 않더라도<br>사용하는 spring boot의 버전에 맞는 의존성 버전이 선택된다.  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependencyManagement&gt;</span><br><span class="line">  &lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.apache.activemq&lt;&#x2F;groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;activemq-amqp&lt;&#x2F;artifactId&gt;</span><br><span class="line">      &lt;version&gt;$&#123;activemq.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">...</span><br><span class="line">&lt;&#x2F;dependencyManagement&gt;</span><br></pre></td></tr></table></figure>

<h3 id="의존성-관리-응용-Maven"><a href="#의존성-관리-응용-Maven" class="headerlink" title="의존성 관리 응용 (Maven)"></a>의존성 관리 응용 (Maven)</h3><p>spring-boot-data-jpa 의존성 추가하기<br>버전을 명시하지 않아도 된다.  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>
<p>만약 버전을 명시하면 spring-boot-dependencies POM의 버전 정보를 무시하고<br>명시된 버전으로 의존성이 추가된다.<br>당연히 spring boot가 관리해주는 의존성이 아닌경우에는<br>버전까지 명시를 해주는 것이 좋다.  </p>
<p>만약 spring boot가 관리해주는 기본 의존성 버전을 바꾸고 싶은 경우 프로퍼티를 추가할 수 있다.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;properties&gt;</span><br><span class="line">    &lt;spring-framework.version&gt;5.2.6.RELEASE&lt;&#x2F;spring-framework.version&gt;</span><br><span class="line">&lt;&#x2F;properties&gt;</span><br></pre></td></tr></table></figure>

<h3 id="자동-설정의-이해"><a href="#자동-설정의-이해" class="headerlink" title="자동 설정의 이해"></a>자동 설정의 이해</h3><p>@SpringBootApplication 애노테이션은 크게 3가지 역할을 한다.</p>
<ul>
<li>@SpringBootConfiguration(@Configuration 역할)</li>
<li>@ComponentScan</li>
<li>@EnableAutoConfiguration</li>
</ul>
<p>@EnableAutoConfiguration은 @ComponentScan으로 찾아진 빈이 등록된 뒤에<br>여러가지 필요한 빈들을 추가로 등록한다.  </p>
<p>@EnableAutoConfiguration 애노테이션이 있는<br>spring-boot-autoconfigure 프로젝트의 META 데이터에는<br>spring.factories라는 파일이 존재하는데,<br>이 파일을 통해 @EnableAutoConfiguration를 사용했을 때 어떤 @Configuraton 들이 적용될 지 알 수 있다.    </p>
<h3 id="자동-설정-만들기"><a href="#자동-설정-만들기" class="headerlink" title="자동 설정 만들기"></a>자동 설정 만들기</h3><p>자동 설정을 제공할 패키지를 포함시킬 프로젝트를 생성한다.  </p>
<ul>
<li>Xxx-Spring-Boot-AutoConfigure<br>자동 설정을 등록할 모듈</li>
<li>Xxx-Spring-Boot-Starter<br>의존성 정의용 모듈 (자동 설정 등록을 여기에해서 하나만 만들수 도 있다.)</li>
</ul>
<p>의존성 추가 및 버전 정보를 가져오기 위해 dependencyManagement 추가</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-autoconfigure&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-autoconfigure-processor&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;optional&gt;true&lt;&#x2F;optional&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;&#x2F;dependencies&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependencyManagement&gt;</span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-dependencies&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.3.3.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">            &lt;type&gt;pom&lt;&#x2F;type&gt;</span><br><span class="line">            &lt;scope&gt;import&lt;&#x2F;scope&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;&#x2F;dependencies&gt;</span><br><span class="line">&lt;&#x2F;dependencyManagement&gt;</span><br></pre></td></tr></table></figure>

<p>다른 프로젝트에서 사용될 Java 설정 파일을 이 프로젝트에서 작성한다.  </p>
<p>classpath:/META-INF/spring.factories 파일을 만들고 설정 파일을 명시해준다.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration&#x3D;\</span><br><span class="line">  com.rockintuna.FishConfiguration</span><br></pre></td></tr></table></figure>

<p>다른 프로젝트에서 사용할 수 있도록 로컬 메이븐 저장소에 설치</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mvc install</span><br></pre></td></tr></table></figure>

<p>자동 설정을 사용할 프로젝트에서 의존성 추가</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.rockintuna&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;rockintuna-spring-boot-starter&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<p>만약 자동 설정을 사용하는 프로젝트에서 설정을 재정의할 필요가 있을 때는,<br>설정 파일을 만들 때 Condition으로 조건을 주어야 한다.  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class FishConfiguration &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    @ConditionalOnMissingBean</span><br><span class="line">    public Fish fish() &#123;</span><br><span class="line">        Fish fish &#x3D; new Fish();</span><br><span class="line">        fish.setName(&quot;tuna&quot;);</span><br><span class="line">        return fish;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>여기서는 @ConditionalOnMissingBean을 적용하지 않으면 다른 프로젝트에서 이 빈을 재정의 할 수 없는데,<br>빈 등록 순서가 ComponentScan -&gt; @EnableAutoConfiguration인 것 처럼,<br>재정의(ComponentScan)를 마친 후에 @EnableAutoConfiguration에 의해 재정의된 설정이 덮어씌여지기 때문이다.  </p>
<p>빈을 등록하여 설정을 재정의하는 방법이 있지만, 좀더 편하게 재정의할 수 있도록 프로퍼티를 사용할 수 있다.  </p>
<p>자동 설정 프로젝트에 프로퍼티 클래스 추가<br>@ConfigurationProperties(“{prefix}”)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@ConfigurationProperties(&quot;fish&quot;)</span><br><span class="line">public class FishProperties &#123;</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>설정에서 해당 프로퍼티를 사용하도록 등록</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableConfigurationProperties(FishProperties.class)</span><br><span class="line">public class FishConfiguration &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    @ConditionalOnMissingBean</span><br><span class="line">    public Fish fish(FishProperties properties) &#123;</span><br><span class="line">        Fish fish &#x3D; new Fish();</span><br><span class="line">        fish.setName(properties.getName());</span><br><span class="line">        return fish;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>설정을 사용하는 프로젝트에서는 application.properties를 통해 쉽게 재정의할 수 있다.<br>{prefix}.{property}={value}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fish.name&#x3D;참치</span><br></pre></td></tr></table></figure>

<h3 id="내장-웹-서버-이해"><a href="#내장-웹-서버-이해" class="headerlink" title="내장 웹 서버 이해"></a>내장 웹 서버 이해</h3><p>스프링부트 자동 설정을 사용하지 않으면 서블릿 웹 서버 사용을 위한 작업이 필요하다.<br>(톰캣 객체 생성, 컨택스트와 서블릿 추가 및 맵핑, 등등..)<br>스프링부트는 내장 웹 서버를 사용하며 서블릿 컨테이너와 관련된 일련의 설정들이 자동으로 이루어진다.  </p>
<ul>
<li><p>ServletWebServerFactoryAutoConfiguration<br>서블릿 웹 서버 생성 자동 설정</p>
<ul>
<li>ServletWebServerFactoryCustomizer<br>웹 서버 커스터마이징</li>
</ul>
</li>
<li><p>DispatcherServletAutoConfiguration<br>DispatcherServlet 생성 및 서블릿 컨테이너에 등록 자동 설정 </p>
</li>
</ul>
<h3 id="내장-웹-서버-응용"><a href="#내장-웹-서버-응용" class="headerlink" title="내장 웹 서버 응용"></a>내장 웹 서버 응용</h3><h4 id="다른-서블릿-컨테이너로-변경하기"><a href="#다른-서블릿-컨테이너로-변경하기" class="headerlink" title="다른 서블릿 컨테이너로 변경하기"></a>다른 서블릿 컨테이너로 변경하기</h4><p>스프링부트의 기본 서블릿 컨테이너 tomcat 대신 jetty 사용하기</p>
<p>tomcat 의존성 제외하고 jetty 의존성 추가</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;exclusions&gt;</span><br><span class="line">        &lt;exclusion&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-tomcat&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;exclusion&gt;</span><br><span class="line">    &lt;&#x2F;exclusions&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot &lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-jetty&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>


<h4 id="웹-서버-사용하지-않기"><a href="#웹-서버-사용하지-않기" class="headerlink" title="웹 서버 사용하지 않기"></a>웹 서버 사용하지 않기</h4><p>웹 어플리케이션 설정 변경</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">&#x2F;&#x2F;        SpringApplication.run(SpringBootStartApplication.class, args);</span><br><span class="line">        SpringApplication application &#x3D; new SpringApplication(SpringBootStartApplication.class);</span><br><span class="line">        application.setWebApplicationType(WebApplicationType.NONE);</span><br><span class="line">        application.run(args);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>또는 프로퍼티를 사용하여 변경</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring.main.web-application-type&#x3D;none</span><br></pre></td></tr></table></figure>

<h4 id="포트-변경하기"><a href="#포트-변경하기" class="headerlink" title="포트 변경하기"></a>포트 변경하기</h4><p>프로퍼티를 사용하여 변경</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server.port&#x3D;8090</span><br></pre></td></tr></table></figure>
<p>랜덤 포트 사용하기</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server.port&#x3D;0</span><br></pre></td></tr></table></figure>

<h3 id="내장-웹-서버에-HTTPS-또는-HTTP2-적용"><a href="#내장-웹-서버에-HTTPS-또는-HTTP2-적용" class="headerlink" title="내장 웹 서버에 HTTPS 또는 HTTP2 적용"></a>내장 웹 서버에 HTTPS 또는 HTTP2 적용</h3><h4 id="HTTPS-설정"><a href="#HTTPS-설정" class="headerlink" title="HTTPS 설정"></a>HTTPS 설정</h4><p>keytool 명령을 이용한 키스토어 생성<br><a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/keytool.html#CHDBGFHE" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/technotes/tools/unix/keytool.html#CHDBGFHE</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">keytool -genkey -alias tomcat -storetype PKCS12 -keyalg RSA -keysize 2048 -keystore keystore.p12 -validity 4000</span><br></pre></td></tr></table></figure>

<p>프로퍼티 설정</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server.ssl.key-store&#x3D;keystore.p12</span><br><span class="line">server.ssl.key-store-password&#x3D;123456</span><br><span class="line">server.ssl.key-store-type&#x3D;PKCS12</span><br><span class="line">server.ssl.key-alias&#x3D;tomcat</span><br></pre></td></tr></table></figure>

<p>HTTP용 커넥터를 추가하여 HTTP와 같이 사용할 수도 있다.</p>
<h4 id="HTTP2-설정"><a href="#HTTP2-설정" class="headerlink" title="HTTP2 설정"></a>HTTP2 설정</h4><p>프로퍼티 설정</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server.http2.enabled&#x3D;true</span><br></pre></td></tr></table></figure>

<p>톰캣 8.5.x 에서는 추가적인 설정이 필요하지만<br>9.0.x / JDK9 에서는 추가 설정이 필요없다.<br><a href="https://docs.spring.io/spring-boot/docs/2.0.0.M6/reference/html/howto-embedded-web-servers.html" target="_blank" rel="noopener">https://docs.spring.io/spring-boot/docs/2.0.0.M6/reference/html/howto-embedded-web-servers.html</a></p>
<h3 id="독립적으로-실행-가능한-JAR"><a href="#독립적으로-실행-가능한-JAR" class="headerlink" title="독립적으로 실행 가능한 JAR"></a>독립적으로 실행 가능한 JAR</h3><p>기본적으로 Java에는 Jar에 있는 내장 Jar를 로딩할 수 있는 표준이 없다.<br>때문에 과거에는 모든 Jar를 하나로 만드는 Uber Jar를 사용했었는데,<br>어떤 라이브러리를 쓰는 것인지 불분명해지고 동일한 이름의 파일이 있을 때의 문제가 있었다.  </p>
<p>스프링부트에서는 애플리케이션 클래스와 라이브러리가 구분되어 있으며<br>패키징 후에 내장 Jar 읽고 실행하는 역할을 하는 클래스가 추가된다.<br>spring-boot-maven-plugin이 패키징을 담당한다.<br>org.springframework.boot.loader.jar.JarFile (읽기)<br>org.springframework.boot.loader.Launcher (실행)  </p>
<p>mvc package 명령어를 통해 실행 가능한 JAR 파일 하나가 생성된다.  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mvc package</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -jar spring-boot-start-0.0.1-SNAPSHOT.jar</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Study</category>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Spring Boot</tag>
        <tag>Dependency</tag>
        <tag>EnableAutoConfiguration</tag>
      </tags>
  </entry>
  <entry>
    <title>스프링 부트 활용 (기술 연동)</title>
    <url>/2020/10/07/hexo_springboot_project_03/</url>
    <content><![CDATA[<img src="/img/springboot.png" class="img_class" width="430" height="270" title="spring-boot">
<h2 id="스프링-부트-활용-기술-연동"><a href="#스프링-부트-활용-기술-연동" class="headerlink" title="스프링 부트 활용 (기술 연동)"></a>스프링 부트 활용 (기술 연동)</h2><h3 id="스프링-웹-MVC"><a href="#스프링-웹-MVC" class="headerlink" title="스프링 웹 MVC"></a>스프링 웹 MVC</h3><p>스프링 부트 MVC는 자동 설정(WebMvcAutoConfiguration)을 통해 여러 기본 기능을 제공한다.  </p>
<p>스프링 MVC 기능 확장하기</p>
<ul>
<li>@Configuration + WebMvcConfigurer</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class WebConfig implements WebMvcConfigurer &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>스프링 MVC 기능 재정의하기</p>
<ul>
<li>@Configuration + @EnableWebMvc</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableWebMvc</span><br><span class="line">public class WebConfig implements WebMvcConfigurer &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="HttpMessageConverters"><a href="#HttpMessageConverters" class="headerlink" title="HttpMessageConverters"></a>HttpMessageConverters</h4><p>Http 요청 본문을 객체로 변경하거나, 객체를 Http 응답 본문으로 변경할 때 사용한다.<br>@RequestBody, @ResponseBody</p>
<p>관련 스프링 부트 자동 설정, HttpMessageConvertersAutoConfiguration에 의해<br>여러가지 응답 타입과 객체 간의 변환을 담당하는 메시지 컨버터가 자동으로 설정 되어있다.</p>
<h4 id="ViewResolver"><a href="#ViewResolver" class="headerlink" title="ViewResolver"></a>ViewResolver</h4><p>스프링 부트의 ContentNegotiatingViewResolver는<br>요청 header의 accept에 해당하는 타입에 따라 서로 다른 응답을 제공하며<br>ViewResolver에 작업을 위임한다.</p>
<h4 id="정적-리소스-지원"><a href="#정적-리소스-지원" class="headerlink" title="정적 리소스 지원"></a>정적 리소스 지원</h4><p>스프링 부트는 정적 리소스를 맵핑해주는 리소스 핸들러를 기본적으로 제공한다.<br>(ResourceHttpRequestHandler)</p>
<p>프로퍼티를 통해 추가 설정<br>spring.mvc.static-path-pattern : 맵핑 패턴 변경<br>spring.mvc.static-locations : 리소스를 찾는 기본 위치 변경</p>
<p>WebMvcConfigurer의 addResourceHandlers로 커스터마이징</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void addResourceHandlers(ResourceHandlerRegistry registry) &#123;</span><br><span class="line">    registry.addResourceHandler(&quot;&#x2F;s&#x2F;**&quot;)</span><br><span class="line">            .addResourceLocations(&quot;classpath:&#x2F;s&#x2F;&quot;)</span><br><span class="line">            .setCachePeriod(20);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>정적 리소스의 변경 여부에 따라 이미 캐싱되어있는 리소스를 사용하면 http code 304를 리턴한다.</p>
<h4 id="웹-Jar"><a href="#웹-Jar" class="headerlink" title="웹 Jar"></a>웹 Jar</h4><p>기본적으로 웹 Jar에 대한 기본 리소스 리졸버를 제공하여<br>“/webjars/**” 맵핑. </p>
<p>webjars-locator-core 의존성을 추가하여 버전을 생략할 수도 있다.</p>
<h4 id="index-페이지와-파비콘"><a href="#index-페이지와-파비콘" class="headerlink" title="index 페이지와 파비콘"></a>index 페이지와 파비콘</h4><p>웰컴 페이지 :<br>기본 리소스 위치에서 index.html/index.템플릿 을 찾아서 사용</p>
<p>파비콘 : 브라우저에서 사용되는 아이콘<br>favicon.ico 파일을 리소스 위치에 생성(favicon.io에서 만들 수 있다.)  </p>
<h4 id="템플릿-엔진"><a href="#템플릿-엔진" class="headerlink" title="템플릿 엔진"></a>템플릿 엔진</h4><p>스프링 부트가 템플릿 엔진의 자동 설정을 지원<br>(FreeMarker, Groovy, Thymeleaf, Mustache)<br>특히, 서블릿 엔진과 독립적으로 동작하기 때문에 테스트 할 때 좋다.  </p>
<p>JSP는 권장하지 않는다. (JAR 패키징 불가 및 Undertow 미지원 등등)</p>
<p>Thymeleaf 의존성 추가</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<p>Thymeleaf view 작성  </p>
<p>name space 추가</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;html lang&#x3D;&quot;en&quot; xmlns:th&#x3D;&quot;http:&#x2F;&#x2F;www.thymeleaf.org&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>Model Attribute 랜더링 방법</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$&#123;...&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot; xmlns:th&#x3D;&quot;http:&#x2F;&#x2F;www.thymeleaf.org&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Hello&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1 th:text&#x3D;&quot;$&#123;name&#125;&quot;&gt;Name&lt;h1&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>

<h4 id="ExceptionHandler"><a href="#ExceptionHandler" class="headerlink" title="ExceptionHandler"></a>ExceptionHandler</h4><p>스프링 부트는 기본적인 예외 처리기를 지원한다.  </p>
<ul>
<li>BasicErrorController : HTML과 Json 응답 지원, ErrorController를 구현하여 커스터마이징 할 수 있다.</li>
</ul>
<p>커스텀 에러 페이지<br>classpath:/static|templetes/error 에 {code}.html 생성</p>
<p>404.html : 404 error 발생 시 이 뷰로 처리<br>4xx.html : 400번대 error 발생 시 이 뷰로 처리<br>ErrorViewResolver를 구현하면 좀더 구체적으로 커스터마이징 할 수 있다.  </p>
<h4 id="Spring-HATEOAS"><a href="#Spring-HATEOAS" class="headerlink" title="Spring HATEOAS"></a>Spring HATEOAS</h4><p>Hypermedia As The Engine Of Application Status</p>
<ul>
<li>서버 : 현재 리소스와 연관된 링크 정보를 클라이언트에 제공한다.</li>
<li>클라이언트 : 연관된 링크 정보를 바탕으로 리소스에 접근한다.</li>
<li>연관된 링크 정보 : Relation, Hypertext Reference</li>
</ul>
<p>스프링 부트는 HATEOAS에 대한 자동 설정을 지원한다.</p>
<p>의존성 추가</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-hateoas&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<p>리소스에 링크 추가하기</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@GetMapping(&quot;&#x2F;hello&quot;)</span><br><span class="line">public EntityModel&lt;Sample&gt; hello() &#123;</span><br><span class="line">    Sample sample &#x3D; new Sample();</span><br><span class="line">    sample.setName(&quot;jilee&quot;);</span><br><span class="line">    sample.setPrefix(&quot;Hi&quot;);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;hateoas.EntityModel을 이용한 링크 정보 (rel:self) 추가</span><br><span class="line">    EntityModel&lt;Sample&gt; sampleEntityModel &#x3D; new EntityModel&lt;&gt;(sample);</span><br><span class="line">    sampleEntityModel.add(linkTo(methodOn(SampleController.class).hello()).withSelfRel());</span><br><span class="line"></span><br><span class="line">    return sampleEntityModel;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h4><p>Cross-Origin Resource Sharing :<br>서로 다른 Origin 사이에서 Resource를 공유하기위한 표준 기술 (&lt;-&gt; SOP(기본))</p>
<p>Origin ? </p>
<ul>
<li>URL 스키마 (http, https)</li>
<li>hostname</li>
<li>포트</li>
</ul>
<p>스프링 부트에서 제공하는 @CrossOrigin 애노테이션을 이용할 수 있다.<br>@Controller 또는 @RequestMapping에 추가하여 사용하거나,<br>WebMvcConfigurer에서 글로벌 설정한다.  </p>
<p>모든 컨트롤러에 대한 CORS 설정</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void addCorsMappings(CorsRegistry registry) &#123;</span><br><span class="line">    registry.addMapping(&quot;&#x2F;**&quot;)</span><br><span class="line">            .allowedOrigins(&quot;http:&#x2F;&#x2F;localhost:18080&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="스프링-데이터"><a href="#스프링-데이터" class="headerlink" title="스프링 데이터"></a>스프링 데이터</h3><h4 id="Spring-JDBC"><a href="#Spring-JDBC" class="headerlink" title="Spring JDBC"></a>Spring JDBC</h4><p>스프링 부트는 Spring JDBC가 classpath에 있으면 자동 설정에 의하여 빈을 설정한다.<br>DataSource, JdbcTemplete</p>
<p>의존성 추가</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-jdbc&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<p>DataSource는 DB에 access하거나 DB의 메타데이터를 확인할 수 있다.  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class DataTestRunner implements ApplicationRunner &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private DataSource dataSource;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run(ApplicationArguments args) throws Exception &#123;</span><br><span class="line">        try(Connection connection &#x3D; dataSource.getConnection()) &#123;</span><br><span class="line">            System.out.println(connection.getMetaData().getURL());</span><br><span class="line">            System.out.println(connection.getMetaData().getUserName());</span><br><span class="line"></span><br><span class="line">            String sql &#x3D; &quot;create table test (id int, name varchar(30));&quot;;</span><br><span class="line">            Statement statement &#x3D; connection.createStatement();</span><br><span class="line">            statement.executeUpdate(sql);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JdbcTemplete는 SQL을 작성할 때 좀더 간결하고 안전하게 할 수 있다.  </p>
<p>인메모리 지원 DB(H2, HSQL, Derby)가 의존성에 존재하고 별도의 DataSource 설정을 하지 않았을 때,<br>스프링 부트는 자동 설정에 의해 embeded 인메모리 DB를 사용한다.</p>
<h4 id="DBCP"><a href="#DBCP" class="headerlink" title="DBCP"></a>DBCP</h4><p>DataBase Connection Pool</p>
<p>스프링 부트는 기본적으로 HikariCP DBCP를 지원한다.<br>DBCP는 Connection에 대한 여러가지 설정을 할 수 있다. (autoCommit, connectionTimeout, maximumPoolSize, …)<br>spring.datasource.hikari.*</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring.datasource.hikari.maximum-pool-size&#x3D;4</span><br></pre></td></tr></table></figure>

<h4 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h4><p>MySQL Connector 의존성 추가</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;scope&gt;runtime&lt;&#x2F;scope&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<p>MySQL Datasource 설정 (application.properties)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring.datasource.url&#x3D;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;test?serverTimezone&#x3D;UTC</span><br><span class="line">spring.datasource.username&#x3D;todolist</span><br><span class="line">spring.datasource.password&#x3D;password</span><br></pre></td></tr></table></figure>
<p>MySQL은 기본적으로 3306 port를 사용한다.  </p>
<h4 id="Spring-Data-JPA"><a href="#Spring-Data-JPA" class="headerlink" title="Spring-Data-JPA"></a>Spring-Data-JPA</h4><p>의존성을 추가하면 스프링 부트는 JPA와 관련된 자동 설정을 한다.  </p>
<p>ORM(Object-Relation Mapping) : 객체와 릴레이션을 맵핑할 때 발생하는 개념적 불일치를 해결하는 프레임워크<br>JPA(Java Persistence API) : ORM을 위한 Java EE 표준<br>Hibernate : 대표적인 JPA 구현체</p>
<p>Spring Data JPA : JPA 표준 스팩을 아주 쉽게 사용할 수 있게끔 추상화 함.  </p>
<ul>
<li>Repository 빈 자동 생성</li>
<li>쿼리 메서드 자동 구현</li>
<li>@EnableJpaRepository (스프링 부트는 자동으로 설정됨)</li>
</ul>
<p>Spring Data JPA -&gt; JPA -&gt; Hibernate -&gt; Datasource(JDBC)</p>
<p>JPA 의존성 추가</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<p>Repository 만들기 (extends JpaRepository&lt;”Entity type”,”ID type”&gt;)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface UserRepository extends JpaRepository&lt;User,Long&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@DataJpaTest : JPA 관련 슬라이싱 테스트, embedded DB만 지원한다.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@DataJpaTest</span><br><span class="line">class UserRepositoryTest &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    DataSource dataSource;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    UserRepository userRepository;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void getMetaInfo() &#123;</span><br><span class="line">        User user &#x3D; new User();</span><br><span class="line">        user.setName(&quot;tester&quot;);</span><br><span class="line">        user.setEmail(&quot;tester@email.com&quot;);</span><br><span class="line">        user.setPassword(&quot;password&quot;);</span><br><span class="line"></span><br><span class="line">        User savedUser &#x3D; userRepository.save(user);</span><br><span class="line">        assertThat(savedUser.getName()).isEqualTo(&quot;tester&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="데이터베이스-초기화"><a href="#데이터베이스-초기화" class="headerlink" title="데이터베이스 초기화"></a>데이터베이스 초기화</h4><p>JPA를 이용한 DB 초기화 관련 프로퍼티<br>spring.jpa.hibernate.ddl-auto</p>
<ul>
<li>update : 변경된 스키마(alter table)나 추가된 스키마(create table)만 새로 생성, 기존 데이터 유지</li>
<li>create : App 실행시 기존 스키마를 지우고 새로 생성</li>
<li>create-drop : App 종료시 스키마 제거</li>
<li>none : ddl 핸들링 끄기 (아무런 작업도 하지 않음)</li>
<li>validate : Entity와 DB의 테이블 사이의 맵핑을 검증 (운영에서 사용)</li>
</ul>
<p>spring.jpa.generate-ddl</p>
<ul>
<li>false : 초기화 설정 종료</li>
<li>true : App 실행시 @Entity에 근거하여 DDL문을 생성하고 실행한다.<br>true로 설정해야 ddl-auto 설정이 동작한다.</li>
</ul>
<p>spring.jpa.show-sql=true : SQL 출력</p>
<p>SQL 스크립트를 사용한 DB 초기화</p>
<ul>
<li>schema.sql 또는 schema-${platform}.sql : App 실행시 스키마 작업</li>
<li>data.sql 또는 data-${platform}.sql : App 실행시 데이터 작업</li>
<li>${platform} 값은 spring.datasource.platform 으로 설정 가능</li>
</ul>
<h3 id="스프링-시큐리티"><a href="#스프링-시큐리티" class="headerlink" title="스프링 시큐리티"></a>스프링 시큐리티</h3><h4 id="스프링-부트-시큐리티-자동-설정"><a href="#스프링-부트-시큐리티-자동-설정" class="headerlink" title="스프링 부트 시큐리티 자동 설정"></a>스프링 부트 시큐리티 자동 설정</h4><p>dependency</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-security&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<p>스프링 시큐리티 관련 자동 설정</p>
<ul>
<li>SecurityAutoConfiguration (스프링 시큐리티 자동 설정)</li>
<li>UserDetailsServiceAutoConfiguration (기본 사용자 생성)</li>
<li>DefaultAuthenticationEventPublisher 빈 등록, 다양한 인증 에러 핸들러 등록 가능</li>
</ul>
<p>의존성을 추가하면 자동 설정에 의해 모든 요청이 인증(Authorization)을 요구하게 된다.<br>(사실은 부트의 자동 설정이 WebSecurityConfigurerAdapter(스프링 시큐리티의 기본 설정 클리스)의<br>설정을 그대로 사용하기 때문이다.)<br>또한 인증 가능한 정보(user/generated security password)와 login 페이지를 제공한다.<br>또는 프로퍼티로 수정한다.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring.security.user.name</span><br><span class="line">spring.security.user.password</span><br></pre></td></tr></table></figure>

<p>기본적으로 Basic 인증과 폼 인증이 둘 다 적용되는데, 요청의 accept 헤더에 따라 응답이 달라진다.<br>(ex) text/html -&gt; 폼 인증 (“redirect:/login”)</p>
<h4 id="스프링-시큐리티-테스트"><a href="#스프링-시큐리티-테스트" class="headerlink" title="스프링 시큐리티 테스트"></a>스프링 시큐리티 테스트</h4><p>spring security test dependency</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.security&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-security-test&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;$&#123;spring-security.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<p>@WithMockUser : 테스트 시 인증된 Mock User를 생성하여 테스트할 수 있다.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">@WithMockUser</span><br><span class="line">public void hello() throws Exception &#123;</span><br><span class="line">    mvc.perform(MockMvcRequestBuilders.get(&quot;&#x2F;hello&quot;))</span><br><span class="line">            .andDo(print())</span><br><span class="line">            .andExpect(status().isOk())</span><br><span class="line">            .andExpect(view().name(&quot;hello&quot;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="스프링-시큐리티-커스터마이징"><a href="#스프링-시큐리티-커스터마이징" class="headerlink" title="스프링 시큐리티 커스터마이징"></a>스프링 시큐리티 커스터마이징</h4><p>WebSecurityConfigurerAdapter 타입의 빈을 등록하면 부트의 스프링 시큐리티 자동 설정은 사용되지 않는다.  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class WebSecurityConfig extends WebSecurityConfigurerAdapter &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void configure(HttpSecurity http) throws Exception &#123;</span><br><span class="line">        http.authorizeRequests()</span><br><span class="line">                &#x2F;&#x2F; &quot;&#x2F;&quot;,&quot;&#x2F;hello&quot; 는 인증 없이 허가</span><br><span class="line">                .antMatchers(&quot;&#x2F;&quot;,&quot;hello&quot;).permitAll()</span><br><span class="line">                &#x2F;&#x2F; 그 외 다른 요청은 인증 필요 </span><br><span class="line">                .anyRequest().authenticated()</span><br><span class="line">                .and()</span><br><span class="line">                &#x2F;&#x2F;폼 로그인 사용 (accept html)</span><br><span class="line">                .formLogin()</span><br><span class="line">                .and()</span><br><span class="line">                &#x2F;&#x2F;httpBasic 사용 (not html)</span><br><span class="line">                .httpBasic();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>UserDetailsService 타입의 빈을 등록하면 부트의 기본 사용자 생성을 사용하지 않는다.  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class AccountService implements UserDetailsService &#123;</span><br><span class="line"></span><br><span class="line">    private AccountRepository accountRepository;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    public AccountService(AccountRepository accountRepository) &#123;</span><br><span class="line">        this.accountRepository &#x3D; accountRepository;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Account createUser(AccountDto accountDto) &#123;</span><br><span class="line">        if (accountRepository.findByEmail(accountDto.getEmail()) &#x3D;&#x3D; null) &#123;</span><br><span class="line">            Account account &#x3D; new Account(accountDto);</span><br><span class="line">            return accountRepository.save(account);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            throw new EmailExistException(&quot;이미 사용중인 Email 입니다.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public UserDetails loadUserByUsername(String name) throws UsernameNotFoundException &#123;</span><br><span class="line">        Optional&lt;Account&gt; byName &#x3D; accountRepository.findByName(name);</span><br><span class="line">        Account account &#x3D; byName.orElseThrow(() -&gt; new UsernameNotFoundException(name));</span><br><span class="line">        return new User(account.getName(), account.getPassword(), authorities());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Collection&lt;? extends GrantedAuthority&gt; authorities() &#123;</span><br><span class="line">        return Arrays.asList(new SimpleGrantedAuthority(&quot;ROLE_USER&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Password Encoding을 사용해야 한다.  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public PasswordEncoder passwordEncoder() &#123;</span><br><span class="line">    return PasswordEncoderFactories.createDelegatingPasswordEncoder();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="스프링-REST-클라이언트"><a href="#스프링-REST-클라이언트" class="headerlink" title="스프링 REST 클라이언트"></a>스프링 REST 클라이언트</h3><h4 id="RestTemplate"><a href="#RestTemplate" class="headerlink" title="RestTemplate"></a>RestTemplate</h4><p>Blocking I/O 기반의 Synchronous API<br>부트는 RestTemplateAutoConfiguration에 의해 spring-web 모듈이 있다면<br>RestTemplateBuilder를 빈으로 등록해준다.<br>기본적으로 java.net.HttpURLConnection을 사용한다.<br>RestTemplateCustomizer를 빈으로 등록하여 전역적으로 커스터마이징 할 수 있다.</p>
<h4 id="WebClient"><a href="#WebClient" class="headerlink" title="WebClient"></a>WebClient</h4><p>non-Blocking I/O 기반의 Asynchronous API<br>부트는 WebClientAutoConfiguration 의해 spring-webflux 모듈이 있다면<br>WebClient.Builder를 빈으로 등록해준다.<br>기본적으로 Reactor Netty의 HTTP 클라이언트를 사용한다.<br>WebClientCustomizer를 빈으로 등록하여 전역적으로 커스터마이징 할 수 있다.</p>
]]></content>
      <categories>
        <category>Study</category>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Spring Boot</tag>
        <tag>Spring Data JPA</tag>
        <tag>Spring Security</tag>
      </tags>
  </entry>
  <entry>
    <title>JPA (Java Persistence API)</title>
    <url>/2020/10/28/hexo_jpa_01/</url>
    <content><![CDATA[<img src="/img/jpa.png" class="img_class" width="340" height="160" title="jpa">
<h2 id="JPA-Java-Persistence-API"><a href="#JPA-Java-Persistence-API" class="headerlink" title="JPA (Java Persistence API)"></a>JPA (Java Persistence API)</h2><h3 id="JPA"><a href="#JPA" class="headerlink" title="JPA"></a>JPA</h3><p>자바 진영의 ORM 기술 표준</p>
<p>ORM?<br>(Object-Relational Mapping)<br>객체와 관계형 DB 사이에서 매핑하는 역할을 담당한다.<br>ORM을 통해 객체는 객체대로 DB는 DB대로 설계할 수 있다.  </p>
<ul>
<li>JPA의 핵심  <ul>
<li>SQL 생성 : 개발자의 SQL 작성에 대한 고충을 덜어준다.</li>
<li>JDBC 사용 : JPA도 결국은 JDBC API를 통해서 DB에 접근한다.</li>
<li>패러다임 불일치 해결 : 객체지향 프로그래밍과 관계형 데이터베이스 사이의 페러다임 불일치를 해결해준다.</li>
</ul>
</li>
</ul>
<p>JPA는 인터페이스의 모음이다.<br>개발자는 JPA 표준 인터페이스의 구현체를 사용하게 되는데,<br>특히 Hibernate를 사용하게 된다.  </p>
<p>JPA를 사용하면 일반적인 JDBC 프로그래밍에 비하여<br>생산성 향상, 유지보수성 향상, 패러다임 불일치 해결, 성능 향상을 기대할 수 있다.  </p>
<h3 id="체험하기"><a href="#체험하기" class="headerlink" title="체험하기"></a>체험하기</h3><h4 id="의존성"><a href="#의존성" class="headerlink" title="의존성"></a>의존성</h4><p>JPA 하이버네이트</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.hibernate&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;hibernate-entitymanager&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.4.21.Final&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>
<p>H2 데이터베이스</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.h2database&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;h2&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.4.200&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<h4 id="JPA-설정하기"><a href="#JPA-설정하기" class="headerlink" title="JPA 설정하기"></a>JPA 설정하기</h4><p>persistence.xml 파일을 통해 JPA를 설정할 수 있다.</p>
<p>JPA 버전 설정</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;persistence version&#x3D;&quot;2.2&quot;</span><br></pre></td></tr></table></figure>

<p>unit 이름으로 그룹화하여 각 속성을 설정할 수 있다.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;persistence-unit name&#x3D;&quot;hello&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>필수 :<br>JDBC 드라이버 설정,<br>DB USER/PASSWORD/URL 설정,<br>dialect 설정 (표준 SQL을 벗어난 특정 DB 문법)</p>
<p>옵션 :<br>SQL 보기,<br>SQL 포메팅,<br>SQL 주석 넣기, …</p>
<p>/META-INF/persistence.xml</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;persistence version&#x3D;&quot;2.2&quot;</span><br><span class="line">             xmlns&#x3D;&quot;http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;persistence&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">             xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;persistence http:&#x2F;&#x2F;java.sun.com&#x2F;xml&#x2F;ns&#x2F;persistence&#x2F;persistence_2_2.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;persistence-unit name&#x3D;&quot;hello&quot;&gt;</span><br><span class="line">        &lt;properties&gt;</span><br><span class="line">            &lt;property name&#x3D;&quot;javax.persistence.jdbc.driver&quot; value&#x3D;&quot;org.h2.Driver&quot;&#x2F;&gt;</span><br><span class="line">            &lt;property name&#x3D;&quot;javax.persistence.jdbc.user&quot; value&#x3D;&quot;sa&quot;&#x2F;&gt;</span><br><span class="line">            &lt;property name&#x3D;&quot;javax.persistence.jdbc.password&quot; value&#x3D;&quot;&quot;&#x2F;&gt;</span><br><span class="line">            &lt;property name&#x3D;&quot;javax.persistence.jdbc.url&quot; value&#x3D;&quot;jdbc:h2:~&#x2F;data&#x2F;test&quot;&#x2F;&gt;</span><br><span class="line">            &lt;property name&#x3D;&quot;hibernate.dialect&quot; value&#x3D;&quot;org.hibernate.dialect.H2Dialect&quot;&#x2F;&gt;</span><br><span class="line">            </span><br><span class="line">            &lt;property name&#x3D;&quot;hibernate.show_sql&quot; value&#x3D;&quot;true&quot;&#x2F;&gt;</span><br><span class="line">            &lt;property name&#x3D;&quot;hibernate.format_sql&quot; value&#x3D;&quot;true&quot;&#x2F;&gt;</span><br><span class="line">            &lt;property name&#x3D;&quot;hibernate.use_sql_comments&quot; value&#x3D;&quot;true&quot;&#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;properties&gt;</span><br><span class="line">    &lt;&#x2F;persistence-unit&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;persistence&gt;</span><br></pre></td></tr></table></figure>

<h4 id="코드에서-JPA-사용하기"><a href="#코드에서-JPA-사용하기" class="headerlink" title="코드에서 JPA 사용하기"></a>코드에서 JPA 사용하기</h4><p>EntityManagerFactory는 Application 구동시에 한번만 생성되도록 하고<br>EntityManager는 클라이언트의 요청마다 생성되도록 한다.<br>주의) EntityManager는 쓰레드간에 공유하면 안됨.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class JpaMain &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        EntityManagerFactory entityManagerFactory &#x3D; Persistence.createEntityManagerFactory(&quot;hello&quot;);</span><br><span class="line">        EntityManager entityManager &#x3D; entityManagerFactory.createEntityManager();</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;todo</span><br><span class="line"></span><br><span class="line">        entityManager.close();</span><br><span class="line">        entityManagerFactory.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="객체와-테이블-생성-및-맵핑"><a href="#객체와-테이블-생성-및-맵핑" class="headerlink" title="객체와 테이블 생성 및 맵핑"></a>객체와 테이블 생성 및 맵핑</h4><p>테이블 생성</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table Account (</span><br><span class="line">id bigint not null,</span><br><span class="line">name varchar(255),</span><br><span class="line">primary key(id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>Account 객체 생성<br>@Entity : JPA가 관리할 객체<br>@Id : 데이터베이스의 PK와 맵핑  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Entity</span><br><span class="line">public class Account &#123;</span><br><span class="line"></span><br><span class="line">    @Id</span><br><span class="line">    private Long id;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    public Long getId() &#123;</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setId(Long id) &#123;</span><br><span class="line">        this.id &#x3D; id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>만약 테이블 이름이나 컬럼 이름이 객체의 것과 다르다면<br>@Table 또는 @Column 어노테이션으로 직접 맵핑할 수 있다.  </p>
<h4 id="Data-변경-해보기"><a href="#Data-변경-해보기" class="headerlink" title="Data 변경 해보기"></a>Data 변경 해보기</h4><p>Data 변경 작업은 Transaction 생성과 시작, 종료(커밋 또는 롤백)가 필요하다.</p>
<p>Insert</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class JpaMain &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        EntityManagerFactory entityManagerFactory &#x3D; Persistence.createEntityManagerFactory(&quot;hello&quot;);</span><br><span class="line">        EntityManager entityManager &#x3D; entityManagerFactory.createEntityManager();</span><br><span class="line"></span><br><span class="line">        EntityTransaction transaction &#x3D; entityManager.getTransaction();</span><br><span class="line">        transaction.begin();</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            Account account &#x3D; new Account();</span><br><span class="line">            account.setId(1L);</span><br><span class="line">            account.setName(&quot;tester&quot;);</span><br><span class="line"></span><br><span class="line">            entityManager.persist(account);</span><br><span class="line"></span><br><span class="line">            transaction.commit();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            transaction.rollback();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            entityManager.close();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">       entityManagerFactory.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Update</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    Account account &#x3D; entityManager.find(Account.class, 1L);</span><br><span class="line">    account.setName(&quot;modified_name&quot;);</span><br><span class="line"></span><br><span class="line">    transaction.commit();</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">    transaction.rollback();</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    entityManager.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Update 같은 경우 find로 불러온 객체를 변경한 후 다시 persist()를 호출해서 저장하지 않아도 되는데,<br>이는 JPA가 트랜잭션 commit 시점에 변경된 객체를 감지하고 알아서 update 쿼리를 보내기 때문이다.  </p>
<h4 id="JPQL"><a href="#JPQL" class="headerlink" title="JPQL"></a>JPQL</h4><p>객체지향 쿼리로서 SQL과 유사하지만 같지는 않다.<br>JPQL은 테이블이 아닌 엔티티 객체를 대상으로 쿼리를 작성하게 된다.<br>JPQL의 from 절은 테이블이 아닌 객체가 온다.  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    List&lt;Account&gt; accountList &#x3D; entityManager.createQuery(&quot;select a from Account as a&quot;, Account.class)</span><br><span class="line">            .getResultList();</span><br><span class="line"></span><br><span class="line">    for(Account account : accountList) &#123;</span><br><span class="line">        System.out.println(account.getId());</span><br><span class="line">        System.out.println(account.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    transaction.commit();</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">    transaction.rollback();</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    entityManager.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Study</category>
        <category>JPA</category>
      </categories>
      <tags>
        <tag>Spring Data JPA</tag>
        <tag>JPA</tag>
        <tag>ORM</tag>
        <tag>Mapping</tag>
      </tags>
  </entry>
  <entry>
    <title>JPA 내부 구조</title>
    <url>/2020/10/28/hexo_jpa_02/</url>
    <content><![CDATA[<img src="/img/jpa.png" class="img_class" width="340" height="160" title="jpa">
<h2 id="JPA-내부-구조"><a href="#JPA-내부-구조" class="headerlink" title="JPA 내부 구조"></a>JPA 내부 구조</h2><h3 id="영속성-관리"><a href="#영속성-관리" class="headerlink" title="영속성 관리"></a>영속성 관리</h3><h4 id="영속성-컨텍스트"><a href="#영속성-컨텍스트" class="headerlink" title="영속성 컨텍스트"></a>영속성 컨텍스트</h4><p>JPA를 이해하는데 가장 중요한 용어<br>“엔티티를 영구 저장하는 환경”</p>
<p>영속성 컨텍스트는 논리적인 개념이며 눈에 보이지 않는다.<br>EntityManager를 이용하여 영속성 컨텍스트에 접근한다.  </p>
<p>J2SE 환경은 EntityManager와 영속성 컨텍스트가 1:1<br>J2EE,Spring framework 환경은 EntityManager와 영속성 컨텍스트가 N:1  </p>
<p>엔티티의 생명주기</p>
<ul>
<li>비영속(transient) : 영속성 컨텍스트와 전혀 관계없는 새로운 상태</li>
<li>영속(managed) : 영속성 컨텍스트에 관리되는 상태</li>
<li>준영속(detached) : 영속성 컨텍스트에 저장되었다가 분리된 상태</li>
<li>삭제(removed) : 삭제된 상태</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    &#x2F;&#x2F;transient</span><br><span class="line">    Account account &#x3D; new Account();</span><br><span class="line">    account.setName(&quot;tester&quot;);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;managed</span><br><span class="line">    entityManager.persist(account);</span><br><span class="line">    &#x2F;&#x2F;사실 persist()에서 DB에 저장되지는 않는다.</span><br><span class="line">    &#x2F;&#x2F;영속성 컨텍스트에 들어가게 된다.</span><br><span class="line">    &#x2F;&#x2F;insert는 commit 시점에 발생한다.</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;detached</span><br><span class="line">    entityManager.detach(account);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;removed</span><br><span class="line">    entityManager.remove(account);</span><br><span class="line"></span><br><span class="line">    transaction.commit();</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">    transaction.rollback();</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    entityManager.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>영속성 컨텍스트의 특징</p>
<ul>
<li><p>1차 캐시 :<br>영속 엔티티는 영속성 컨텍스트의 1차 캐시에 속하게 된다.<br>조회를 할때 DB에 접근하기 전에 이 캐시부터 조회하게 된다.<br>1차 캐시에 없어서 DB에 직접 접근하여 얻어진 엔티티도 영속 상태로 1차 캐시에 넣어둔다.</p>
</li>
<li><p>영속 엔티티의 동일성 보장 :<br>1차 캐시를 통해 Repeatable Read isolation level을 DB가 아닌 Application 에서 제공한다.</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    Account account1 &#x3D; entityManager.find(Account.class, 1L);</span><br><span class="line">    Account account2 &#x3D; entityManager.find(Account.class, 1L);</span><br><span class="line"></span><br><span class="line">    System.out.println(account1&#x3D;&#x3D;account2); &#x2F;&#x2F;true</span><br><span class="line"></span><br><span class="line">    transaction.commit();</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">    transaction.rollback();</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    entityManager.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>엔티티 등록에서 트랜잭션 지원 :<br>데이터 변경시 트랜잭션을 이용하여 쓰기 지연을 할 수 있다.<br>persist()에서는 엔티티를 1차 캐시에 저장하고<br>엔티티를 분석하여 Insert SQL을 생성한 뒤 쓰기 지연 SQL 저장소에 넣어둔다.<br>transaction.commit() 시점에서 쓰기 지연 SQL의 SQL들이 실행한다.<br>이를 통해 connection 한번으로 모든 처리를 모아서 한번에 할 수 있다는 장점이 있다.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">transaction.begin();</span><br><span class="line">try &#123;</span><br><span class="line">    Account account &#x3D; new Account();</span><br><span class="line">    account.setId(1L);</span><br><span class="line">    account.setName(&quot;tester&quot;);</span><br><span class="line">    </span><br><span class="line">    entityManager.persist(account);</span><br><span class="line">    </span><br><span class="line">    transaction.commit();</span><br><span class="line">    </span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">    transaction.rollback();</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    entityManager.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>엔티티 수정시 변경 감지 :<br>영속 엔티티가 수정되면 JPA가 Dirty Checking 기능으로 엔티 변경을 감지하여<br>commit() 시점에 update SQL을 실행한다.  </li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    Account account &#x3D; entityManager.find(Account.class, 1L);</span><br><span class="line">    account.setName(&quot;modified_name&quot;);</span><br><span class="line"></span><br><span class="line">    transaction.commit();</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">    transaction.rollback();</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    entityManager.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Dirty Checking : 1차 캐시의 스냅샷(1차 캐시에 캐싱될 때의 엔티티 상태)과 현재 엔티티 상태를 비교하는 것,<br>변경이 있으면 update SQL을 생성하여 쓰기 지연 SQL 저장소에 저장한다.  </p>
<h4 id="플러시"><a href="#플러시" class="headerlink" title="플러시"></a>플러시</h4><p>영속성 컨텍스트의 변경 내용을 데이터베이스에 반영하는 것.</p>
<p>플러시가 발생하면 어떤일이 일어나는가?  </p>
<ul>
<li>Dirty Checking</li>
<li>감지된 Update 쿼리를 쓰기 지연 SQL 저장소에 저장</li>
<li>쓰기 지연 SQL 저장소의 SQL 쿼리들을 DB로 전송</li>
</ul>
<p>플러시는 언제 발생하는가?</p>
<ul>
<li>em.flush()</li>
<li>트랜잭션 커밋</li>
<li>JPQL 쿼리 실행<br>find()는 1차 캐시에서 찾으면 되지만, JPQL은 실제 SQL이 발생하게 되므로…</li>
</ul>
<p>플러시 모드 옵션 (em.setFlushMode())</p>
<ul>
<li>FlushModeType.Auto : 커밋 또는 쿼리 실행 시 플러시 (default)</li>
<li>FlushModeType.Commit : 커밋할 때만 플러시</li>
</ul>
<h4 id="준영속-상태"><a href="#준영속-상태" class="headerlink" title="준영속 상태"></a>준영속 상태</h4><p>detached : 영속 상태의 엔티티가 영속성 컨텍스트에서 분리됨.<br>영속성 컨텍스트가 제공하는 기능들을 사용할 수 없다.  </p>
<p>준영속 상태로 만드는 방법?</p>
<ul>
<li>em.detach(entity) : 특정 엔티티만 준영속 상태로 전환</li>
<li>em.clear() : 영속성 컨텍스트 초기화</li>
<li>em.close() : 영속성 컨텍스트 닫기</li>
</ul>
<p>다시 영속 상태로 변환하려면?</p>
<ul>
<li>em.merge(entity)</li>
</ul>
<p>준영속 상태의 엔티티는 영속성 컨텍스트에서 관리되지 않기 때문에,<br>Dirty Checking이 발생하지 않는다.<br>따라서, 아래 예시에서는 Update SQL이 DB로 전송되지 않는다.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    Account account &#x3D; entityManager.find(Account.class, 1L);</span><br><span class="line">    account.setName(&quot;modified_name&quot;);</span><br><span class="line"></span><br><span class="line">    entityManager.detach(account);</span><br><span class="line"></span><br><span class="line">    transaction.commit();</span><br><span class="line"></span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">    transaction.rollback();</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    entityManager.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Study</category>
        <category>JPA</category>
      </categories>
      <tags>
        <tag>Spring Data JPA</tag>
        <tag>JPA</tag>
        <tag>ORM</tag>
        <tag>Mapping</tag>
      </tags>
  </entry>
  <entry>
    <title>JPA 매핑하기</title>
    <url>/2020/10/28/hexo_jpa_03/</url>
    <content><![CDATA[<img src="/img/jpa.png" class="img_class" width="340" height="160" title="jpa">
<h2 id="JPA-매핑하기"><a href="#JPA-매핑하기" class="headerlink" title="JPA 매핑하기"></a>JPA 매핑하기</h2><h3 id="엔티티-매핑"><a href="#엔티티-매핑" class="headerlink" title="엔티티 매핑"></a>엔티티 매핑</h3><h4 id="객체와-테이블-매핑"><a href="#객체와-테이블-매핑" class="headerlink" title="객체와 테이블 매핑"></a>객체와 테이블 매핑</h4><p>@Entity, @Table : 객체와 테이블 매핑</p>
<p>@Entity가 붙은 클래스는 JPA가 관리하는 엔티티가 된다.<br>JPA를 사용하여 테이블과 매핑시 필수적이다.<br>기본생성자가 필요하고 final 클래스, enum, interface, inner 클래스를 사용할 수 없다.<br>저장할 필드는 final일 수 없다.  </p>
<p>@Table은 엔티티와 매핑할 테이블을 지정한다.(없으면 엔티티 이름으로 매핑)  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Entity</span><br><span class="line">@Table(name &#x3D; &quot;Member&quot;)</span><br><span class="line">public class Account &#123;</span><br><span class="line"></span><br><span class="line">    @Id</span><br><span class="line">    private Long id;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="데이터베이스-스키마-자동-생성"><a href="#데이터베이스-스키마-자동-생성" class="headerlink" title="데이터베이스 스키마 자동 생성"></a>데이터베이스 스키마 자동 생성</h4><p>애플리케이션 실행 시점에 해당 데이터베이스에 적절한 DDL을 자동으로 수행하여 테이블을 생성하는 기능.<br>개발 단계에서 유용하게 사용할 수 있다.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;property name&#x3D;&quot;hibernate.hbm2ddl.auto&quot; value&#x3D;&quot;create&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>

<p>hibernate.hbm2ddl.auto</p>
<ul>
<li>create : 기존 테이블 삭제 후 다시 생성</li>
<li>create-drop : 시작 시점에 테이블 생성 후 종료 시점에 제거</li>
<li>update : 스키마 변경분만 반영 (컬럼 삭제는 안되는 것에 주의)</li>
<li>validate : 엔티티와 테이블의 매핑이 정상적인지 검증</li>
<li>none : 사용 X</li>
</ul>
<p>방언(dialect) 설정마다 DDL에 차이가 있음에 유의</p>
<h4 id="필드와-컬럼-매핑"><a href="#필드와-컬럼-매핑" class="headerlink" title="필드와 컬럼 매핑"></a>필드와 컬럼 매핑</h4><p>@Column : 필드와 테이블 컬럼 매핑</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Column(name &#x3D; &quot;name&quot;)</span><br><span class="line">private String name;</span><br></pre></td></tr></table></figure>
<ul>
<li>name : 매핑할 테이블 컬럼 이름</li>
<li>insertable, updatable : 등록/변경 가능 여부 (default = true)</li>
<li>nullable(DDL) : null 허용 여부 (not null constraint)</li>
<li>unique(DDL) : unique 제약조건 (제약조건명이 난수로 생성되어 보통 @Table에서 제약조건 생성)</li>
<li>columnDefinition(DDL) : 컬럼 정보 직접 입력<br>ex) columnDefinition = “varchar(50) not null”</li>
<li>length(DDL) : 문자 길이 제약조건, String에만 사용</li>
<li>precision, scale(DDL) : BigDecimal 또는 BigInteger 같은 타입의 자릿수 설정</li>
</ul>
<p>@Enumerated : enum 타입 매핑 정보</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Enumerated(EnumType.STRING)</span><br><span class="line">private Role role;</span><br></pre></td></tr></table></figure>
<ul>
<li>ORDINAL : enum 순서를 숫자로 저장 (문제 발생 소지가 있어 비추)</li>
<li>STRING : enum 이름 저장</li>
</ul>
<p>@Temporal : 날짜 타입 매핑 정보</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Temporal(TemporalType.TIMESTAMP)</span><br><span class="line">private Date createDate;</span><br></pre></td></tr></table></figure>
<ul>
<li>DATE : 날짜만 (컬럼 타입 date)</li>
<li>TIME : 시간만 (컬럼 타입 time)</li>
<li>TIMESTAMP : 날짜와 시간 (컬럼 타입 timestamp)</li>
</ul>
<p>LocalDate, LocalDateTime 타입은 애노테이션을 생략할 수 있다. </p>
<p>@Lob : BLOB,CLOB 타입 등으로 매핑</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Lob</span><br><span class="line">private String description;</span><br></pre></td></tr></table></figure>
<p>필드 타입이 문자면 clob, 나머지는 blob으로 매핑된다.</p>
<p>@Transient : 특정 필드 매핑 안함, 주로 메모리에서만 임시로 어떤 값을 저장하고 싶을 때 사용</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Transient</span><br><span class="line">private Integer tempId;</span><br></pre></td></tr></table></figure>

<h4 id="기본키-매핑"><a href="#기본키-매핑" class="headerlink" title="기본키 매핑"></a>기본키 매핑</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Id</span><br><span class="line">@GeneratedValue(strategy &#x3D; GenarationType.IDENTITY)</span><br><span class="line">private Long id;</span><br></pre></td></tr></table></figure>

<p>@Id : 해당 필드를 기본키로 매핑  </p>
<p>@GeneratedValue : 기본키 값 자동 생성</p>
<ul>
<li>IDENTITY : DB에 위임<br>MySQL, PostgreSQL 등에서 사용</li>
<li>SEQUENCE : DB 시퀀스를 생성 후 사용<br>Oracle, PostgreSQL 등에서 사용<br>@SequenceGenerator를 이용하여 사용할 시퀀스 커스텀 가능</li>
<li>TABLE : 키 생성용 테이블 생성<br>어느 DB에서나 사용할 수 있지만 성능 이슈 있음<br>@TableGenerator를 이용하여 사용할 테이블 커스텀 가능</li>
<li>AUTO : 방언에 따라 자동 지정</li>
</ul>
<p>IDENTITY 전략의 특징 :<br>DB에 insert 되기 전에는 PK 값을 알 수 없다.<br>한편 JPA는 커밋 시점에서야 insert 쿼리를 전달하기 때문에 문제가 발생한다.<br>그래서 IDENTITY 전략에서만 예외적으로 persist() 시점에 insert 쿼리를 전달한다.  </p>
<p>SEQUENCE 전략의 특징 :<br>persist() 시점에서 PK 값이 필요하기 때문에 정의된 시퀀스를 참조하는 작업이 수행된다.<br>때문에 persist() 마다 DB 접근이 필요한데, 이때의 성능 최적화를 위해<br>@SequenceGenerator의 allicationSize(default 50) 속성으로<br>DB의 현재 Sequence 값을 미리 설정값 만큼 증가시켜두고<br>증가된 부분은 추가적인 DB 접근 없이 메모리에서 불러올 수 있다.<br>TABLE 전략의 @TableGenerator:allicationSize도 위와 마찬가지이다.  </p>
<h3 id="연관관계-매핑-기초"><a href="#연관관계-매핑-기초" class="headerlink" title="연관관계 매핑 기초"></a>연관관계 매핑 기초</h3><p>객체지향은 참조가 필요한데<br>만약 객체를 연관관계 매핑 없이 테이블에 맞추어 모델링하는 경우<br>협력 관계를 만들 수 없다(참조가 불가능하다).  </p>
<h4 id="단방향-연관관계"><a href="#단방향-연관관계" class="headerlink" title="단방향 연관관계"></a>단방향 연관관계</h4><p>ex) Member와 Team의 N:1 다대일 관계일때,<br>Member 입장에서 어노테이션(@ManytoOne)으로 어떤 관계인지 알려줘야 한다.<br>특히, DB입장에서는 조인하는 컬럼명이 다른 경우가 많기 때문에 명시해주는 편이다.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@ManyToOne</span><br><span class="line">@JoinColumn(name &#x3D; &quot;TEAM_ID&quot;)</span><br><span class="line">private Team team;</span><br></pre></td></tr></table></figure>
<p>Member에서는 Team을 참조할 수 있으나,<br>Team에서는 Member를 참조할 수 없는 단방향 관계이다.</p>
<h4 id="양방향-연관관계"><a href="#양방향-연관관계" class="headerlink" title="양방향 연관관계"></a>양방향 연관관계</h4><p>Team에서도 Member 목록을 참조할 수 있는 양방향 관계를 만들 수 있다.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@OneToMany(mappedBy &#x3D; &quot;team&quot;)</span><br><span class="line">private List&lt;Member&gt; members &#x3D; new ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure>
<p>테이블 구조는 단방향인 경우와 다르지 않다.  </p>
<h4 id="연관관계의-주인과-mappedBy"><a href="#연관관계의-주인과-mappedBy" class="headerlink" title="연관관계의 주인과 mappedBy"></a>연관관계의 주인과 mappedBy</h4><p>테이블 입장에서는 FK 하나로 양방향 연관관계 하나를 가진다. (사실 방향성이 없다.)<br>그러나 객체 입장에서는 양방향 연관관계인 경우 두 개의 단방향 연관관계(서로를 참조하는)를 가진다.  </p>
<p>객체의 양방향 관계는 사실 양방향 관계가 아니라 서로 다른 단방향 관계 둘이다.<br>이 두 관계중 하나를 연관관계의 주인으로 지정해야 한다.<br>연관관계의 주인은 외래키를 관리(등록, 수정)하며, 주인이 아닌 쪽은 읽기만 가능하다.<br>주인이 아니면 mappedBy로 주인을 지정하고 주인으로 지정되는 관계는 mappedBy를 사용하지 않는다.  </p>
<p>비즈니스 로직에서의 중요성으로 주인을 정하기보다는 FK가 있는 곳을 주인으로 정하자,<br>그렇지 않으면 A객체에서 변경했는데 B테이블에 update 쿼리가 나가는 등 많이 헷갈리게 된다.</p>
<p>ex) Member와 Team의 N:1 다대일 양방향 관계에서 Member.team이 연관관계의 주인일때</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@ManyToOne</span><br><span class="line">@JoinColumn(name &#x3D; &quot;TEAM_ID&quot;)</span><br><span class="line">private Team team;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@OneToMany(mappedBy &#x3D; &quot;team&quot;)</span><br><span class="line">private List&lt;Member&gt; members &#x3D; new ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p>외래 키 등록또는 변경을 할때는 주인을 사용해야 한다.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;정상적인 외래 키 관리</span><br><span class="line">member.setTeam(team);</span><br><span class="line"></span><br><span class="line">em.persist();</span><br></pre></td></tr></table></figure>
<p>위의 경우는 이후에 Team.members로 조회를 할때 영속성 컨텍스트의 1차 캐시를 사용할 경우<br>추가된 member를 확인할 수 없다.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;가짜 주인을 사용한 비정상적 관리  </span><br><span class="line">team.getMembers().add(member);</span><br><span class="line"></span><br><span class="line">em.persist(); &#x2F;&#x2F; TEAM_ID(FK)에 null이 들어간다.</span><br></pre></td></tr></table></figure>

<p>객체지향적 프로그래밍의 순수 객체 상태를 고려해서 양쪽에서 값을 입력해야 한다.  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">member.setTeam(team);</span><br><span class="line">team.getMembers().add(member);</span><br><span class="line"></span><br><span class="line">em.persist();</span><br></pre></td></tr></table></figure>
<p>결과는 정상적인 외래 키 값 입력과 다르지 않지만,<br>이후에 Team.members 조회를 할때 영속성 컨텍스트의 1차 캐시를 사용할 경우에도<br>추가된 member를 확인할 수 있다.</p>
<p>이를 위해 연관관계 편의 메소드를 활용하자</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void changeTeam(Team team) &#123;</span><br><span class="line">    this.team &#x3D; team;</span><br><span class="line">    team.getMembers().add(this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>연관관계 편의 메소드는 주인이 아닌 관계를 가지는 객체에서 만들어도 된다.<br>그렇지만 양쪽에서 만들어서 사용하지는 말자.</p>
<p>양방향 연관관계에서 무한루프 조심하기<br>ex) toString(), lombok, JSON 생성 라이브러리  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public String toString() &#123;</span><br><span class="line">    return &quot;Member&#123;&quot; +</span><br><span class="line">            &quot;id&#x3D;&quot; + id +</span><br><span class="line">            &quot;, team&#x3D;&quot; + team +</span><br><span class="line">            &quot;, name&#x3D;&#39;&quot; + name + &#39;\&#39;&#39; +</span><br><span class="line">            &quot;, city&#x3D;&#39;&quot; + city + &#39;\&#39;&#39; +</span><br><span class="line">            &#39;&#125;&#39;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public String toString() &#123;</span><br><span class="line">    return &quot;Team&#123;&quot; +</span><br><span class="line">            &quot;id&#x3D;&quot; + id +</span><br><span class="line">            &quot;, name&#x3D;&#39;&quot; + name + &#39;\&#39;&#39; +</span><br><span class="line">            &quot;, members&#x3D;&#39;&quot; + members + &#39;\&#39;&#39; +</span><br><span class="line">            &#39;&#125;&#39;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>자동으로 생성된 toString()을 사용할때,<br>member.toString()에서 team.toString()을 호출하면<br>team.toString()에서 다시 member.toString()을 호출…</p>
<ul>
<li>Lombok의 @toString 사용하지 않기</li>
<li>toString() 구현시 매핑 컬럼 빼기 </li>
<li>@Entity를 Json으로 직접 변환하지 않기.(대신 DTO 사용)</li>
</ul>
<p>단방향 매핑만으로 연관관계 매핑은 완료되며, 양방향 매핑은 단순히 역방향 참조를 위한것이다.<br>때문에 단방향 매핑만 잘 해놓고 양방향 매핑은 필요할 때 추가하면 된다.<br>다만, JPQL에서 역방향 참조를 사용할 일이 많다.  </p>
<h3 id="다양한-연관관계-매핑"><a href="#다양한-연관관계-매핑" class="headerlink" title="다양한 연관관계 매핑"></a>다양한 연관관계 매핑</h3><h4 id="다대일-N-1"><a href="#다대일-N-1" class="headerlink" title="다대일 N:1"></a>다대일 N:1</h4><p>@ManyToOne<br>가장 많이 사용하는 연관관계이다.<br>테이블 입장의 연관관계에서 다(N) 쪽의 테이블이 FK를 가지게 된다.<br>연관관계의 주인은 다 쪽에 있다.  </p>
<p>ex) Member(N) : Team(1) 의 경우 Member.team이 주인이 됨</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@ManyToOne</span><br><span class="line">@JoinColumn(name &#x3D; &quot;TEAM_ID&quot;)</span><br><span class="line">private Team team;</span><br></pre></td></tr></table></figure>

<p>양방향인 경우는 주인이 아닌 관계에서 @OneToMany(mappedBy = “필드명”) 사용.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@OneToMany(mappedBy &#x3D; &quot;team&quot;)</span><br><span class="line">private List&lt;Member&gt; members &#x3D; new ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure>

<h4 id="일대다-1-N"><a href="#일대다-1-N" class="headerlink" title="일대다 1:N"></a>일대다 1:N</h4><p>@OneToMany<br>FK는 다(N) 쪽의 테이블에 걸려있지만, 주인은 반대의 관계(1)에서 가지는 연관관계이다.<br>@JoinColumn 애노테이션을 꼭 사용해야 하며 사용하지 않으면 조인 테이블(조인용 테이블이 추가로 생성됨) 방식을 사용하게 된다.</p>
<p>ex) Team(1) : Member(N) 의 경우 Team.members가 주인이 됨</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@OneToMany</span><br><span class="line">@JoinColumn(name &#x3D; &quot;TEAM_ID&quot;)</span><br><span class="line">private List&lt;Member&gt; members &#x3D; new ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p>엔티티가 관리하는 외래 키가 다른 테이블에 있고<br>때문에 관리 작업에서 추가로 Update 쿼리가 발생하는 단점이 있다.<br> =&gt; 일대다 단방향보다는 다대일 양방향을 사용하자.</p>
<p>일대다 양방향의 경우는 공식적으로는 존재하지 않는 매핑이다.<br>주인이 아닌 관계에서 @ManyToOne,<br>@JoinColumn(name = “필드명”, insertable = false, updatable=false)사용하여 구현할 수는 있다.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@ManyToOne</span><br><span class="line">@JoinColumn(name &#x3D; &quot;TEAM_ID&quot;, insertable &#x3D; false, updatable&#x3D;false)</span><br><span class="line">private Team team;</span><br></pre></td></tr></table></figure>

<p>강제로 필드를 주인이지만 읽기 전용으로 생성하여 양방향처럼 사용하는 방법.<br> =&gt; 그냥 다대일 양방향 사용하자.</p>
<h4 id="일대일-1-1"><a href="#일대일-1-1" class="headerlink" title="일대일 1:1"></a>일대일 1:1</h4><p>@OneToOne<br>일대일 관계는 그 반대도 일대일이다.<br>주 테이블이(Member)나 대상 테이블(Locker) 중에 외래 키를 가질 곳을 선택할 수 있다.<br>(FK를 어느 테이블에 설정할지는 비즈니스 로직에 따라서…)<br>다대일이나 일대다와 테이블 구조에서 다른 점은 외래 키에 unique 제약조건이 추가로 설정된다.<br>일대다 관계처럼 FK가 있는 테이블의 반대 엔티티에서 주인으로 설정할 수 없기 때문에<br>다대일처럼 FK가 있는 엔티티에서 주인이도록 설정하자.</p>
<p>ex) Member(1) : Locker(1), Member 테이블에 FK가 있다고 가정.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@OneToOne</span><br><span class="line">@JoinColumn(name &#x3D; &quot;LOCKER_ID&quot;)</span><br><span class="line">private Locker locker;</span><br></pre></td></tr></table></figure>

<p>양방향이 필요한 경우 주인이 아닌 엔티티에서 @OneToOne(mappedBy = “필드명”) 사용.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@OneToOne(mappedBy &#x3D; &quot;locker&quot;)</span><br><span class="line">private Member member;</span><br></pre></td></tr></table></figure>

<p>양뱡향에서 주의할 점은 프록시 기능의 한계로 인하여<br>주인이 아닌 관계를 통해 조회 시 지연 로딩이 불가능하다는 단점이 있다.  </p>
<h4 id="다대다-N-M"><a href="#다대다-N-M" class="headerlink" title="다대다 N:M"></a>다대다 N:M</h4><p>@ManyToMany<br>실무에서 거의 쓰지 않기도 하고 추천하지도 않는 관계.<br>RDB같은 경우에 정규화된 테이블 2개로 다대다 관계를 표현할 수 없으며<br>연결 테이블을 추가하여 일대다, 다대일 관계로 풀어내야 한다.<br>연결 테이블에서 양쪽 테이블의 PK를 참조하는 FK를 가지고 있다.</p>
<p>ORM의 @ManyToMany는 각 관계와 연결 테이블을 매핑해준다.<br>@JoinTable(name = “테이블명”)으로 연결테이블을 지정.</p>
<p>ex) Member(N) : Product(M)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@ManyToMany</span><br><span class="line">@JoinTable(name &#x3D; &quot;MEMBER_PRODUCT&quot;)</span><br><span class="line">private List&lt;Product&gt; products &#x3D; new ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p>양방향이 필요한 경우 주인이 아닌 엔티티에서 @ManyToMany(mappedBy = “필드명”) 사용.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@ManyToMany(mappedBy &#x3D; &quot;products&quot;)</span><br><span class="line">private List&lt;Member&gt; mambers &#x3D; new ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p>@JoinTable에 지정된 연결 테이블에서는 추가적인 데이터를 사용할 수 없다는 한계가 있고<br>쿼리도 생각한 것과 다르게 생성되는 경우가 많기 때문에 사용을 권장하지 않는다.<br> =&gt; 연결 테이블용 엔티티 추가</p>
<p>연결 테이블 엔티티를 추가(연결 테이블을 엔티티로 승격)하고<br>@ManyToMany대신 @ManyToOne과 @OneToMany의 조합으로 사용하자.</p>
<p>ex) Member -1:N- MemberProduct -N:1- Product<br>Member</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@OneToMany(mappedBy &#x3D; &quot;member&quot;)</span><br><span class="line">private List&lt;MemberProduct&gt; memberProducts &#x3D; new ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure>
<p>MemberProduct</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@ManyToOne</span><br><span class="line">@JoinColumn(name &#x3D; &quot;MEMBER_ID&quot;)</span><br><span class="line">private Member member;</span><br><span class="line"></span><br><span class="line">@ManyToOne</span><br><span class="line">@JoinColumn(name &#x3D; &quot;PRODUCT_ID&quot;)</span><br><span class="line">private Product product;</span><br></pre></td></tr></table></figure>
<p>Product</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@OneToMany(mappedBy &#x3D; &quot;product&quot;)</span><br><span class="line">private List&lt;MemberProduct&gt; memberProducts &#x3D; new ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p>이렇게 하면 @ManyToMany에서는 불가능한 연결 테이블에 속성 추가를 할 수 있다.</p>
<h3 id="고급-매핑"><a href="#고급-매핑" class="headerlink" title="고급 매핑"></a>고급 매핑</h3><h4 id="상속-관계-매핑"><a href="#상속-관계-매핑" class="headerlink" title="상속 관계 매핑"></a>상속 관계 매핑</h4><p>객체에는 상속 관계가 있지만 RDB의 테이블에는 상속 관계가 없다.<br>그나마 객체 상속과 유사한 것이 슈퍼타입/서브타입 관계 모델링 기법이다.</p>
<p>상속 관계 매핑 : 객체의 상속 구조와 DB의 슈퍼타입/서브타입 관계를 매핑</p>
<p>DB에서 슈퍼타입/서브타입 관계를 물리적인 모델로 구현하는 방법</p>
<ul>
<li>각각 테이블로 변환 =&gt; 조인 전략 </li>
<li>통합 테이블로 변환 =&gt; 단일 테이블 전략</li>
<li>서브타입 테이블로 변환 =&gt; 구현 클래스마다 테이블 전략</li>
</ul>
<p>세가지 중 어떤 구현 방식을 사용하더라도 JPA에서 매핑할 수 있다.</p>
<p>상속 관계 매핑</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Entity</span><br><span class="line">public class Book extends Item &#123;</span><br><span class="line">    private String author;</span><br><span class="line">    private String isbn;</span><br><span class="line">    ~</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Entity</span><br><span class="line">public class Album extends Item &#123;</span><br><span class="line">    private String artist;</span><br><span class="line">    ~</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Entity</span><br><span class="line">public class Movie extends Item &#123;</span><br><span class="line">    private String director;</span><br><span class="line">    private String actor;</span><br><span class="line">    ~</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>객체 상속만 하고 아무런 설정도 하지 않으면 JPA는 기본적으로 단일 테이블 전략을 사용한다.<br>그러므로 부모 객체 엔티티에 매핑되는 테이블에 모든 속성이 추가된다.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Hibernate: </span><br><span class="line">    </span><br><span class="line">    create table Item (</span><br><span class="line">       DTYPE varchar(31) not null,</span><br><span class="line">        ITEM_ID bigint not null,</span><br><span class="line">        name varchar(255),</span><br><span class="line">        price integer not null,</span><br><span class="line">        stockQuantity integer not null,</span><br><span class="line">        artist varchar(255),</span><br><span class="line">        author varchar(255),</span><br><span class="line">        isbn varchar(255),</span><br><span class="line">        actor varchar(255),</span><br><span class="line">        director varchar(255),</span><br><span class="line">        primary key (ITEM_ID)</span><br><span class="line">    )</span><br></pre></td></tr></table></figure>
<p>단일 테이블 전략은 하위 객체를 구별하기 위한 “DTYPE” 컬럼이 필수이기 때문에 자동으로 생성된다.</p>
<p>전략을 변경하기 위해서는 @Inheritance(strategy = InheritanceType.xxx) 어노테이션을 사용한다.</p>
<ul>
<li>InheritanceType.JOINED : 조인 전략</li>
<li>InheritanceType.SINGLE_TABLE : 단일 테이블 전략</li>
<li>InheritanceType.TABLE_PER_CLASS : 구현 클래스마다 테이블 전략</li>
</ul>
<p>@DiscriminatorColumn 어노테이션은 “DTYPE” 컬럼(String, 하위 객체명)을 추가한다.<br>(만약 하위 객체명 대신 다른 값으로 대체하고 싶다면 하위 객체에서 @DiscriminatorValue 사용)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Entity</span><br><span class="line">@Inheritance(strategy &#x3D; InheritanceType.JOINED)</span><br><span class="line">@DiscriminatorColumn</span><br><span class="line">public abstract class Item &#123;</span><br><span class="line">    ~</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>조인 전략은 슈퍼타입과 서브타입을 모두 테이블로 생성하며<br>서브타입 테이블들은 각각 슈퍼타입 PK를 참조하는 FK를 가지게 된다.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Hibernate: </span><br><span class="line">    </span><br><span class="line">    create table Item (</span><br><span class="line">       ITEM_ID bigint not null,</span><br><span class="line">        name varchar(255),</span><br><span class="line">        price integer not null,</span><br><span class="line">        stockQuantity integer not null,</span><br><span class="line">        primary key (ITEM_ID)</span><br><span class="line">    )</span><br><span class="line">Hibernate: </span><br><span class="line">    </span><br><span class="line">    create table Album (</span><br><span class="line">       artist varchar(255),</span><br><span class="line">        ITEM_ID bigint not null,</span><br><span class="line">        primary key (ITEM_ID)</span><br><span class="line">    )</span><br><span class="line">Hibernate: </span><br><span class="line">    </span><br><span class="line">    create table Book (</span><br><span class="line">       author varchar(255),</span><br><span class="line">        isbn varchar(255),</span><br><span class="line">        ITEM_ID bigint not null,</span><br><span class="line">        primary key (ITEM_ID)</span><br><span class="line">    )</span><br><span class="line">Hibernate: </span><br><span class="line">    </span><br><span class="line">    create table Movie (</span><br><span class="line">       actor varchar(255),</span><br><span class="line">        director varchar(255),</span><br><span class="line">        ITEM_ID bigint not null,</span><br><span class="line">        primary key (ITEM_ID)</span><br><span class="line">    )</span><br><span class="line">Hibernate: </span><br><span class="line">    </span><br><span class="line">    alter table Album </span><br><span class="line">       add constraint FK75mrpprv8oigh00y92tibw7id </span><br><span class="line">       foreign key (ITEM_ID) </span><br><span class="line">       references Item</span><br><span class="line">Hibernate: </span><br><span class="line">    </span><br><span class="line">    alter table Book </span><br><span class="line">       add constraint FK2srbe8wjbanr4vtkrsb8atq7o </span><br><span class="line">       foreign key (ITEM_ID) </span><br><span class="line">       references Item</span><br><span class="line">Hibernate: </span><br><span class="line">    </span><br><span class="line">    alter table Movie </span><br><span class="line">       add constraint FKqqwswm36y8uqoh9emtoruoxcv </span><br><span class="line">       foreign key (ITEM_ID) </span><br><span class="line">       references Item</span><br></pre></td></tr></table></figure>
<p>자식 객체를 저장할때(persist()),<br>서브타입 테이블 뿐만 아니라 슈퍼타입 테이블에도 insert 된다.<br>자식 객체를 조회하면 슈퍼타입/서브타입 테이블을 조인하여 조회한다.  </p>
<p>구현 클래스마다 테이블 전략 적용</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Entity</span><br><span class="line">@Inheritance(strategy &#x3D; InheritanceType.TABLE_PER_CLASS)</span><br><span class="line">public abstract class Item &#123;</span><br><span class="line">    ~</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>구현 클래스마다 테이블 전략은 상위 추상 클래스 엔티티에 매핑되는 테이블을 생성하지 않고<br>하위 클래스를 매핑하는 테이블만 생성한다.<br>구현 클래스마다 테이블 전략에서는 @DiscriminatorColumn 어노테이션이 의미가 없다.(사용되지 않는다.)</p>
<p>구현 클래스마다 테이블 전략에서 상위 추상 클래스를 통해 조회할때, 하위 클래스를 모두 조회해야 한다는 단점이 있다.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Item item &#x3D; em.find(Item.class, movie.getId());</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Hibernate: </span><br><span class="line">    select</span><br><span class="line">        item0_.ITEM_ID as item_id1_5_0_,</span><br><span class="line">        item0_.name as name2_5_0_,</span><br><span class="line">        item0_.price as price3_5_0_,</span><br><span class="line">        item0_.stockQuantity as stockqua4_5_0_,</span><br><span class="line">        item0_.artist as artist1_0_0_,</span><br><span class="line">        item0_.author as author1_1_0_,</span><br><span class="line">        item0_.isbn as isbn2_1_0_,</span><br><span class="line">        item0_.actor as actor1_7_0_,</span><br><span class="line">        item0_.director as director2_7_0_,</span><br><span class="line">        item0_.clazz_ as clazz_0_ </span><br><span class="line">    from</span><br><span class="line">        ( select</span><br><span class="line">            ITEM_ID,</span><br><span class="line">            name,</span><br><span class="line">            price,</span><br><span class="line">            stockQuantity,</span><br><span class="line">            artist,</span><br><span class="line">            null as author,</span><br><span class="line">            null as isbn,</span><br><span class="line">            null as actor,</span><br><span class="line">            null as director,</span><br><span class="line">            1 as clazz_ </span><br><span class="line">        from</span><br><span class="line">            Album </span><br><span class="line">        union</span><br><span class="line">        all select</span><br><span class="line">            ITEM_ID,</span><br><span class="line">            name,</span><br><span class="line">            price,</span><br><span class="line">            stockQuantity,</span><br><span class="line">            null as artist,</span><br><span class="line">            author,</span><br><span class="line">            isbn,</span><br><span class="line">            null as actor,</span><br><span class="line">            null as director,</span><br><span class="line">            2 as clazz_ </span><br><span class="line">        from</span><br><span class="line">            Book </span><br><span class="line">        union</span><br><span class="line">        all select</span><br><span class="line">            ITEM_ID,</span><br><span class="line">            name,</span><br><span class="line">            price,</span><br><span class="line">            stockQuantity,</span><br><span class="line">            null as artist,</span><br><span class="line">            null as author,</span><br><span class="line">            null as isbn,</span><br><span class="line">            actor,</span><br><span class="line">            director,</span><br><span class="line">            3 as clazz_ </span><br><span class="line">        from</span><br><span class="line">            Movie </span><br><span class="line">    ) item0_ </span><br><span class="line">where</span><br><span class="line">    item0_.ITEM_ID&#x3D;?</span><br></pre></td></tr></table></figure>

<p>전략 별 장단점  </p>
<p>조인 전략</p>
<ul>
<li>장점<ul>
<li>테이블 정규화</li>
<li>외래 키 참조 무결성 제약조건 활용 가능</li>
<li>효율적인 저장공간 사용</li>
</ul>
</li>
<li>단점<ul>
<li>조인을 통한 조회로 성능저하</li>
<li>복잡한 조회 쿼리</li>
<li>저장 시 insert 2회 호출</li>
</ul>
</li>
</ul>
<p>단일 테이블 전략</p>
<ul>
<li>장점<ul>
<li>조인이 필요 없어서 조회 성능이 좋음</li>
<li>단순한 조회 쿼리</li>
</ul>
</li>
<li>단점<ul>
<li>자식 엔티티가 매핑한 컬럼은 모두 null 허용</li>
<li>테이블 하나에 모든 데이터를 저장하기 때문에 조회 성능이 오히려 느려질 수 있음 </li>
</ul>
</li>
</ul>
<p>구현 클래스마다 테이블 전략 (비추)</p>
<ul>
<li>장점<ul>
<li>서브타입을 명확하게 구분해서 처리할 때 효과적</li>
<li>not null 제약조건 사용 가능</li>
</ul>
</li>
<li>단점<ul>
<li>여러 자식 테이블을 함께 조회할 때 성능이 느림(union)</li>
<li>자식 테이블을 통합해서 쿼리하기 어려움</li>
</ul>
</li>
</ul>
<h4 id="MappedSuperclass"><a href="#MappedSuperclass" class="headerlink" title="@MappedSuperclass"></a>@MappedSuperclass</h4><p>테이블과 관계 없고 단순히 엔티티들이 공통으로 사용하는 매핑 정보를 모아 가지고 있는 역할을 한다.<br>주로 등록일, 수정일, 등록자, 수정자 같은 전체 엔티티에서 공통적으로 적용하는 매핑 정보를 모을 때 사용된다.<br>참고로 @Entity는 다른 엔티티나 @MappedSuperclass로 지정된 클래스만 상속받을 수 있다.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@MappedSuperclass</span><br><span class="line">public abstract class BaseEntity &#123;</span><br><span class="line">    </span><br><span class="line">    @Column(name &#x3D; &quot;INSERT_MEMBER&quot;)</span><br><span class="line">    private String createdBy;</span><br><span class="line">    private LocalDateTime createdDate;</span><br><span class="line">    @Column(name &#x3D; &quot;UPDATE_MEMBER&quot;)</span><br><span class="line">    private String lastModifiedBy;</span><br><span class="line">    private LocalDateTime lastModifiedDate;</span><br><span class="line">    ~</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>부모 클래스가 가지는 속성들만 상속받을 수 있다.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Entity</span><br><span class="line">public class Member extends BaseEntity &#123;</span><br><span class="line">    ~</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>상속 관계 매핑이 아니며 부모 클래스를 조회할 수 없다. (em.find(BaseEntity) x)<br>직접 생성하여 사용할 일이 없으므로 추상 클래스로 생성할 것을 권장한다.</p>
<h3 id="프록시와-연관관계-관리"><a href="#프록시와-연관관계-관리" class="headerlink" title="프록시와 연관관계 관리"></a>프록시와 연관관계 관리</h3><h4 id="프록시"><a href="#프록시" class="headerlink" title="프록시"></a>프록시</h4><p>em.find(엔티티 클래스, id) : 데이터베이스를 통하여 실제 엔티티 객체 조회<br>em.getReference(엔티티 클래스, id) : 데이터베이스 조회를 미루는 가짜(프록시) 엔티티 객체 조회</p>
<p>프록시의 특징</p>
<ul>
<li>실제 엔티티를 상속 받아서 만들어지며 겉 모양은 실제 엔티티와 동일하다. 타입 체크시 주의가 필요하다. (== 대신 instanceof 사용)  </li>
<li>실제 객체의 참조(target)를 보관한다.  </li>
<li>호출되면 실제 객체의 메소드를 대신 호출한다.  </li>
<li>처음 사용할 때 딱 한번만 초기화하며, 초기화할때는 프록시 객체가 실제 객체가 되는 것이 아니라<br>target을 통해 실제 객체에 접근하는 것이다.</li>
<li>찾는 엔티티가 이미 영속성 컨텍스트에 있으면 실제 엔티티를 반환한다.</li>
<li>준영속성 상태에서는 초기화할 때 예외가 발생한다. (실제 객체 참조를 위한 영속성 컨텍스트의 도움을 받을 수 없기 때문)</li>
<li>이론적으로는 진짜 객체인지 프록시 객체인지 구분하지 않고 사용하면 된다.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;프록시 객체 조회 </span><br><span class="line">&#x2F;&#x2F;여기까지는 member는 프록시 객체이며 target은 null이다.</span><br><span class="line">Member member &#x3D; em.getReference(Member.class, 1L);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;초기화 요청, 이때 실제 엔티티를 조회하기 위해 DB에 접근한다.</span><br><span class="line">&#x2F;&#x2F;조회된 실제 엔티티가 target이 된다. </span><br><span class="line">member.getName();</span><br></pre></td></tr></table></figure>

<p>em.find()으로도 프록시 객체가 리턴되는 경우가 있는데,<br>같은 엔티티 조회가 프록시 객체로 먼저 조회되었을 때이다.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;프록시 객체 조회</span><br><span class="line">Member member1 &#x3D; em.getReference(Member.class, 1L);</span><br><span class="line">&#x2F;&#x2F;em.find()이지만 member1과 같은 프록시 객체가 된다.</span><br><span class="line">Member member2 &#x3D; em.find(Member.class, 1L);</span><br></pre></td></tr></table></figure>

<p>프록시 객체 확인하기</p>
<p>프록시 인스턴스 초기화 여부 확인 :<br>PersistenceUnitUtil.isLoaded(Object entity)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">emf.getPersistenceUnitUtil().isLoaded(member);</span><br></pre></td></tr></table></figure>
<p>프록시 클래스 확인 :<br>entity.getClass()</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">System.out.println(member.getClass());</span><br></pre></td></tr></table></figure>
<p>프록시 강제 초기화 :<br>org.hibernate.Hibernate.initialize(entity)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Hibernate.initialize(member);</span><br></pre></td></tr></table></figure>

<h4 id="즉시-로딩과-지연-로딩"><a href="#즉시-로딩과-지연-로딩" class="headerlink" title="즉시 로딩과 지연 로딩"></a>즉시 로딩과 지연 로딩</h4><p>엔티티를 조회할 때,<br>비즈니스 로직상 연관 관계가 있는 엔티티까지 같이 조회 할 필요가 없다면?<br> =&gt; 지연 로딩(LAZY)을 사용하여 연관 관계 엔티티를 프록시로 조회할 수 있다.<br> 그러면 DB에서는 실제로 사용할 엔티티만 조회한다.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@ManyToOne(fetch &#x3D; FetchType.LAZY)</span><br><span class="line">@JoinColumn(name &#x3D; &quot;MEMBER_ID&quot;)</span><br><span class="line">private Member member;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;member.Team은 프록시로 조회</span><br><span class="line">Member member &#x3D; em.find(Member.class, 1L);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;실제 사용되는 시점에서 프록시 초기화 발생 </span><br><span class="line">member.getTeam().getName();</span><br></pre></td></tr></table></figure>

<p>그렇지 않고 연관 관계의 엔티티까지 자주 함께 사용되는 경우에는?<br> =&gt; 즉시 로딩(EAGER)을 사용하여 함께 실제 객체로 조회한다.<br> JPA 구현체는 가능하면 조인을 사용하여 SQL 한번으로 함께 조회한다.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@ManyToOne(fetch &#x3D; FetchType.EAGER)</span><br><span class="line">@JoinColumn(name &#x3D; &quot;MEMBER_ID&quot;)</span><br><span class="line">private Member member;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;Member와 Team을 DB에서 함께 조회</span><br><span class="line">Member member &#x3D; em.find(Member.class, 1L);</span><br></pre></td></tr></table></figure>

<p>프록시와 즉시 로딩(EAGER) 주의</p>
<ul>
<li>즉시 로딩을 사용하면 예상치 못한 SQL 발생 가능</li>
<li>JPQL에서 N+1 문제 발생</li>
<li>@ManyToOne, @OneToOne은 기본적으로 즉시 로딩 사용 (LAZY로 변경 필요)</li>
<li>@OneToMany, @ManyToMany는 기본적으로 지연 로딩 사용</li>
</ul>
<p>=&gt; 가급적 지연 로딩(LAZY)만 사용하자</p>
<p>N+1 문제?<br>JPQL은 사용자가 작성한 JPQL 문을 SQL로 번역하여 실행되는데,<br>번역된 SQL이 먼저 실행된 후에 로딩 방식을 알게 된다.<br>이때 로딩 방식이 지연 로딩이면 상관 없겠지만,<br>즉시 로딩인 경우에는 연관 관계의 엔티티를 조회하기 위해서<br>처음 번역된 SQL문으로 얻은 row 수(N) 만큼 추가로 SQL이 발생하게 되어 성능에 치명적인 단점을 가지게된다.<br>=&gt; 지연 로딩 사용 또는 JPQL fetch join 사용</p>
<h4 id="영속성-전이-CASCADE"><a href="#영속성-전이-CASCADE" class="headerlink" title="영속성 전이(CASCADE)"></a>영속성 전이(CASCADE)</h4><p>특정 엔티티를 영속 상태로 만들 때 연관된 엔티티도 함께 영속 상태로 만들고 싶을 때 사용<br>ex) 부모 엔티티를 저장할 때 자식 엔티티도 함께 저장</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@OneToMany(mappedBy &#x3D; &quot;parent&quot;, cascade &#x3D; CascadeType.ALL)</span><br><span class="line">private List&lt;Child&gt; childList &#x3D; new ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">parent.getChildList.add(child1);</span><br><span class="line">parent.getChildList.add(child2);</span><br><span class="line"></span><br><span class="line">em.persist(parent);</span><br><span class="line">&#x2F;&#x2F;아래 영속화는 cascade에 의해 자동으로 이루어진다.</span><br><span class="line">&#x2F;&#x2F;em.persist(child1);</span><br><span class="line">&#x2F;&#x2F;em.persist(child2);</span><br></pre></td></tr></table></figure>

<p>엔티티를 영속화할 때 연관된 엔티티도 함께 영속화하는 편리함을 제공할 뿐,<br>영속성 전이는 연관관계를 매핑하는 것과는 아무런 관련이 없다.</p>
<p>CASCADE의 종류</p>
<ul>
<li>CascadeType.ALL : 모두 적용</li>
<li>CascadeType.PERSIST : 영속</li>
<li>CascadeType.REMOVE : 삭제</li>
<li>CascadeType.MERGE : 병합</li>
<li>CascadeType.REFRESH : REFRESH</li>
<li>CascadeType.DETACH : DETACH</li>
</ul>
<p>주의)<br>두 엔티티의 라이프사이클이 유사할 때만 사용하자.<br>참조하는 곳이 하나인 경우(특정 엔티티가 개인 소유할 때)만 사용하자.</p>
<h4 id="고아-객체"><a href="#고아-객체" class="headerlink" title="고아 객체"></a>고아 객체</h4><p>고아 객체 제거 : 부모 엔티티와 연관 관계가 끊어진 자식 엔티티를 자동으로 삭제</p>
<p>orphanRemoval = true</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@OneToMany(mappedBy &#x3D; &quot;parent&quot;, cascade &#x3D; CascadeType.ALL, orphanRemoval &#x3D; true)</span><br><span class="line">private List&lt;Child&gt; childList &#x3D; new ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p>자식 엔티티를 컬렉션에서 제거할 경우 자동으로 delete문이 발생한다.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">parent.getChildList().remove(0);</span><br></pre></td></tr></table></figure>

<p>또는 부모 엔티티가 제거되는 경우 연관 관계에 있는 자식 엔티티도 자동으로 삭제된다.<br>이 경우는 CascadeType.REMOVE 처럼 동작한다.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">em.remove(parent);</span><br></pre></td></tr></table></figure>

<p>주의)<br>참조하는 곳이 하나인 경우(특정 엔티티가 개인 소유할 때)만 사용하자.<br>@OneToOne, @OneToMany만 사용 가능하다.  </p>
<p>CASCADE와 orphanRemoval를 사용하면 부모 엔티티를 통해서 자식 엔티티의 생명주기를 관리할 수 있다.<br>, 이런 특징은 도메인 주도 설계(DDD)의 Aggregate Root개념을 구현할 때 유용하다.</p>
<h3 id="값-타입"><a href="#값-타입" class="headerlink" title="값 타입"></a>값 타입</h3><p>JPA의 데이터 타입 분류 </p>
<p>엔티티 타입</p>
<ul>
<li>@Entity로 정의하는 객체</li>
<li>데이터가 변해도 식별자로 지속해서 추적할 수 있다.</li>
</ul>
<p>값 타입</p>
<ul>
<li>int, Integer, String처럼 단순히 값으로 사용하는 자바 기본 타입이나 객체</li>
<li>식별자가 없고 값만 있기 때문에 식별자로 추적할 수 없다.</li>
</ul>
<p>값 타입의 분류</p>
<p>기본값 타입</p>
<ul>
<li>자바 기본 타입(int, double)</li>
<li>래퍼 클래스(Integer, Long)</li>
<li>String</li>
</ul>
<p>임베디드 타입(embedded type, 복합 값 타입)</p>
<p>컬렉션 값 타입(collection value type)</p>
<h4 id="기본값-타입"><a href="#기본값-타입" class="headerlink" title="기본값 타입"></a>기본값 타입</h4><p>ex) String name, int age  </p>
<p>생명 주기를 엔티티에 의존한다.<br>ex) 회원 엔티티를 삭제하면 이름, 나이 필드도 함께 삭제된다.  </p>
<p>값 타입은 공유하면 안된다.<br>ex) 회원 이름 변경 시 다른 회원의 이름도 함께 변경되면 안된다.<br>자바 기본 타입은 항상 값을 복사한다.<br>Integer 같은 래퍼 클래스나 String 같은 특수한 클래스는 공유가 가능하지만 변경이 불가능하다.</p>
<h4 id="임베디드-타입"><a href="#임베디드-타입" class="headerlink" title="임베디드 타입"></a>임베디드 타입</h4><p>새로운 값 타입을 직접 정의할 수 있다.<br>주로 기본값 타입들을 모아서 만들기 때문에 복합 값 타입이라고도 한다.  </p>
<p>임베디드 타입 사용법  </p>
<ul>
<li>@Embeddable : 값 타입을 정의하는 곳에 표시  </li>
<li>@Embedded : 값 타입을 사용하는 곳에 표시  </li>
<li>기본 생성자가 필수이다.</li>
<li>임베디드 타입의 값이 null이면 매핑되는 컬럼 값은 모두 null이다.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Embeddable</span><br><span class="line">public class Period &#123;</span><br><span class="line">    private LocalDateTime startDate;</span><br><span class="line">    private LocalDateTime endDate;</span><br><span class="line">    ~</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Embeddable</span><br><span class="line">public class Address &#123;</span><br><span class="line">    private String city;</span><br><span class="line">    private String street;</span><br><span class="line">    private String zipcode;</span><br><span class="line">    ~</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Embedded</span><br><span class="line">private Period period;</span><br><span class="line"></span><br><span class="line">@Embedded</span><br><span class="line">private Address address;</span><br></pre></td></tr></table></figure>

<p>임베디드 타입과 테이블 매핑</p>
<ul>
<li>임베디드 타입은 엔티티의 값일 뿐이다.</li>
<li>임베디드 타입을 사용하든 안하든 매핑하는 테이블은 변하지 않는다.</li>
<li>객체와 테이블을 아주 세밀하게 매핑하는 것이 가능하다.(find-grained)</li>
<li>잘 설계한 ORM 애플리케이션은 매핑한 테이블의 수보다 클래스의 수가 더 많다.</li>
</ul>
<p>임베디드 타입의 장점</p>
<ul>
<li>재사용성</li>
<li>높은 응집도</li>
<li>해당 값 타입 전용 메소드 생성 가능</li>
<li>소유한 엔티티에 생명주기를 의존한다.</li>
</ul>
<p>@AttributeOverride : 속성 재정의<br>한 엔티티에서 같은 임베디드 타입을 사용할 수 있다.<br>@AttributeOverrides, @AttributeOverride를 사용하여 컬럼 명 속성을 재정의 한다.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Embedded</span><br><span class="line">private Period period;</span><br><span class="line"></span><br><span class="line">@Embedded</span><br><span class="line">@AttributeOverrides(&#123;</span><br><span class="line">    @AttributeOverride(name &#x3D; &quot;startDate&quot;, column &#x3D; @Column(name &#x3D; &quot;EMP_START&quot;)),</span><br><span class="line">    @AttributeOverride(name &#x3D; &quot;endDate&quot;, column &#x3D; @Column(name &#x3D; &quot;EMP_END&quot;))</span><br><span class="line">&#125;)</span><br><span class="line">private Period empPeriod;</span><br></pre></td></tr></table></figure>

<h4 id="값-타입과-불변-객체"><a href="#값-타입과-불변-객체" class="headerlink" title="값 타입과 불변 객체"></a>값 타입과 불변 객체</h4><p>임베디드 타입은 그 특징상 여러 엔티티에서 공유가 가능한데,<br>값 타입은 공유하게 되면 부작용(side effect)가 발생할 수 있기 때문에 위험하다.<br>자바 기본 타입은 값을 복사하지만,<br>임베디드 타입은 객체 타입이기 때문에<br>참조 값을 직접 대입하는 것을 막을 방법이 없으며, 공유 참조를 피할 수 없다.<br>만약, 객체 타입을 수정할 수 없게 만들면 부작용을 원천 차단할 수 있다.</p>
<p>불변 객체(immutable object) : 생성 시점 이후 절대 값을 변경할 수 없는 객체 </p>
<ul>
<li>값 타입은 불변 객체로 설계해야 한다.</li>
<li>생성자로만 값을 설정하고 수정자를 만들지 않는다. (또는 private로 설정)</li>
<li>Integer, String은 자바가 제공하는 대표적인 불변 객체이다.</li>
<li>변경이 필요하다면 인스턴스를 새로 생성.</li>
</ul>
<p>=&gt; 임베디드 타입을 사용할 때는 불변 객체로 생성하자. </p>
<h4 id="값-타입의-비교"><a href="#값-타입의-비교" class="headerlink" title="값 타입의 비교"></a>값 타입의 비교</h4><p>값 타입은 인스턴스가 달라도 그 안의 값이 같다면 비교했을 때 같은 것으로 봐야한다.</p>
<p>동일성(identity) 비교 : 인스턴스의 참조 값을 비교 (==)<br>동등성(equivalence) 비교 : 인스턴스가 포함하는 값을 비교 (equals())  </p>
<p>값 타입을 비교할 때는 a.equals(b)를 이용하여 동등성 비교를 해야한다.<br>equals() 메소드는 기본적으로 ==를 사용하기 때문에 적절한 재정의가 필요하다.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public boolean equals(Object o) &#123;</span><br><span class="line">    if (this &#x3D;&#x3D; o) return true;</span><br><span class="line">    if (o &#x3D;&#x3D; null || getClass() !&#x3D; o.getClass()) return false;</span><br><span class="line">    Period period &#x3D; (Period) o;</span><br><span class="line">    return Objects.equals(startDate, period.startDate) &amp;&amp;</span><br><span class="line">            Objects.equals(endDate, period.endDate);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="값-타입-컬렉션"><a href="#값-타입-컬렉션" class="headerlink" title="값 타입 컬렉션"></a>값 타입 컬렉션</h4><p>엔티티의 하나의 속성에 값 타입을 하나 이상 저장할 때 사용한다.</p>
<p>@ElementCollection, @CollectionTable 어노테이션 사용</p>
<p>한편, RDB 테이블의 개별 필드는 컬렉션을 저장할 수 없으므로<br>컬렉션을 저장하기 위한 별도의 테이블이 필요하다.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@ElementCollection</span><br><span class="line">@CollectionTable(name &#x3D; &quot;FAVORITE_FOOD&quot;, </span><br><span class="line">    joinColumns &#x3D; @JoinColumn(name &#x3D; &quot;MEMBER_ID&quot;)</span><br><span class="line">)</span><br><span class="line">@Column(name &#x3D; &quot;FOOD_NAME&quot;) &#x2F;&#x2F;여기서의 @Column은 FAVORITE_FOOD 테이블의 컬럼 정보이다.</span><br><span class="line">private Set&lt;String&gt; favoriteFoods &#x3D; new HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">@ElementCollection</span><br><span class="line">@CollectionTable(name &#x3D; &quot;ADDRESS&quot;,</span><br><span class="line">    joinColumns &#x3D; @JoinColumn(name &#x3D; &quot;MEMBER_ID&quot;)</span><br><span class="line">)    </span><br><span class="line">private List&lt;Address&gt; addressHistory &#x3D; new ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p>값 타입 컬렉션의 특징</p>
<ul>
<li>값 타입 컬렉션은 기본적으로 지연 로딩을 사용한다.</li>
<li>값 타입의 생명주기는 엔티티에 종속되어야 하기 때문에,<br>영속성 전이 + 고아 객체 제거 기능이 필수적이라고 할 수 있다.</li>
</ul>
<p>값 타입 컬렉션의 제약 사항</p>
<ul>
<li>값 타입은 엔티티와 달리 식별자가 없어서 변경시 추적할 수가 없다.</li>
<li>변경이 발생하면 주인 엔티티와 관련된 모든 데이터를 삭제하고 값 타입 컬렉션에 있는 현재 값을 모두 다시 저장한다.</li>
<li>값 타입 컬렉션을 매핑하는 테이블은 모든 컬럼을 묶어서 기본 키를 구성해야 한다.</li>
</ul>
<p>=&gt; 값 타입 컬렉션 대신 일대다 관계(영속성 전이 + 고아 객체 제거 기능 포함)를 고려 </p>
]]></content>
      <categories>
        <category>Study</category>
        <category>JPA</category>
      </categories>
      <tags>
        <tag>Spring Data JPA</tag>
        <tag>JPA</tag>
        <tag>ORM</tag>
        <tag>Mapping</tag>
      </tags>
  </entry>
  <entry>
    <title>객체지향 쿼리 언어 (JPQL)</title>
    <url>/2020/11/02/hexo_jpa_04/</url>
    <content><![CDATA[<img src="/img/jpa.png" class="img_class" width="340" height="160" title="jpa">
<h2 id="객체지향-쿼리-언어-JPQL"><a href="#객체지향-쿼리-언어-JPQL" class="headerlink" title="객체지향 쿼리 언어 (JPQL)"></a>객체지향 쿼리 언어 (JPQL)</h2><p>JPA는 다양한 쿼리 방법을 지원한다.<br>(JPQL, JPA Criteria, QueryDSL, 네이티브 SQL, JDBC API 직접 사용)  </p>
<p>JPA를 사용하면 엔티티 객체를 중심으로 개발하게 된다.<br>검색을 할 때도 테이블이 아닌 객체를 대상으로 검색을 할 필요가 있다.<br>이때, 모든 DB를 객체로 변환하는 것은 사실상 불가능하기 때문에<br>애플리케이션에서 필요로 하는 데이터만 객체로 변환하기 위해 결국 검색 조건이 포함된 SQL이 필요하게 된다. </p>
<p>JPQL :<br>SQL을 추상화한 객체 지향 쿼리 언어이다.<br>JPQL을 통해서 객체를 대상으로 SQL과 유사한 문법으로 쿼리할 수 있다.<br>SQL을 추상화했기 때문에 특정 데이터베이스 SQL에 의존하지 않는다.</p>
<p>JPA Criteria :<br>문자가 아닌 자바 코드로 JPQL을 작성할 수 있다.<br>동적 쿼리에 용이하지만 너무 복잡하고 실용성이 없다는 단점이 있다.</p>
<p>QueryDSL :<br>문자가 아닌 자바 코드로 JPQL을 작성할 수 있다.<br>동적 쿼리 작성이 편리하고 컴파일 시점에 문법 오류를 찾을 수 있다.<br>단순하고 쉬워서 실무 사용에 권장된다.  </p>
<p>네이티브 SQL :<br>SQL을 직접 사용하는 기능.<br>JPQL로 해결할 수 없는 특정 데이터베이스에 의존적인 기능이나 문법을 요구할 때 사용한다.</p>
<h3 id="기본-문법"><a href="#기본-문법" class="headerlink" title="기본 문법"></a>기본 문법</h3><h4 id="기본-문법과-쿼리-API"><a href="#기본-문법과-쿼리-API" class="headerlink" title="기본 문법과 쿼리 API"></a>기본 문법과 쿼리 API</h4><p>“select m from Member as m where m.age &gt; 18”  </p>
<ul>
<li>엔티티와 속성은 대소문자를 구분한다. (Member, age)  </li>
<li>JPQL 키워드는 대소문자를 구분하지 않는다. (SELECT, FROM)  </li>
<li>테이블이 아닌 엔티티 이름을 사용한다. (Member)  </li>
<li>별칭이 필수이다.(m)</li>
</ul>
<p>쿼리의 타입<br>TypedQuery : 반환 타입이 명확할 때 사용  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TypedQuery&lt;Movie&gt; query &#x3D; em.createQuery(&quot;select m from Movie m&quot;, Movie.class);</span><br></pre></td></tr></table></figure>
<p>Query : 반환 타입이 명확하지 않을 때 사용  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Query query &#x3D; em.createQuery(&quot;select m.name, m.age from Movie m&quot;);</span><br></pre></td></tr></table></figure>

<p>결과 조회 API<br>query.getResultList() : 결과가 하나 이상일 때, 리스트를 반환, 결과가 없으면 빈 리스트를 반환한다.<br>query.getSingleResult() : 결과가 정확히 하나일 때, 단일 객체를 반환, 결과가 없거나 두 개 이상이면 예외 발생</p>
<p>파라미터 바인딩</p>
<ul>
<li>이름 기준  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TypedQuery query &#x3D; em.createQuery(&quot;SELECT m FROM Member m where m.username &#x3D; :username&quot;, Member.class);</span><br><span class="line">query.setParameter(&quot;username&quot;, usernameParam);</span><br></pre></td></tr></table></figure></li>
<li>위치 기준<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TypedQuery query &#x3D; em.createQuery(&quot;SELECT m FROM Member m where m.username &#x3D; ?1&quot;, Member.class);</span><br><span class="line">query.setParameter(1, usernameParam);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="프로젝션"><a href="#프로젝션" class="headerlink" title="프로젝션"></a>프로젝션</h4><p>SELECT 절에 조회할 대상(엔티티, 임베디드 타입, 스칼라 타입)을 지정하는 것.<br>이 대상들은 영속성 컨텍스트에서 관리되게 된다.</p>
<p>SELECT m FROM Member m : 엔티티 프로젝션<br>SELECT m.team FROM Member m : 엔티티 프로젝션<br>SELECT m.address FROM Member m : 임베디드 타입 프로젝션<br>SELECT m.username, m.age FROM Member m : 스칼라 타입 프로젝션</p>
<p>여러 값을 프로젝션으로 가지는 쿼리 결과 조회하는 방법</p>
<ul>
<li><p>Query 타입으로 조회</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Query query &#x3D; em.createQuery(&quot;select m.name, m.age from Movie m&quot;);</span><br><span class="line">List resultList &#x3D; query.getResultList();</span><br><span class="line"></span><br><span class="line">Object o &#x3D; resultList.get(0);</span><br><span class="line">Object[] result &#x3D; (Object[]) o;</span><br><span class="line">System.out.println(&quot;name &#x3D; &quot;+result[0]);</span><br><span class="line">System.out.println(&quot;age &#x3D; &quot;+result[1]);</span><br></pre></td></tr></table></figure>
</li>
<li><p>Object[] 타입으로 조회</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TypedQuery&lt;Object[]&gt; query &#x3D; em.createQuery(&quot;select m.name, m.age from Movie m&quot;);</span><br><span class="line">List&lt;Object[]&gt; resultList &#x3D; query.getResultList();</span><br><span class="line"></span><br><span class="line">Object[] result &#x3D; resultList.get(0);</span><br><span class="line">System.out.println(&quot;name &#x3D; &quot;+result[0]);</span><br><span class="line">System.out.println(&quot;age &#x3D; &quot;+result[1]);</span><br></pre></td></tr></table></figure>
</li>
<li><p>new 명령어로 조회<br>단순값을 DTO로 바로 조회할 수 있다.<br>패키지명을 포함한 전체 클래스명을 입력해야 하고 순서와 타입이 일치하는 생성자가 필요하다.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List&lt;MemberDTO&gt; result &#x3D; em.createQuery(&quot;select new mypack.MemberDTO(m.name, m.age) from Member m&quot;, MemberDto.class)</span><br><span class="line">        .getResultList();</span><br><span class="line"></span><br><span class="line">MemberDTO memberDTO &#x3D; result.get(0);</span><br><span class="line">System.out.println(&quot;name &#x3D; &quot;+memberDTO.getName());</span><br><span class="line">System.out.println(&quot;age &#x3D; &quot;+memberDTO.getAge());</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="페이징"><a href="#페이징" class="headerlink" title="페이징"></a>페이징</h4><p>JPA는 페이징을 다음 두 API로 추상화하였다.  </p>
<ul>
<li>setFirstResult(int startPosition) : 조회 시작 위치(0 부터)</li>
<li>setMaxResult(int maxResult) : 조회 할 데이터 수<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">em.createQuery(&quot;select m from Member m order by m.age desc&quot;, Member.class);</span><br><span class="line">    .setFirstResult(0)</span><br><span class="line">    .setMaxResult(10)</span><br><span class="line">    .getResultList();</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="조인"><a href="#조인" class="headerlink" title="조인"></a>조인</h4><p>JOIN 절에도 테이블이 아닌 엔티티가 와야한다. (ex) m.team t</p>
<p>JOIN : 내부 조인<br>LEFT JOIN : 외부 조인  </p>
<p>세타 조인도 가능은 하다. (FROM에 두 엔티티)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">em.createQuery(&quot;SELECT m,t FROM Member m, Team t WHERE m.username &#x3D; t.name&quot;);</span><br></pre></td></tr></table></figure>

<p>ON 절 : 조인 대상에서 필터링 할 때 사용한다.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">em.createQuery(&quot;SELECT m,t FROM Member m LEFT JOIN m.team t ON t.name &#x3D; &#39;A&#39;&quot;);</span><br></pre></td></tr></table></figure>
<p>또는 연관관계 없는 엔티티와의 외부 조인에서 사용한다.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">em.createQuery(&quot;SELECT m,t FROM Member m LEFT JOIN m.team t ON m.username &#x3D; t.name&quot;);</span><br></pre></td></tr></table></figure>

<h4 id="서브-쿼리"><a href="#서브-쿼리" class="headerlink" title="서브 쿼리"></a>서브 쿼리</h4><p>쿼리 내부에 또 한번 쿼리를 작성하여 그 결과를 변수처럼 사용하는 방법.</p>
<ul>
<li>평균 나이보다 많은 회원<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">em.createQuery(&quot;SELECT m FROM Member m where m.age &gt; (SELECT avg(m2.age) FROM Member m2)&quot;);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>서브 쿼리 지원 합수<br>EXISTS (sub query): 서브쿼리에 결과가 존재하면 참 (&lt;&gt; NOT EXISTS)</p>
<p>ALL|ANY|SOME (sub query)<br>ALL : 조건이 모두 만족하면 참<br>ANY : 조건이 하나라도 만족하면 참 (== SOME)</p>
<p>IN (sub query) : 서브 쿼리의 결과 중 하나라도 같은 것이 있다면 참 (&lt;&gt; NOT IN)</p>
<p>JPA 서브 쿼리 한계  </p>
<ul>
<li>JPA는 WHERE, HAVING 절에서만 서브 쿼리를 사용할 수 있다.(하이버네이트에서는 SELECT 절에서도 사용가능하다.)</li>
<li>JPQL은 FROM 절에서 서브 쿼리가 불가능하다.</li>
</ul>
<h4 id="JPQL-타입-표현"><a href="#JPQL-타입-표현" class="headerlink" title="JPQL 타입 표현"></a>JPQL 타입 표현</h4><p>문자 : ‘Hello’, ‘She’’s’<br>숫자 : 10L, 10D, 10F<br>Boolean : TRUE, FALSE<br>ENUM : example.MemberType.ADMIN (패키지명을 포함해야한다, 길기 때문에 보통은 파라미터 바운딩 사용)<br>엔티티 타입 : TYPE(i) = Book (상속 관계에서 사용, SQL에서는 DTYPE으로 필터링)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;select i from Item i where type(i) &#x3D; Book&quot;</span><br></pre></td></tr></table></figure>

<h4 id="CASE-식"><a href="#CASE-식" class="headerlink" title="CASE 식"></a>CASE 식</h4><p>SELECT 절에 조건을 추가하여 결과를 조건에 따라 다르게 받을 수 있다.</p>
<ul>
<li><p>기본 CASE 식</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT </span><br><span class="line">    CASE WHEN m.age &lt;&#x3D; 10 THEN &#39;학생요금&#39;</span><br><span class="line">         WHEN m.age &gt;&#x3D; 60 THEN &#39;경로요금&#39;</span><br><span class="line">         ELSE &#39;일반요금&#39;</span><br><span class="line">    END</span><br><span class="line">FROM Member m</span><br></pre></td></tr></table></figure>
</li>
<li><p>단순 CASE 식</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT </span><br><span class="line">    CASE t.name</span><br><span class="line">         WHEN &#39;A&#39; THEN &#39;100명&#39;</span><br><span class="line">         WHEN &#39;B&#39; THEN &#39;200명&#39;</span><br><span class="line">         ELSE &#39;인원제한없음&#39;</span><br><span class="line">    END</span><br><span class="line">FROM Team t</span><br></pre></td></tr></table></figure>
</li>
<li><p>COALESCE : 첫번째 값이 null이 아니면 두번째 주어진 값을 반환</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT COALESCE(m.username, &#39;이름 없는 회원&#39;) FROM Member m</span><br></pre></td></tr></table></figure>
</li>
<li><p>NULLIF : 두 값이 같으면 null을 반환, 다르면 첫번째 값 반환 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT NULLIF(m.username, &#39;관리자&#39;) FROM Member m</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="JPQL-사용자-정의-함수"><a href="#JPQL-사용자-정의-함수" class="headerlink" title="JPQL 사용자 정의 함수"></a>JPQL 사용자 정의 함수</h4><p>사용하기 전에 방언 설정에서 먼저 추가해야 한다.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MyH2Dialect extends H2Dialect &#123;</span><br><span class="line">    public MyH2Dialect() &#123;</span><br><span class="line">        registerFunction(&quot;group_concat&quot;, new StandardSQLFunction(&quot;group_concat&quot;,StandardBasicTypes.STRING));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>hibernate.dialect 변경</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;property name&#x3D;&quot;hibernate.dialect&quot; value&#x3D;&quot;dialect.MyH2Dialect&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>

<p>사용 방법</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">em.createQuery(&quot;select function(&#39;group_concat&#39;,m.username) from Member m&quot;, String.class);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">em.createQuery(&quot;select group_concat(m.username) from Member m&quot;, String.class);</span><br></pre></td></tr></table></figure>

<h3 id="중급-문법"><a href="#중급-문법" class="headerlink" title="중급 문법"></a>중급 문법</h3><h4 id="경로-표현식"><a href="#경로-표현식" class="headerlink" title="경로 표현식"></a>경로 표현식</h4><p>.(점)을 찍어서 객체 그래프를 탐색하는 것</p>
<p>경로 표현식 용어 정리</p>
<ul>
<li>상태 필드 : 단순히 값을 저장하기 위한 필드</li>
<li>연관 필드 : 연관 관계를 위한 필드<ul>
<li>단일 값 연관 필드 : @ManyToOne, @OneToOne, 대상이 엔티티</li>
<li>컬렉션 값 연관 필드 : @OneToMany, @ManyToMany, 대상이 컬렉션</li>
</ul>
</li>
</ul>
<p>경로 표현식의 특징</p>
<ul>
<li>상태 필드 : 경로 탐색의 끝이며 더 이상 탐색할 수 없다.</li>
<li>단일 값 연관 필드 : 묵시적 내부 조인 발생, 추가적으로 탐색할 수 있다.</li>
<li>컬렉션 값 연관 필드 : 묵시적 내부 조인 발생, 더 이상 탐색할 수 없다. </li>
</ul>
<p>묵시적 조인의 주의사항</p>
<ul>
<li>항상 내부 조인</li>
<li>컬렉션은 경로 탐색의 끝이며 추가 탐색을 하려면 명시적 조인을 통해 별칭을 얻어야 한다.</li>
<li>경로 탐색은 주로 SELECT, WHERE 절에서 사용하지만 묵시적 조인으로 인해 SQL의 FROM절에 영향을 준다.</li>
</ul>
<p>=&gt; 가급적 묵시적 조인 대신 명시적 조인 사용.</p>
<h4 id="페치-조인-fetch-join"><a href="#페치-조인-fetch-join" class="headerlink" title="페치 조인 (fetch join)"></a>페치 조인 (fetch join)</h4><p>SQL의 조인 종류가 아니고 JPQL에서 성능 최적화를 위해 제공하는 기능이다.<br>연관된 엔티티나 컬렉션을 SQL 한 번에 함께 조회(즉시 로딩)하는 기능이다.<br>일반 조인과 다른 점은 연관된 엔티티를 함께 조회하느냐 마느냐의 차이이다.  </p>
<p>JPQL</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;select m from Member m join fetch m.team&quot;</span><br></pre></td></tr></table></figure>
<p>SQL </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select M.*, T.* from MEMBER M inner join TEAM T on M.TEAM_ID &#x3D; T.ID;</span><br></pre></td></tr></table></figure>
<p>JPQL에서는 select절에 Member만 있지만 SQL에서는 TEAM 까지 같이 조회한다.<br>이것은 지연로딩으로 설정하더라도 프록시로 조회하지 않고 실제 데이터를 조회하는데,<br>엔티티에 직접 적용하는 글로벌 로딩 전략보다 페치 조인이 우선하기 때문이다.</p>
<p>한편, 컬렉션 페치 조인에서는 중복된 결과가 나오게 될 수도 있다.<br>ex) TEAM A에 MEMBER가 2명인 경우  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List&lt;Team&gt; resultList &#x3D; em.createQuery(&quot;select t from Team t join fetch t.members&quot;, Team.class)</span><br><span class="line">        .getResultList();</span><br><span class="line"></span><br><span class="line">for (Team team : resultList) &#123;</span><br><span class="line">    System.out.println(&quot;teamname &#x3D; &quot;+team.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>결과)<br>teamname = A<br>teamname = A  </p>
<p>이때, 중복 제거를 위해서 DISTINCT를 사용할 수 있다.<br>JPQL의 DISTINCT는 SQL에 DISTINCT를 추가하는 기능 외에<br>애플리케이션에서 엔티티 중복을 제거하는 기능도 가지고 있다.(같은 식별자를 가진 엔티티 제거)</p>
<p>ex)   </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List&lt;Team&gt; resultList &#x3D; em.createQuery(&quot;select distinct t from Team t join fetch t.members&quot;, Team.class)</span><br><span class="line">        .getResultList();</span><br><span class="line"></span><br><span class="line">for (Team team : resultList) &#123;</span><br><span class="line">    System.out.println(&quot;teamname &#x3D; &quot;+team.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>결과)<br>teamname = A  </p>
<p>페치 조인의 특징과 한계</p>
<ul>
<li>페치 조인 대상에는 별칭을 사용할 수 없다. (Hibernate에서는 가능하지만 가급적 사용하지 않는다.)</li>
<li>둘 이상의 컬렉션은 페치 조인할 수 없다.</li>
<li>컬렉션을 페치 조인하면 페이징 API를 사용할 수 없다. (Hibernate는 경고 후 메모리에서 페이징하지만 위험하다.)</li>
</ul>
<p>페이징 API를 써야한다면…<br> =&gt; 컬렉션 페치 조인 대신 단일 값 연관 필드를 페치 조인 한다.<br> 또는 @BatchSize(size) 애노테이션을 이용하여 페치 조인 대신 N+1 문제를 해결한다.</p>
<h4 id="다형성-쿼리"><a href="#다형성-쿼리" class="headerlink" title="다형성 쿼리"></a>다형성 쿼리</h4><p>TYPE<br>조회 대상을 특정 자식으로 한정할 수 있다.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;select i from Item i where type(i) in (Book, Movie)&quot;</span><br></pre></td></tr></table></figure>

<p>TREAT<br>부모 타입을 특정 자식 타입으로 다룰때 사용한다.(자바 다운 캐스팅과 유사하다.)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;select i from Item i where treat(i as Book).auther &#x3D; &#39;kim&#39;&quot;</span><br></pre></td></tr></table></figure>

<h4 id="엔티티-직접-사용"><a href="#엔티티-직접-사용" class="headerlink" title="엔티티 직접 사용"></a>엔티티 직접 사용</h4><p>JPQL에서 엔티티를 사용하면 엔티티의 기본 값(PK)이 사용된다.<br>이것은 파라미터로 전달하거나 식별자를 직접 전달해도 동일하다.<br>ex)<br>JPQL</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;select count(m) from Member m&quot;</span><br></pre></td></tr></table></figure>
<p>SQL</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select count(m.id) from MEMBER m;</span><br></pre></td></tr></table></figure>

<p>또는 연관된 엔티티를 사용하면 엔티티의 외래 키 값(FK)이 사용된다.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List&lt;Member&gt; resultList &#x3D; em.createQuery(&quot;select m from Member m where m.team &#x3D; :team&quot;, Member.class)</span><br><span class="line">    .setParameter(&quot;team&quot;,team1).getResultList();</span><br><span class="line"></span><br><span class="line">for (Member member : resultList) &#123;</span><br><span class="line">    System.out.println(&quot;member &#x3D; &quot; + member.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SQL</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Hibernate: </span><br><span class="line">    &#x2F;* select</span><br><span class="line">        m </span><br><span class="line">    from</span><br><span class="line">        Member m </span><br><span class="line">    where</span><br><span class="line">        m.team &#x3D; :team *&#x2F; select</span><br><span class="line">            member0_.MEMBER_ID as member_i1_4_,</span><br><span class="line">            member0_.createdDate as createdd2_4_,</span><br><span class="line">            member0_.lastModifiedDate as lastmodi3_4_,</span><br><span class="line">            member0_.city as city4_4_,</span><br><span class="line">            member0_.street as street5_4_,</span><br><span class="line">            member0_.zipcode as zipcode6_4_,</span><br><span class="line">            member0_.name as name7_4_,</span><br><span class="line">            member0_.TEAM_ID as team_id8_4_ </span><br><span class="line">        from</span><br><span class="line">            Member member0_ </span><br><span class="line">        where</span><br><span class="line">            member0_.TEAM_ID&#x3D;?</span><br></pre></td></tr></table></figure>
<p>JPQL에서는 where 조건에 Team을 주었는데, SQL에서는 FK(TEAM_ID)로 변환되어 실행 됨.</p>
<h4 id="Named-쿼리"><a href="#Named-쿼리" class="headerlink" title="Named 쿼리"></a>Named 쿼리</h4><p>미리 정의해서 이름을 부여해두고 사용하는 JPQL이다.  </p>
<ul>
<li>정적 쿼리만 가능하다.  </li>
<li>어노테이션이나 XML에 정의하여 사용한다.</li>
<li>애플리케이션 로딩 시점에 초기화 후 재사용된다.</li>
<li>애플리케이션 로딩 시점에 쿼리를 검증한다.(중요)</li>
</ul>
<p>정의하기</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Entity</span><br><span class="line">@NamedQuery(</span><br><span class="line">        name &#x3D; &quot;Member.findByUsername&quot;,</span><br><span class="line">        query &#x3D; &quot;select m from Member m where m.name &#x3D; :name&quot;</span><br><span class="line">)</span><br><span class="line">public class Member &#123;</span><br><span class="line">    ~</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>사용하기</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List&lt;Member&gt; resultList &#x3D; em.createNamedQuery(&quot;Member.findByUsername&quot;, Member.class)</span><br><span class="line">    .setParameter(&quot;name&quot;, &quot;member1&quot;)</span><br><span class="line">    .getResultList();</span><br></pre></td></tr></table></figure>

<h4 id="벌크-연산"><a href="#벌크-연산" class="headerlink" title="벌크 연산"></a>벌크 연산</h4><p>쿼리 한번으로 여러 로우(엔티티)를 변경할 수 있다.</p>
<ul>
<li>UPDATE, DELETE 지원</li>
<li>excuteUpdate()의 결과는 영향받은 엔티티의 수를 반환한다.</li>
<li>INSERT 지원 (insert into .. select, Hibernate)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int resultCount &#x3D; em.createQuery(&quot;update Member m set m.createdDate &#x3D; :createdDate&quot;)</span><br><span class="line">    .setParameter(&quot;createdDate&quot;, LocalDateTime.now())</span><br><span class="line">    .executeUpdate();</span><br></pre></td></tr></table></figure>

<p>벌크 연산은 영속성 컨텍스트를 무시하고 DB에 직접 쿼리한다.<br>=&gt; 꼬임 방지를 위해 영속성 컨텍스트 작업보다 먼저 벌크 연산을 수행 하거나,<br> 벌크 연산 후 영속성 컨텍스트를 초기화하자.</p>
]]></content>
      <categories>
        <category>Study</category>
        <category>JPA</category>
      </categories>
      <tags>
        <tag>Spring Data JPA</tag>
        <tag>JPA</tag>
        <tag>ORM</tag>
        <tag>Mapping</tag>
        <tag>JPQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Data JPA</title>
    <url>/2020/11/16/hexo_spring_data_jpa_01/</url>
    <content><![CDATA[<img src="/img/springdatajpa.png" class="img_class" width="340" height="320" title="springdatajpa">
<h2 id="Spring-Data-JPA"><a href="#Spring-Data-JPA" class="headerlink" title="Spring Data JPA"></a>Spring Data JPA</h2><p>Spring Data JPA 원리</p>
<p>JpaRepository&lt;Entity, Id&gt; 인터페이스</p>
<ul>
<li>데이터 접근 오브젝트 역할을 하는 매직 인터페이스.</li>
<li>@Repository 애노테이션 없이 빈으로 등록 됨.</li>
<li>기본적으로 CRUD 메서드를 제공해준다.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface PostRepository extends JpaRepository&lt;Post, Long&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<dl><dt>@EnableJpaRepository</dt><dd>@Configuration 스프링 설정 클래스에 붙여야 JpaRepository 인터페이스를 사용할 수 있다.<br>(스프링 부트에서는 자동으로 설정된다.)</dd></dl><p>@EnableJpaRepository는 JpaRepositoriesRegistrar.class를 import 하는데,<br>이 클래스가 JpaRepository 인터페이스를 상속받는 인터페이스 타입의 빈을 만들어서 등록해주는 역할을 한다.<br>(핵심은 spring의 ImportBeanDefinitionRegistrar 인터페이스, 애노테이션이 아닌 프로그래밍을 통해 빈을 등록할 수 있음.)</p>
<p>특히 스프링 부트 스타터 JPA 같은 경우,<br>HibernateJpaAutoConfiguration 자동 설정에 의하여 EntityManagerFactory가 빈으로 등록된다.<br>또한 EntityManager나 TransactionManager를 빈으로 주입 받아 사용할 수 있다.</p>
<p>SQL을 확인하는 법(application.properties)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring.jpa.show-sql&#x3D;true</span><br><span class="line">spring.jpa.properties.hibernate.format_sql&#x3D;true </span><br><span class="line">logging.level.org.hibernate.type.descriptor.sql&#x3D;true</span><br></pre></td></tr></table></figure>


<h3 id="Spring-Data-Common"><a href="#Spring-Data-Common" class="headerlink" title="Spring Data Common"></a>Spring Data Common</h3><p>여러 저장소 지원 프로젝트(Spring Data JPA, JDBC, KeyValue, 등)의 공통 기능을 제공하는 프로젝트.</p>
<h4 id="리포지토리"><a href="#리포지토리" class="headerlink" title="리포지토리"></a>리포지토리</h4><p>Spring Data Common</p>
<ul>
<li>Repository : 단순히 리포지토리라는 마크.</li>
<li>CrudRepository : CRUD 기능<br>save(entity), saveAll(entities), findById(id), …</li>
<li>PagingAndSortingRepository : 페이징, 정렬 기능<br>findAll(pageable), findAll(sort)</li>
</ul>
<p>Spring Data JPA</p>
<ul>
<li>JpaRepository : JPA 기능 추가</li>
</ul>
<h4 id="인터페이스-정의하기"><a href="#인터페이스-정의하기" class="headerlink" title="인터페이스 정의하기"></a>인터페이스 정의하기</h4><p>제공되는 메소드를 사용하지 않고 직접 정의하고 싶다면<br>@RepositoryDefinition 애노테이션 사용.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RepositoryDefinition(domainClass &#x3D; Comment.class, idClass &#x3D; Long.class)</span><br><span class="line">public interface CommentRepository &#123;</span><br><span class="line"></span><br><span class="line">    Comment save(Comment comment);</span><br><span class="line"></span><br><span class="line">    List&lt;Comment&gt; findAll();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>직접 정의하지 않으면 아무 기능이 없으며 Spring Data JPA가 구현을 도와준다. </p>
<p>공통 인터페이스를 따로 정의하고 싶다면<br>@NoRepositoryBean 애노테이션 사용.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@NoRepositoryBean</span><br><span class="line">public interface MyRepository&lt;T, Id extends Serializable&gt; extends Repository&lt;T, Id&gt; &#123;</span><br><span class="line"></span><br><span class="line">    &lt;E extends T&gt; E save(E entity);</span><br><span class="line">    </span><br><span class="line">    List&lt;T&gt; findall();</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>다른 리포지토리에서 이 인터페이스를 상속받아 사용하면 된다.</p>
<h4 id="Null-처리"><a href="#Null-처리" class="headerlink" title="Null 처리"></a>Null 처리</h4><ul>
<li><p>Spring Data 2.0부터 자바 8의 Optional을 지원한다.<br>=&gt; 반환 값이 없을 때 Null과는 다르며 Optional 객체에서 사용할 수 있는 메소드를 사용할 수 있다.</p>
</li>
<li><p>콜렉션은 Null을 리턴하지 않고 비어있는 콜렉션을 리턴한다.<br>=&gt; 콜렉션 Null 체크 하지 말자.</p>
</li>
<li><p>Null 애노테이션(@NonNullApi, @NonNull, @Nullable)을 지원한다.<br>=&gt; 런타임 시에 Null여부를 체크할 수 있다.</p>
</li>
</ul>
<h4 id="쿼리-만들기-개요"><a href="#쿼리-만들기-개요" class="headerlink" title="쿼리 만들기 개요"></a>쿼리 만들기 개요</h4><p>쿼리 탐색 전략</p>
<ul>
<li><p>메소드 이름을 분석해서 쿼리 만들기(CREATE)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List&lt;Comment&gt; findByTitleContains(String keyword);</span><br></pre></td></tr></table></figure>
<p>Spring Data JPA가 이름을 분석하여 쿼리를 만들어준다.</p>
</li>
<li><p>미리 정의된 쿼리를 찾아 사용하기(USE_DECLARED_QUERY)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Query(&quot;select c from Comment c where c.title like :keyword&quot;)</span><br><span class="line">List&lt;Comment&gt; findByTitleContains(String keyword);</span><br></pre></td></tr></table></figure>
<p>@Query, @NamedQuery<br>메소드 이름만으로는 쿼리를 표현하기 힘든 경우 사용한다.</p>
</li>
<li><p>미리 정의된 쿼리를 찾아 사용하되 없으면 메소드 이름 분석하여 쿼리 만들기(CREATE_IF_NOT_FOUND)<br>, 기본 전략</p>
</li>
</ul>
<p>전략 설정은 @EnableJpaRepositories 애노테이션에서 한다.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableJpaRepositories(queryLookupStrategy &#x3D; QueryLookupStrategy.Key.CREATE_IF_NOT_FOUND)</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line">    ~</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>메소드 이름으로 쿼리 만들 때 주의할 점.</p>
<ul>
<li><p>카멜 케이스를 사용한다.</p>
</li>
<li><p>프로퍼티를 표현할 때 경로 표현식은 ‘.’ 대신 ‘_’를 사용한다.<br>ex) Address.zipcode =&gt; Address_Zipcode</p>
</li>
<li><p>리턴 타입을 Page&lt;&gt;로 받으려면 Pageable 파라미터를 받아야한다. </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Page&lt;Comment&gt; findByTitleContains(String keyword, Pageable pageable);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>정렬 쿼리 예시</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List&lt;Person&gt; findByLastnameOrderByFirstnameAsc(String lastname);</span><br><span class="line">List&lt;Person&gt; findByLastnameOrderByFirstnameDesc(String lastname);</span><br></pre></td></tr></table></figure>

<p>페이징 쿼리 예시</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Page&lt;Person&gt; findByLastname(String lastname, Pageable pageable);</span><br><span class="line">Slice&lt;Person&gt; findByLastname(String lastname, Pageable pageable);</span><br><span class="line">List&lt;Person&gt; findByLastname(String lastname, Pageable pageable);</span><br><span class="line">List&lt;Person&gt; findByLastname(String lastname, Sort sort);</span><br></pre></td></tr></table></figure>

<p>스트리밍 쿼리 예시</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Stream&lt;User&gt; readAllByFirstnameNotNull();</span><br></pre></td></tr></table></figure>
<ul>
<li>try-with-resource를 사용할 것. (Stream을 다 사용한 뒤에 close() 해야하며 AutoCloseable을 구현하였으므로)<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try(Stream&lt;Post&gt; postStream &#x3D; postRepository.findByTitleContains(&quot;good&quot;)) &#123;</span><br><span class="line">    String title &#x3D; postStream.findFirst().get().getTitle();</span><br><span class="line">    assertThat(title).isEqualTo(&quot;good&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h4 id="비동기-쿼리-메소드"><a href="#비동기-쿼리-메소드" class="headerlink" title="비동기 쿼리 메소드"></a>비동기 쿼리 메소드</h4><p>비동기 실행을 위해서 설정 필요 (@EnableAsync)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@EnableJpaRepositories</span><br><span class="line">@EnableAsync</span><br><span class="line">public class Application &#123;</span><br><span class="line">    ~</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>비동기 쿼리 예시</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Async </span><br><span class="line">Future&lt;User&gt; findByFirstname(String firstname);</span><br><span class="line">@Async </span><br><span class="line">CompletableFuture&lt;User&gt; findOneByFirstname(String firstname);</span><br><span class="line">@Async </span><br><span class="line">ListenableFuture&lt;User&gt; findOneByLastname(String lastname);</span><br></pre></td></tr></table></figure>
<ul>
<li>메서드를 스프링 TaskExecutor에 전달하여 별도의 쓰레드에서 실행된다. Reactive와는 다름.</li>
</ul>
<p>비동기 쿼리가 트랜젝션이 열려있는 도중에 실행된다면 해당 트랜잭션의 작업을 알지 못하는 것을 주의해야 한다.<br>(테스트에서는 그렇게 동작하는데 실제 애플리케이션에서 어떻게 동작할지는 모르겠음.)</p>
<h4 id="커스텀-리포지토리"><a href="#커스텀-리포지토리" class="headerlink" title="커스텀 리포지토리"></a>커스텀 리포지토리</h4><p>쿼리 메소드(쿼리 만들기와 쿼리 찾아 사용하기)로 해결이 안되는 경우 직접 코딩으로 구현할 수 있다.</p>
<ul>
<li>스프링 데이터 리포지토리 인터페이스에 기능 추가.</li>
<li>스프링 데이터 리포지토리 기본 기능 덮어쓰기(재정의) 가능.(커스텀이 더 높은 우선순위를 가진다.)</li>
</ul>
<p>구현하는 방법</p>
<ul>
<li><p>커스텀 리포지토리 인터페이스 정의</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface PostCustomRepository&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    List&lt;T&gt; findMyPosts();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>인터페이스 구현 클래스 만들기(Impl, @Repository)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Repository</span><br><span class="line">public class PostCustomRepositoryImpl implements PostCustomRepository&lt;Post&gt; &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private EntityManager em;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public List&lt;Post&gt; findMyPosts() &#123;</span><br><span class="line">        return em.createQuery(&quot;select p from Post p&quot;,Post.class).getResultList();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>기본적으로 접미어는 “Impl”를 사용해야 한다.<br>사용할 접미어는 @EnableJpaRepositories 애노테이션에서 바꿀 수 있다.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@EnableJpaRepositories(repositoryImplementationPostfix &#x3D; &quot;Impl&quot;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>엔티티 리포지토리에 커스텀 리포지토리 인터페이스 추가</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface PostRepository extends JpaRepository&lt;Post, Long&gt;, PostCustomRepository&lt;Post&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h4 id="기본-리포지토리-커스터마이징"><a href="#기본-리포지토리-커스터마이징" class="headerlink" title="기본 리포지토리 커스터마이징"></a>기본 리포지토리 커스터마이징</h4><p>모든 엔티티 리포지토리에 공통적으로 추가하거나 덮어 쓰고 싶은 기능이 있다면</p>
<ul>
<li><p>JpaRepository를 상속받는 인터페이스 추가 (@NoRepositoryBean)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@NoRepositoryBean</span><br><span class="line">public interface MyRepository&lt;T, Id extends Serializable&gt; extends JpaRepository&lt;T, Id&gt; &#123;</span><br><span class="line"></span><br><span class="line">    boolean contains(T entity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>기본 구현체(SimpleJpaRepository)를 상속받는 커스텀 구현체 만들기</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MyRepositoryImpl&lt;T, Id extends Serializable&gt; extends SimpleJpaRepository&lt;T, Id&gt; implements MyRepository&lt;T, Id&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private EntityManager em;</span><br><span class="line"></span><br><span class="line">    public MyRepositoryImpl(JpaEntityInformation&lt;T, ?&gt; entityInformation, EntityManager entityManager) &#123;</span><br><span class="line">        super(entityInformation, entityManager);</span><br><span class="line">        this.em &#x3D; entityManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public MyRepositoryImpl(Class&lt;T&gt; domainClass, EntityManager em) &#123;</span><br><span class="line">        super(domainClass, em);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean contains(Object entity) &#123;</span><br><span class="line">        return em.contains(entity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>@EnableJpaRepositories 설정</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@EnableJpaRepositories(repositoryBaseClass &#x3D; MyRepositoryImpl.class)</span><br></pre></td></tr></table></figure>
</li>
<li><p>JpaRepository 대신 생성한 기본 리포지토리를 상속받으면 정의한 기능을 사용할 수 있다.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface PostRepository extends MyRepository&lt;Post, Long&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h4 id="도메인-이벤트"><a href="#도메인-이벤트" class="headerlink" title="도메인 이벤트"></a>도메인 이벤트</h4><p>도메인의 변경을 감지할 이벤트 리스너를 만들고 이벤트를 발생할 수 있다. (Spring의 이벤트 기능 사용)  </p>
<p>이벤트 클래스 생성</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class PostPublishedEvent extends ApplicationEvent &#123;</span><br><span class="line"></span><br><span class="line">    private final Post post;</span><br><span class="line"></span><br><span class="line">    public PostPublishedEvent(Object source) &#123;</span><br><span class="line">        super(source);</span><br><span class="line">        this.post &#x3D; (Post) source;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Post getPost() &#123;</span><br><span class="line">        return post;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>리스너(이벤트 핸들러) 클래스 생성</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class PostListener &#123;</span><br><span class="line"></span><br><span class="line">    @EventListener</span><br><span class="line">    public void handle(PostPublishedEvent postPublishedEvent) &#123;</span><br><span class="line">        System.out.println(&quot;--&quot;);</span><br><span class="line">        System.out.println(postPublishedEvent.getPost().getTitle() + &quot; is published&quot;);</span><br><span class="line">        System.out.println(&quot;--&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>스프링 데이터의 도메인 이벤트 Publisher : save() 할때 이벤트 발생<br>@DomainEvents : 이벤트를 받아 콜렉션으로 모아놓음<br>@AfterDomainEventPublication : 이벤트 콜렉션 클린업  </p>
<p>extends AbstractAggregationRoot<T> : 위의 두개의 기능이 구현되어 있는 스프링 데이터에서 제공하는 구현체</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Entity</span><br><span class="line">public class Post extends AbstractAggregateRoot&lt;Post&gt; &#123;</span><br><span class="line">    ~</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;엔티티에 해당 엔티티에 대한 이벤트를 담는 메서드 생성</span><br><span class="line">    public Post publish() &#123;</span><br><span class="line">        this.registerEvent(new PostPublishedEvent(this));</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Post post &#x3D; new Post();</span><br><span class="line">post.setTitle(&quot;good&quot;);</span><br><span class="line">post.publish();</span><br><span class="line">postRepository.save(post);</span><br></pre></td></tr></table></figure>
<p>save()하기 전에 이벤트만 넣어주면??<br>담겨있던 이벤트가 save() 시점에 자동으로 발생하며 리스너가 동작하게 된다.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--</span><br><span class="line">good is published</span><br><span class="line">--</span><br></pre></td></tr></table></figure>
<p>=&gt; Event 객체를 생성하고 publish 하는 코드가 생략될 수 있다.</p>
<h4 id="QueryDSL-연동"><a href="#QueryDSL-연동" class="headerlink" title="QueryDSL 연동"></a>QueryDSL 연동</h4><p>QueryDSL을 사용하는 이유중 하나는 조건문을 표현하는 방법이 타입 세이프 하다는 것. (자바 코드로 표현 가능)</p>
<p><a href="http://www.querydsl.com/static/querydsl/4.1.3/reference/html_single/#jpa_integration" target="_blank" rel="noopener">http://www.querydsl.com/static/querydsl/4.1.3/reference/html_single/#jpa_integration</a>  </p>
<p>의존성 추가</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;com.querydsl&lt;&#x2F;groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;querydsl-apt&lt;&#x2F;artifactId&gt;</span><br><span class="line">  &lt;version&gt;$&#123;querydsl.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">  &lt;scope&gt;provided&lt;&#x2F;scope&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;com.querydsl&lt;&#x2F;groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;querydsl-jpa&lt;&#x2F;artifactId&gt;</span><br><span class="line">  &lt;version&gt;$&#123;querydsl.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.slf4j&lt;&#x2F;groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;slf4j-log4j12&lt;&#x2F;artifactId&gt;</span><br><span class="line">  &lt;version&gt;1.6.1&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<p>maven 플러그인 설정</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;plugin&gt;</span><br><span class="line">    &lt;groupId&gt;com.mysema.maven&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;apt-maven-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.1.3&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;executions&gt;</span><br><span class="line">        &lt;execution&gt;</span><br><span class="line">            &lt;goals&gt;</span><br><span class="line">                &lt;goal&gt;process&lt;&#x2F;goal&gt;</span><br><span class="line">            &lt;&#x2F;goals&gt;</span><br><span class="line">            &lt;configuration&gt;</span><br><span class="line">                &lt;outputDirectory&gt;target&#x2F;generated-sources&#x2F;java&lt;&#x2F;outputDirectory&gt;</span><br><span class="line">                &lt;processor&gt;com.querydsl.apt.jpa.JPAAnnotationProcessor&lt;&#x2F;processor&gt;</span><br><span class="line">            &lt;&#x2F;configuration&gt;</span><br><span class="line">        &lt;&#x2F;execution&gt;</span><br><span class="line">    &lt;&#x2F;executions&gt;</span><br><span class="line">&lt;&#x2F;plugin&gt;</span><br></pre></td></tr></table></figure>

<p>이 상태에서 컴파일을 하면 ‘target/generated-sources/java’ 위치에 QueryDSL이 쿼리 생성용 클래스를 만들게 된다.<br>(ex) Post 클래스가 있으면 QPost</p>
<p>QuerydslPredicateExecutor<T> : QueryDSL이 제공하는 인터페이스</p>
<ul>
<li>Optional<T> findOne(Predicate) : 하나를 찾을 때</li>
<li>List<T>|Page<T>|.. findAll(Predicate) : 여러개 찾을 때<br>QuerydslPredicateExecutor 인터페이스는 QuerydslJpaRepository 클래스가 구현하고 있다.</li>
</ul>
<p>리포지토리 QuerydslPredicateExecutor 상속 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface PostRepository extends JpaRepository&lt;Post, Long&gt;, QuerydslPredicateExecutor&lt;Post&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="웹-지원-기능"><a href="#웹-지원-기능" class="headerlink" title="웹 지원 기능"></a>웹 지원 기능</h4><ul>
<li>DomainClassConverter<br>Spring Data JPA가 지원하는 String을 도메인 객체로 변환해주는 컨버터이다.<br>보통 URI를 @PathVariable 애노테이션을 이용하여 객체로 바로 바인딩할 때 사용한다.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@GetMapping(&quot;&#x2F;posts&#x2F;&#123;id&#125;&quot;)</span><br><span class="line">public Post getPost(@PathVariable(&quot;id&quot;) Post post) &#123;</span><br><span class="line">    return post; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Pageable / Sort 매개변수<br>Spring Data JPA를 사용하면 핸들러 메소드에서 페이징과 정렬 관련된 매개 변수를 받을 수 있다.  </li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@GetMapping(&quot;&#x2F;posts&quot;)</span><br><span class="line">public Page&lt;Post&gt; getPosts(Pageable pageable) &#123;</span><br><span class="line">    return postRepository.findAll(pageable); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>관련 매개 변수</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mockMvc.perform(get(&quot;&#x2F;posts&quot;)</span><br><span class="line">        .param(&quot;page&quot;,&quot;0&quot;)</span><br><span class="line">        .param(&quot;size&quot;,&quot;20&quot;)</span><br><span class="line">        .param(&quot;sort&quot;,&quot;created,desc&quot;)</span><br><span class="line">        .param(&quot;sort&quot;,&quot;title&quot;))</span><br></pre></td></tr></table></figure>

<ul>
<li>HATEOAS<br>Spring HATEOAS와 연계하여 응답에 페이징과 관련된 링크를 추가할 수 있다. </li>
</ul>
<p>의존성</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-hateoas&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<p>PagedResourcesAssembler를 매개변수로 받을 수 있으며 그를 통해 Page를 PagedModel(구 PagedResource)로 변환할 수 있다.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@GetMapping(&quot;&#x2F;posts&quot;)</span><br><span class="line">public PagedModel&lt;EntityModel&lt;Post&gt;&gt; getPosts(Pageable pageable, PagedResourcesAssembler&lt;Post&gt; assembler) &#123;</span><br><span class="line">    return assembler.toModel(postRepository.findAll(pageable));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="Spring-Data-JPA-1"><a href="#Spring-Data-JPA-1" class="headerlink" title="Spring Data JPA"></a>Spring Data JPA</h3><h4 id="EnableJpaRepositories"><a href="#EnableJpaRepositories" class="headerlink" title="@EnableJpaRepositories"></a>@EnableJpaRepositories</h4><p>@EnableJpaRepositories</p>
<ul>
<li>@Configuration에서 설정해야 JpaRepository를 사용할 수 있다. </li>
<li>부트에서는 자동 설정이다.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@EnableJpaRepositories</span><br><span class="line">public class Application &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="JpaRepository-save"><a href="#JpaRepository-save" class="headerlink" title="JpaRepository save()"></a>JpaRepository save()</h4><p>JpaRepository의 save()는 단순히 새 엔티티를 추가하는 메서드가 아니다.</p>
<ul>
<li>Transient 상태의 객체는 EntityManager.persist()</li>
<li>Detached 상태의 객체는 EntityManager.merge()</li>
</ul>
<p>둘 다 Persistent 상태로 만든다는 것은 동일하지만 내부적인 차이점이 있다.<br>persist()는 파라미터로 받은 객체를 Persistent 상태로 만들지만,<br>merge()는 파라미터로 받은 객체의 복사본을 만들어서 그 복사본을 Persistent 상태로 만든다.<br>save()는 Persistent 상태로 만든 엔티티를 반환하게 되는데<br>그렇기 때문에 persist()는 파라미터와 반환값은 서로 동일한 인스턴스인 반면 merge()는 파라미터와 반환값이 서로 다른 인스턴스이다.<br>=&gt; persist() 이든 merge() 이든 파라미터를 재사용하기보다는 반환값을 이용하자.</p>
<p>엔티티의 상태가 Transient인지 Detached인지 판단하는 기준</p>
<ul>
<li>엔티티의 @Id 프로퍼티를 찾아 null이면 Transient, null이 아니면 Detached</li>
<li>엔티티가 Persistable 인터페이스를 구현하고 있다면 isNew() 메소드에 위임한다.</li>
<li>JpaRepositoryFactory를 상속받는 클래스를 만들고 getEntityInformation()을 오버라이딩해서 자신이 원하는 판단 로직을 구현할 수도 있다.</li>
</ul>
<h4 id="쿼리-메소드"><a href="#쿼리-메소드" class="headerlink" title="쿼리 메소드"></a>쿼리 메소드</h4><p>쿼리 생성하기</p>
<p><a href="https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#jpa.query-methods.query-creation" target="_blank" rel="noopener">https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#jpa.query-methods.query-creation</a></p>
<p>쿼리 찾아쓰기</p>
<ul>
<li>엔티티에 정의한 쿼리 찾아 사용하기 (JPA Named 쿼리)<ul>
<li>@NamedQuery</li>
<li>@NamedNativeQuery</li>
</ul>
</li>
<li>리포지토리 메소드에 정의한 쿼리 사용하기<ul>
<li>@Query</li>
<li>@Query(nativeQuery=true)</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Entity</span><br><span class="line">@NamedQuery(name &#x3D; &quot;Post.findByTitle&quot;, query &#x3D; &quot;SELECT p From Post p WHERE p.title &#x3D; ?1&quot;)</span><br><span class="line">public class Post &#123;</span><br><span class="line">    ~</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface PostRepository extends JpaRepository&lt;Post, Long&gt; &#123;</span><br><span class="line"></span><br><span class="line">    List&lt;Post&gt; findByTitle(String title);</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List&lt;Post&gt; posts &#x3D; postRepository.findByTitle(&quot;go&quot;);</span><br></pre></td></tr></table></figure>
<p>리포지토리에 정의한 findByTitle()는 쿼리를 생성하지 않고 Post Entity에서 Post.findByTitle를 찾아서 사용한다.</p>
<p>엔티티에 정의하면 엔티티 클래스가 지저분해지는 단점이 있다.<br> =&gt; 리포지토리 메소드에 정의</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface PostRepository extends JpaRepository&lt;Post, Long&gt; &#123;</span><br><span class="line"></span><br><span class="line">    @Query(&quot;SELECT p FROM Post p WHERE p.title &#x3D; ?1&quot;)</span><br><span class="line">    List&lt;Post&gt; findByTitle(String title);</span><br></pre></td></tr></table></figure>


<h4 id="Sort"><a href="#Sort" class="headerlink" title="Sort"></a>Sort</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Query(&quot;SELECT p FROM Post p WHERE p.title &#x3D; ?1&quot;)</span><br><span class="line">List&lt;Post&gt; findByTitle(String title, Sort sort);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List&lt;Post&gt; posts &#x3D; postRepository.findByTitleStartsWith(&quot;good&quot;, Sort.by(&quot;title&quot;));</span><br></pre></td></tr></table></figure>

<p>@Query에서 Pageable이나 Sort를 매개변수로 사용할때의 제약사항 :<br>ORDER BY 절에서 함수를 호출하는 경우 Sort를 사용할 수 없다.<br> =&gt; JpaSort.unsafe() 사용.</p>
<p>Sort의 안에서 사용한 프로퍼티 또는 alias가 엔티티에 없는 경우 예외가 발생한다.</p>
<p>예)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List&lt;Post&gt; posts &#x3D; postRepository.findByTitle(&quot;good&quot;, Sort.by(&quot;LENGTH(title)&quot;));</span><br></pre></td></tr></table></figure>

<p>JpaSort.unsafe()를 사용하면 함수 호출이 가능하다.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List&lt;Post&gt; posts &#x3D; postRepository.findByTitle(&quot;good&quot;, JpaSort.unsafe(&quot;LENGTH(title)&quot;));</span><br></pre></td></tr></table></figure>


<h4 id="NamedParameter와-SpEL"><a href="#NamedParameter와-SpEL" class="headerlink" title="NamedParameter와 SpEL"></a>NamedParameter와 SpEL</h4><p>NamedParameter (@Param)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Query(&quot;SELECT p FROM Post p WHERE p.title &#x3D; :title&quot;)</span><br><span class="line">List&lt;Post&gt; findByTitle(@Param(&quot;title&quot;) String keyword);</span><br></pre></td></tr></table></figure>

<p>SpEL<br> : 스프링 표현 언어, @Query에서 엔티티 이름을 변수로 표현할 수 있다.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Query(&quot;SELECT p FROM #&#123;#entityName&#125; p WHERE p.title &#x3D; :title&quot;)</span><br><span class="line">List&lt;Post&gt; findByTitle(@Param(&quot;title&quot;) String keyword);</span><br></pre></td></tr></table></figure>
<p>특정 엔티티의 리포지토리 안에서 해당 엔티티의 이름이 자동으로 들어간다.</p>
<h4 id="Update-쿼리-메소드"><a href="#Update-쿼리-메소드" class="headerlink" title="Update 쿼리 메소드"></a>Update 쿼리 메소드</h4><p>보통은 JPA의 Dirty Checking을 통해서 flush 할때 Update 쿼리가 자동으로 발생하게 되지만,<br>만약 Update 쿼리를 직접 정의해서 사용하고 싶다면?<br> =&gt; @Modifying와 @Query 어노테이션 사용</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Modifying</span><br><span class="line">@Query(&quot;UPDATE Post p SET p.title &#x3D; :title WHERE p.id &#x3D; :id&quot;)</span><br><span class="line">int updateTitle(@Param(&quot;title&quot;) String title,</span><br><span class="line">                @Param(&quot;id&quot;) Long id);</span><br></pre></td></tr></table></figure>

<p>이렇게 정의한 메소드를 사용하여 발생한 Update 쿼리는 실제로 DB에서 실행되지만,<br>JPA의 영속성 컨텍스트는 이 변경을 감지하지 못하기 때문에<br>영속성 컨텍스트의 1차 캐시에 이미 있던 정보는 변하지 않는다.<br>그렇기 때문에 Update 쿼리 발생 후에도 1차 캐시에서 엔티티를 조회하면 변경되지 않은 데이터를 참조하게 될 수도 있다.</p>
<p>clearAutomatically 옵션을 사용하여 1차 캐시를 미리 비워두는 우회법이 있긴 하다.  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Modifying(clearAutomatically &#x3D; true)</span><br></pre></td></tr></table></figure>
<p>그렇다 하더라도 별로임. =&gt; 애플리케이션 로직으로 Update 하는 것이 맞다.</p>
<h4 id="EntityGraph"><a href="#EntityGraph" class="headerlink" title="EntityGraph"></a>EntityGraph</h4><p>쿼리 메소드마다 Fetch 모드를 설정 할 수 있다.</p>
<p>@NamedEntityGraph : @Entity에서 재사용할 여러 엔티티 그룹을 정의할 때 사용한다.  </p>
<p>@NamedEntityGraph(name = 이름, attributeNodes = @NamedAttributeNode(EAGER로 가져올 연관관계))</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@NamedEntityGraph(name &#x3D; &quot;Comment.post&quot;</span><br><span class="line">        ,attributeNodes &#x3D; @NamedAttributeNode(&quot;post&quot;))</span><br><span class="line">@Entity</span><br><span class="line">public class Comment &#123;</span><br><span class="line"></span><br><span class="line">    ~</span><br><span class="line"></span><br><span class="line">    @ManyToOne(fetch &#x3D; FetchType.LAZY)</span><br><span class="line">    private Post post;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@EntityGraph : @NamedEntityGraph에 정의되어 있는 엔티티 그룹을 사용.  </p>
<p>그래프 타입을 설정할 수 있다.</p>
<ul>
<li>FETCH : 설정한 엔티티 애트리뷰트는 EAGER 패치, 나머지는 LAZY 패치. (default)</li>
<li>LOAD : 설정한 엔티티 애트리뷰트는 EAGER 패치, 나머지는 기본 패치 전략.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@EntityGraph(value &#x3D; &quot;Comment.post&quot;)</span><br><span class="line">Optional&lt;Comment&gt; loadById(Long id);</span><br></pre></td></tr></table></figure>
<p>엔티티에서는 LAZY 모드로 설정되어 있지만, 이 메소드를 사용할 때는 EAGER 모드를 사용하게 된다.</p>
<p>@NamedEntityGraph 를 정의하지 않고 @EntityGraph에서 바로 정의할 수도 있다.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@EntityGraph(attributePaths &#x3D; &quot;post&quot;)</span><br><span class="line">    Optional&lt;Comment&gt; getById(Long id);</span><br></pre></td></tr></table></figure>


<h4 id="Projection"><a href="#Projection" class="headerlink" title="Projection"></a>Projection</h4><p>엔티티의 일부 데이터만 가져오기.</p>
<p>인터페이스 기반 프로젝션</p>
<ul>
<li><dl><dt>Closed Projection</dt><dd>가져오려는 애트리뷰트만 가져오기 때문에 쿼리 최적화 가능, default 메소드 사용 가능.</dd></dl><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface CommentSummary &#123;</span><br><span class="line"></span><br><span class="line">    String getContent();</span><br><span class="line">    int getUp();</span><br><span class="line">    int getDown();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List&lt;CommentSummary&gt; findByPost_Id(Long id);</span><br></pre></td></tr></table></figure>
</li>
<li><dl><dt>Open Projection</dt><dd>@Value(SpEL)을 사용해서 연산 가능, SpEL이 엔티티 대상이기 때문에 쿼리 최적화 불가능.</dd></dl><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface CommentSummary &#123;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;#&#123;target.up + &#39; &#39; + target.down&#125;&quot;)</span><br><span class="line">    String getVotes();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>만약 연산을 Closed Projection에서 하고 싶다면?<br> =&gt; 인터페이스의 default 메서드 사용.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface CommentSummary &#123;</span><br><span class="line"></span><br><span class="line">    String getContent();</span><br><span class="line">    int getUp();</span><br><span class="line">    int getDown();</span><br><span class="line"></span><br><span class="line">    default String getVotes() &#123;</span><br><span class="line">        return getUp() + &quot; &quot; + getDown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>클래스 기반 프로젝션</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class CommentSummary &#123;</span><br><span class="line"></span><br><span class="line">    private String content;</span><br><span class="line">    private int up;</span><br><span class="line">    private int down;</span><br><span class="line"></span><br><span class="line">    public CommentSummary(String content, int up, int down) &#123;</span><br><span class="line">        this.content &#x3D; content;</span><br><span class="line">        this.up &#x3D; up;</span><br><span class="line">        this.down &#x3D; down;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getContent() &#123;</span><br><span class="line">        return content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getUp() &#123;</span><br><span class="line">        return up;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getDown() &#123;</span><br><span class="line">        return down;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getVotes() &#123;</span><br><span class="line">        return getUp() + &quot; &quot; + getDown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>인터페이스 기반과 별다른 차이는 없지만 롬복을 사용할 수 있다는 장점이 있다.</p>
<p>다이나믹 프로젝션 :<br>프로젝션 용 메서드 하나에서 어떤 프로젝션을 사용할지 인자로 받을 수 있다.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;T&gt; List&lt;T&gt; findByPost_Id(Long id, Class&lt;T&gt; type);</span><br></pre></td></tr></table></figure>


<h4 id="Specifications"><a href="#Specifications" class="headerlink" title="Specifications"></a>Specifications</h4><p>조건절을 Predicate와 유사한 Spec으로 정의할 수 있다.</p>
<p>설정 방법<br><a href="https://docs.jboss.org/hibernate/stable/jpamodelgen/reference/en-US/html_single/" target="_blank" rel="noopener">https://docs.jboss.org/hibernate/stable/jpamodelgen/reference/en-US/html_single/</a></p>
<p>의존성</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.hibernate&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;hibernate-jpamodelgen&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<p>메이븐 플러그인 설정</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;plugin&gt;</span><br><span class="line">    &lt;groupId&gt;org.bsc.maven&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;maven-processor-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.0.5&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;executions&gt;</span><br><span class="line">        &lt;execution&gt;</span><br><span class="line">            &lt;id&gt;process&lt;&#x2F;id&gt;</span><br><span class="line">            &lt;goals&gt;</span><br><span class="line">                &lt;goal&gt;process&lt;&#x2F;goal&gt;</span><br><span class="line">            &lt;&#x2F;goals&gt;</span><br><span class="line">            &lt;phase&gt;generate-sources&lt;&#x2F;phase&gt;</span><br><span class="line">            &lt;configuration&gt;</span><br><span class="line">                &lt;processors&gt;</span><br><span class="line">                    &lt;processor&gt;org.hibernate.jpamodelgen.JPAMetaModelEntityProcessor&lt;&#x2F;processor&gt;</span><br><span class="line">                &lt;&#x2F;processors&gt;</span><br><span class="line">            &lt;&#x2F;configuration&gt;</span><br><span class="line">        &lt;&#x2F;execution&gt;</span><br><span class="line">    &lt;&#x2F;executions&gt;</span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.hibernate&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;hibernate-jpamodelgen&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;$&#123;hibernate.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;&#x2F;dependencies&gt;</span><br><span class="line">&lt;&#x2F;plugin&gt;</span><br></pre></td></tr></table></figure>

<p>Repository 상속 추가 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface CommentRepository extends JpaRepository&lt;Comment, Long&gt;, JpaSpecificationExecutor&lt;Comment&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Spec 정의하기 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class CommentSpecs &#123;</span><br><span class="line"></span><br><span class="line">    public static Specification&lt;Comment&gt; isBest() &#123;</span><br><span class="line">        return new Specification&lt;Comment&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public Predicate toPredicate(Root&lt;Comment&gt; root</span><br><span class="line">                    , CriteriaQuery&lt;?&gt; criteriaQuery</span><br><span class="line">                    , CriteriaBuilder criteriaBuilder) &#123;</span><br><span class="line">                return criteriaBuilder.isTrue(root.get(Comment_.best));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Specification&lt;Comment&gt; isGood() &#123;</span><br><span class="line">        return new Specification&lt;Comment&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public Predicate toPredicate(Root&lt;Comment&gt; root</span><br><span class="line">                    , CriteriaQuery&lt;?&gt; criteriaQuery</span><br><span class="line">                    , CriteriaBuilder criteriaBuilder) &#123;</span><br><span class="line">                return criteriaBuilder.greaterThan(root.get(Comment_.up), 10);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Spec 사용하기</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">commentRepository.findAll(CommentSpecs.isBest().and(CommentSpecs.isGood()));</span><br></pre></td></tr></table></figure>
<p>=&gt; Spec 구현에 따라서 사용되는 쪽의 쿼리 가독성을 제공한다.</p>
<h4 id="트랜젝션"><a href="#트랜젝션" class="headerlink" title="트랜젝션"></a>트랜젝션</h4><p>스프링 데이터 JPA가 제공하는 Repository의 모든 메소드에는 기본적으로 @Transactional이 적용되어 있다.</p>
<p>@Transactional<br> : 클래스, 인터페이스, 메소드에서 사용할 수 있으며, 메소드에 가장 가까운 애노테이션이 우선 순위가 높다.<br><a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/transaction/annotation/Transactional.html" target="_blank" rel="noopener">https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/transaction/annotation/Transactional.html</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Transactional(readOnly &#x3D; true)</span><br><span class="line">List&lt;CommentSummary&gt; findByPost_Id(Long id);</span><br></pre></td></tr></table></figure>

<p>JPA의 구현체로 Hibernate를 사용할 때 트랜잭션을 readOnly로 설정했을 때 장점<br> : readOnly는 Flush 모드를 NEVER로 설정하여 Dirty Checking을 하지 않도록 함. =&gt; 성능적 이점</p>
<h4 id="Auditing"><a href="#Auditing" class="headerlink" title="Auditing"></a>Auditing</h4><p>엔티티 변경 시점에 언제, 누가 변경했는지에 대한 정보를 기록하는 기능이다.<br>스프링 부트 자동 설정 없음.</p>
<p>메인 어플리케이션에서 @EnableJpaAuditing 추가</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@EnableJpaRepositories</span><br><span class="line">@EnableJpaAuditing</span><br><span class="line">public class Application &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Auditing 기능을 사용할 엔티티에 @EntityListeners(AuditingEntityListener.class) 추가</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Entity</span><br><span class="line">@EntityListeners(AuditingEntityListener.class)</span><br><span class="line">public class Comment &#123;</span><br><span class="line">    ~</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AuditorAware 추가</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class AccountAuditorAware implements AuditorAware&lt;Account&gt; &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Optional&lt;Account&gt; getCurrentAuditor() &#123;</span><br><span class="line">        &#x2F;&#x2F;시큐리티를 통해 현재 user를 꺼내오는 로직 필요</span><br><span class="line">        return Optional.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@EnableJpaAuditing(auditorAwareRef &#x3D; &quot;accountAuditorAware&quot;)</span><br></pre></td></tr></table></figure>

<p>엔티티 프로퍼티 설정</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@CreatedDate</span><br><span class="line">private Date created;</span><br><span class="line"></span><br><span class="line">@CreatedBy</span><br><span class="line">@ManyToOne</span><br><span class="line">private Account createdBy;</span><br><span class="line"></span><br><span class="line">@LastModifiedDate</span><br><span class="line">private Date updated;</span><br><span class="line"></span><br><span class="line">@LastModifiedBy</span><br><span class="line">@ManyToOne</span><br><span class="line">private Account updatedBy;</span><br></pre></td></tr></table></figure>

<p>Auditing 대신 @PrePersist와 @PreUpdate등 JPA 라이프 사이클 이벤트를 활용할 수도 있다. </p>
<p>엔티티 클래스에서 콜백 정의</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@PrePersist</span><br><span class="line">public void prePersist() &#123;</span><br><span class="line">    System.out.println(&quot;Pre Persist is called&quot;);</span><br><span class="line">    &#x2F;&#x2F;엔티티가 영속화 되기 전 실행 될 로직을 추가하여 사용</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>이</p>
]]></content>
      <categories>
        <category>Study</category>
        <category>Spring Framework</category>
      </categories>
      <tags>
        <tag>Spring Data JPA</tag>
        <tag>JPA</tag>
        <tag>JPQL</tag>
      </tags>
  </entry>
</search>
